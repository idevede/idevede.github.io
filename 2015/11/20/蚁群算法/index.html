<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>蚁群算法 | Dove&#39;s bolg</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文在CSDN的地址：点这里 自1991年由意大利学者 M. Dorigo，V. Maniezzo 和 A. Colorni 通过模拟蚁群觅食行为提出了一种基于种群的模拟进化算法——蚁群优化。">
<meta name="keywords" content="蚁群算法，算法设计">
<meta property="og:type" content="article">
<meta property="og:title" content="蚁群算法">
<meta property="og:url" content="https://idevede.github.io/2015/11/20/蚁群算法/index.html">
<meta property="og:site_name" content="Dove&#39;s bolg">
<meta property="og:description" content="本文在CSDN的地址：点这里 自1991年由意大利学者 M. Dorigo，V. Maniezzo 和 A. Colorni 通过模拟蚁群觅食行为提出了一种基于种群的模拟进化算法——蚁群优化。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-07-06T06:26:55.689Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蚁群算法">
<meta name="twitter:description" content="本文在CSDN的地址：点这里 自1991年由意大利学者 M. Dorigo，V. Maniezzo 和 A. Colorni 通过模拟蚁群觅食行为提出了一种基于种群的模拟进化算法——蚁群优化。">
  
    <link rel="alternate" href="/atom.xml" title="Dove&#39;s bolg" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Dove&#39;s bolg</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://idevede.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-蚁群算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/20/蚁群算法/" class="article-date">
  <time datetime="2015-11-20T13:19:31.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      蚁群算法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/49952133" target="_blank" rel="noopener">点这里</a></p>
<p>自1991年由意大利学者 M. Dorigo，V. Maniezzo 和 A. Colorni 通过模拟蚁群觅食行为提出了一种基于种群的模拟进化算法——蚁群优化。<br><a id="more"></a></p>
<h2 id="蚁群算法简介"><a href="#蚁群算法简介" class="headerlink" title="蚁群算法简介"></a>蚁群算法简介</h2><p>自1991年由意大利学者 M. Dorigo，V. Maniezzo 和 A. Colorni 通过模拟蚁群觅食行为提出了一种基于种群的模拟进化算法——蚁群优化。该算法的出现引起了学者们的极大关注，蚁群算法的特点：</p>
<p> ① 其原理是一种正反馈机制或称增强型学习系统; 它通过【最优路径上蚂蚁数量的增加→信息素强度增加→后来蚂蚁选择概率增大→最优路径上蚂蚁数量更大增加】达到最终收敛于最优路径上L</p>
<p>② 它是一种通用型随机优化方法, 它吸收了蚂蚁的行为特(内在搜索机制) , 它是使用人工蚂蚁仿真(也称蚂蚁系统) 来求解问题L但人工蚂蚁决不是对实际蚂蚁的一种简单模拟, 它融进了人类的智能L人工蚂蚁有一定的记忆; 人工蚂蚁不完全是瞎的; 人工蚂蚁生活的时空是离散的L</p>
<p>③ 它是一种分布式的优化方法, 不仅适合目前的串行计算机, 而且适合未来的并行计算机L</p>
<p>④ 它是一种全局优化的方法, 不仅可用于求解单目标优化问题, 而且可用于求解多目标优化问题L</p>
<p>⑤ 它是一种启发式算法, 计算复杂性为o (Nc<em>n2</em>m) , 其中Nc 是迭代次数, m 是蚂蚁数目, n 是目的节点数目L</p>
<p>蚁群发现最短路径的原理和机制[1]</p>
<p>下面用图 1解释蚁群发现最短路径的原理和机制。</p>
<p>如图 1(a)所示，在蚁巢和食物源之间有两条道路 Nest-A-B-D-Food 和Nest-A-C-D-Food，其长度分别为 4 和 6。单位时间内蚂蚁可移动一个单位长度的距离。开始时所有路径上都没有外激素。</p>
<p>如图 1(b)，在 t=0 时刻，20 只蚂蚁从蚁巢出发移动到 A。由于路径上没有外激素，它们以相同概率选择左侧或右侧道路，因此平均有 10 只蚂蚁走左侧，另外 10 只走右侧。</p>
<p>如图 1(c)，在 t=4 时刻，第一组先到达食物源的蚂蚁将折回。</p>
<p>如图 1(d)，在 t=5 时刻，两组蚂蚁将在 D 点相遇。此时 BD 上的外激素数量与 CD 上的相同，因此返回的 10 只蚂蚁中有 5 只选择 BD 而另 5 只选择 CD。</p>
<p>如图 1(e)，在 t=8 时刻，前 5 个蚂蚁将返回巢穴，而在 AC、CD 和 AB 上各有 5 个蚂蚁。</p>
<p>如图 1(f)，在 t=9 时刻，前 5 个蚂蚁又回到 A 并且再次面对往左还是往右的选择。这时，AB 上的轨迹数是 20 而 AC 上是 15，因此将有较为多数的蚂蚁选择往右，从而增强了 AB 上外激素的量。随着该过程的继续，两条道路上外激素数量的差距将越来越大，直至绝大多数蚂蚁都选择了最短的路径。正是由于一条道路要比另一条道路短，因此，在相同的时间间隔内，短的路线会有更多的机会被选择。</p>
<p>根据仿生学家的研究结果,蚂蚁凭借路径寻优的能力能够找到蚁巢与食物之间的最短路径,其原理在于:蚂蚁在所经过的路径上留下一种挥发性分泌物(pheromone,以下称为信息素),信息素随着时间的推移会逐渐挥发消失.蚂蚁在觅食过程中能够感知这种物质的存在及其强度,并以此来指导自己的运动方向,倾向于朝着这种物质强度高的方向移动,即选择该路径的概率与当时这条路径上该物质的强度成正比.信息素强度越高的路径,选择它的蚂蚁就越多,则在该路径上留下的信息素的强度就更大,而强度大的信息素又吸引更多的蚂蚁,从而形成一种正反馈.通过这种正反馈,蚂蚁最终可以发现最佳路径,导致大部分的蚂蚁都会走此路径.</p>
<p>以求解ｎ个城市的ＴＳＰ旅行商问题为例说明ＡＣＡ模型.</p>
<p>设蚁群中蚂蚁的数量为ｍ,ｄij (ｉ,ｊ=1,2,…,ｎ)表示城市ｉ和城市ｊ之间的距离,ｂi(ｔ)表示ｔ时刻位于城市ｉ的蚂蚁的个数,则有 表示ｔ时刻在城市ｉ,ｊ连线上残留的信息量.初始时刻,各条路径上信息量相等,设τｉｊ(0)=Ｃ(Ｃ为常数).蚂蚁ｋ(ｋ=1,2,…,ｍ)在运动过程中,根据各条路径上的信息量决定转移方向. 表示在ｔ时刻蚂蚁ｋ由城市ｉ转移到城市ｊ的概率.</p>
<p>   （1）</p>
<p>残留信息的重要程度;β——启发信息的重要程度;tabuk——记录蚂蚁ｋ当前所走过的城市,称为记忆列表,ｋ=1,2,…,ｍ,集合tabuk随着进化过程作动态调整.经过ｎ个时刻,所有蚂蚁都完成了一次遍历.此时,计算每一只蚂蚁所走过的路径Ｌｋ,并保存最短路径Ｌｍｉｎ=ｍｉｎ{Ｌｋ︱ｋ=1,2,…,ｍ}.在蚂蚁完成一次循环以后,各路径上的信息量进行如下调整</p>
<p>τｉｊ(ｔ+1)=(1-ρ)τｉｊ(ｔ)+Δτｉｊ    (2)</p>
<p>式中ρ∈(0,1),表示信息素τｉｊ(ｔ)随时间的推移而衰减的程度.所以1-ρ为信息素残留因子，开始时Δτｉｊ（0）=0，</p>
<p>信息素增量Δτｉｊ可表示             (3)</p>
<p>式中Δτｋｉｊ为蚂蚁ｋ在本次循环中在城市ｉ和ｊ之间留下的信息量,它的计算公式根据具体问题而定.Dorigo曾给出Δτｋｉｊ3种不同的模型,分别称为Ant-Cycle模型、Ant-Quantity模型、Ant-Density模型，它们的区别就在于信息素的更新机制,即其差别在于Δτｋｉｊ</p>
<p>在Ant-Cycle模型中：</p>
<p>（4） 式中，Q表示信息素强度，它在一定程度上影响算法的收敛速度；Lk表示第K只蚂蚁在本次循环中所奏路径的总长度。</p>
<p>在Ant-Quantity模型中：</p>
<p>（5） 式中，Q表示信息素强度，它在一定程度上影响算法的收敛速度；dij表示第K只蚂蚁在t和t+1之间经过的（ i, j ）</p>
<p>在Ant-Density模型中：</p>
<p>（6） 区别:式(5)式(6)中利用的是局部信息，即蚂蚁完成一步后更新路径上的信息素；而式(4)中利用的是整体信息，即蚂蚁完成一个循环后所有路径上的信息素。经过大量试验总结研究，采用式(4)性能较好，所以 Ant-Cycle模型是最优的。</p>
<p>以上说明了信息素残留因子1-ρ、信息启发式因子α、期望启发式因子β、信息素强度Q、蚂蚁数目M等都是非常重要的参数，其选区方式和选区原则直接影响到蚁群算法的全局收敛性和求解效率。我们学习到这种“三步走”[2]选择蚁群算法最优组合参数的有效方法：</p>
<p>（1） 确定蚂蚁数目M，根据 城市规模 / 蚂蚁数目 ≈1.5的选择策略来确定蚂蚁的总数目。</p>
<p>（2） 参数粗调，即调整数值范围较大的信息启发式因子α、期望启发式因子β、信息素强度Q等参数，已得到较理想的解。</p>
<p>（3） 参数微调，即调整数值范围较小的信息素残留因子1-ρ。</p>
<h2 id="目前蚁群算法的应用"><a href="#目前蚁群算法的应用" class="headerlink" title="目前蚁群算法的应用"></a>目前蚁群算法的应用</h2><p>虽然对蚁群算法的研究时间不长, 但是初步研究已显示出它在求解复杂优化问题方面具有很大的优势, 特别是1998 年在比利时布鲁塞尔专门召开了第一届蚂蚁优化国际研讨会后, 现在每两年召开一次这样的蚂蚁优化国际研讨会。这标志着蚁群算法的研究已经得到了国际上的广泛支持，使得这种新兴的智能进化仿生算法展现出了勃勃生机[3]。</p>
<p>以蚁群算法为代表的群体智能已成为当今分布式人工智能研究的一个热点,许多源于蜂群和蚁群模型设计的算法已越来越多地被用于企业的运转模式的研究。美国五角大楼正在资助关于群体智能系统的研究工作–群体战略(SWARM STRATEGY),它的一个实战用途是通过运用成群的空中无人驾驶飞行器和地面车辆来转移敌人的注意力,让自己的军队在敌人后方不被察觉地安全行进。英国电信公司和美国世界通信公司以电子蚂蚁为基础,对新的电信网络管理方法进行了试验。群体智能还被应用于工厂生产计划的制定和运输部门的后勤管理。美国太平洋西南航空公司采用了一种直接源于蚂蚁行为研究成果的运输管理软件,结果每年至少节约了1000万美元费用开支。英国联合利华公司已率先利用群体智能技术改善其一家牙膏厂的运转状况。美国通用汽车公司,法国液气公司,荷兰公路交通部和美国一些移民事务机构也都采用这种技术来改善其运转的机能。又如美国MCIWorld.com公司一直研究人工蚂蚁，并用于管理公司的电话网，对用户记账收费等工作。另外，还设计“人工蚂蚁”打算用于因特网的路由管理。鉴于群体智能广阔的应用前景,美国和欧洲联盟均于近几年开始出资资助基于群体智能模拟的相关研究项目, 关在一些院校开设群体智能的相关课程.牛津大学出版社1999年版的E.Bonabeau和M.Dorigo等人编写的专著《群体智能:从自然到人工系统》(Swarm Intelligence:From Natural to Artificial System),以及2001年出版的J.Kennedy和R.Eberhart编著的《群体智能》(Swarm Intelligence)进一步扩大了群体智能的影响.IEEE进化计算会刊也于2002年8月出版了蚁群优化算特刊。国内也有研究者用蚂蚁算法求解全国144个城市的最短回路问题，求得的解同其它方法求到得解一样精确，这说明蚂蚁算法不但是求解组合优化问题的可行方法，而且是一种很有竞争力的算法。国家自然科学基金”十五”期间学科交叉类优先资助领域中的认知科学及其信息处理的研究内容中也明确列出了群体智能领域的进化,自适应与现场认知主题[4]。而且从1999年开始，几乎每年都会有几项相关项目获得资助。蚁群算法是一种新型的模拟进化算法，其在数据挖掘中的应用正逐步引起人们的关注。目前，人工蚁群在知识发现的过程中主要用于发掘聚类模型和分类模型。</p>
<h3 id="蚁群算法在数据挖掘中的应用"><a href="#蚁群算法在数据挖掘中的应用" class="headerlink" title="蚁群算法在数据挖掘中的应用"></a>蚁群算法在数据挖掘中的应用</h3><p>聚类是将一组对象分成若干个群体，每个群体构成一个簇，使得簇内的对象尽可能具有最大的相似性，不同簇之间的对象尽可能有最大的相异性。目前，聚类方法主要有K均值法，模糊聚类、神经网络聚类、基于遗传算法的聚类、小波变换聚类以及将这些算法有效结合而形成的改进方法。随着蚁群算法研究的兴起，人们发现在某些方面采用蚁群模型进行聚类更加接近实际的聚类问题。将蚁群算法用于聚类分析,灵感源于蚂蚁堆积他们的尸体和分类他们的幼体。基于蚁群算法的聚类方法从原理上可分为两种：一种是基于蚁堆形成原理来实现数据聚类，另一种是运用蚂蚁觅食的原理，利用信息来实现聚类分析。</p>
<p>而数据是数据挖掘的另一个重要主题，它是在数据库对象集合中寻找属性，并根据分类模式将其划分为不同类别的过程。分类过程利用历史数据记录自动推导出对给定数据的分类树。分类器构造方法有统计学方法、机器学习法、神经网络、决策树等。从知识发现的观点来看，分类规则的表达方式形如if&lt;条件&gt;then&lt;类&gt;规则前件（if 部分）包含一组条件集合，一般由逻辑连接符连接；规则结论（then部分）定义了样本的预测类，这些样本的预测属性满足规则前件所定义的所有条件[5]。将蚁群算法引入分类规则的发现，是利用蚁群觅食原理在数据库中进行搜索，对随机产生的一组规则进行选择优化，直到数据库能被该组规则覆盖，从而挖掘出隐含在数据库中的规则，建立最优的分类模型。蚁群算法搜索的初始条件为发现规则的集合为空，且训练集包含所有的训练样本。蚂蚁搜索一次要完成规则生成、规则剪枝、信息素更新三个任务。一次搜索生成一条规则，并且将这条规则加入发现规则集合，同时将该条规则所覆盖的训练样本从训练集中删除。如果未覆盖训练样本的数目大于用户定义的阈值，即最大未覆盖样本数，就反复执行上述过程，最终算法将得到一组最优分类规则集合[5]。 </p>
<p>最早在这一领域开展工作的是Deneubourg 等[6],他们根据数据对象与其周围对象的相似性,让蚂蚁随机地移动、拾起或放下数据对象,以达到聚类数据的目的,这个基本模型已成功地应用于机器人领域。Lumer 等首先改进此算法,提出了LF算法。Wu 等、Ramos等、Yang等[7]从不同角度对LF算法进行了改进,在用蚁群算法进行聚类分析方面取得了一定成效。近几年，学者在这方面的研究从来没有间断过，也取得了一定的研究成果。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>不过，将蚁群算法运用于数据发掘还存在一些问题，需要进一步研究：</p>
<p>（1）如何将现实的挖掘任务转换成蚁群求解的问题空间，并用适当的方式表达。如何定义“人工蚂蚁”以及蚂蚁间的非直接通信方式（如路径上的信息素、对象的分布状态等）的选择。</p>
<p>（2）如何建立正反馈机制，定义启发函数，递增地进行问题求解，并且使得到的解与问题定义中现实世界的情况相对应。</p>
<p>（3）基于蚁群的算法要初始化大量的参数，这些参数的选择会对算法的性能产生较大的影响，但其选取的方法和原则目前尚无理论上的依据，只能通过多次实验调优，因此参数的最佳设置原则还有待进一步研究。</p>
<p>（4）蚁群算法的搜索时间较长，如何将蚁群算法与遗传算法、免疫算法等优化算法相结合，改善和提高算法性能，以适应海量数据库的知识发现。</p>
<p>所以如何在数据挖掘中运用蚁群算法快速、高效地获得高质量的知识越来越受到人们的关注，逐渐成为近期的研究热点[5]。</p>
<h2 id="Matlab实现蚁群算法"><a href="#Matlab实现蚁群算法" class="headerlink" title="Matlab实现蚁群算法"></a>Matlab实现蚁群算法</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[R_best,L_best,L_ave,Shortest_Route,Shortest_Length]</span>=<span class="title">ACATSP</span><span class="params">(C,NC_max,m,Alpha,Beta,Rho,Q)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%-------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主要符号说明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% C n个城市的坐标，n×2的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% NC_max 最大迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% m 蚂蚁个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Alpha 表征信息素重要程度的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Beta 表征启发式因子重要程度的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Rho 信息素蒸发系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Q 信息素增加强度系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% R_best 各代最佳路线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% L_best 各代最佳路线的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%=========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第一步：变量初始化</span></span><br><span class="line"></span><br><span class="line">n=<span class="built_in">size</span>(C,<span class="number">1</span>);<span class="comment">%n表示问题的规模（城市个数）</span></span><br><span class="line"></span><br><span class="line">D=<span class="built_in">zeros</span>(n,n);<span class="comment">%D表示完全图的赋权邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">i</span>~=<span class="built_in">j</span></span><br><span class="line"></span><br><span class="line">D(<span class="built_in">i</span>,<span class="built_in">j</span>)=((C(<span class="built_in">i</span>,<span class="number">1</span>)-C(<span class="built_in">j</span>,<span class="number">1</span>))^<span class="number">2</span>+(C(<span class="built_in">i</span>,<span class="number">2</span>)-C(<span class="built_in">j</span>,<span class="number">2</span>))^<span class="number">2</span>)^<span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">D(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="built_in">eps</span>;      <span class="comment">%i=j时不计算，应该为0，但后面的启发因子要取倒数，用eps（浮点相对精度）表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">D(<span class="built_in">j</span>,<span class="built_in">i</span>)=D(<span class="built_in">i</span>,<span class="built_in">j</span>);   <span class="comment">%对称矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Eta=<span class="number">1.</span>/D;          <span class="comment">%Eta为启发因子，这里设为距离的倒数</span></span><br><span class="line"></span><br><span class="line">Tau=<span class="built_in">ones</span>(n,n);     <span class="comment">%Tau为信息素矩阵</span></span><br><span class="line"></span><br><span class="line">Tabu=<span class="built_in">zeros</span>(m,n);   <span class="comment">%存储并记录路径的生成</span></span><br><span class="line"></span><br><span class="line">NC=<span class="number">1</span>;               <span class="comment">%迭代计数器，记录迭代次数</span></span><br><span class="line"></span><br><span class="line">R_best=<span class="built_in">zeros</span>(NC_max,n);       <span class="comment">%各代最佳路线</span></span><br><span class="line"></span><br><span class="line">L_best=<span class="built_in">inf</span>.*<span class="built_in">ones</span>(NC_max,<span class="number">1</span>);   <span class="comment">%各代最佳路线的长度</span></span><br><span class="line"></span><br><span class="line">L_ave=<span class="built_in">zeros</span>(NC_max,<span class="number">1</span>);        <span class="comment">%各代路线的平均长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> NC&lt;=NC_max        <span class="comment">%停止条件之一：达到最大迭代次数，停止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第二步：将m只蚂蚁放到n个城市上</span></span><br><span class="line"></span><br><span class="line">Randpos=[];   <span class="comment">%随即存取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:(<span class="built_in">ceil</span>(m/n))</span><br><span class="line"></span><br><span class="line">Randpos=[Randpos,randperm(n)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Tabu(:,<span class="number">1</span>)=(Randpos(<span class="number">1</span>,<span class="number">1</span>:m))';    <span class="comment">%此句不太理解？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第三步：m只蚂蚁按概率函数选择下一座城市，完成各自的周游</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">2</span>:n     <span class="comment">%所在城市不计算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m    </span><br><span class="line"></span><br><span class="line">visited=Tabu(<span class="built_in">i</span>,<span class="number">1</span>:(<span class="built_in">j</span><span class="number">-1</span>)); <span class="comment">%记录已访问的城市，避免重复访问</span></span><br><span class="line"></span><br><span class="line">J=<span class="built_in">zeros</span>(<span class="number">1</span>,(n-<span class="built_in">j</span>+<span class="number">1</span>));       <span class="comment">%待访问的城市</span></span><br><span class="line"></span><br><span class="line">P=J;                      <span class="comment">%待访问城市的选择概率分布</span></span><br><span class="line"></span><br><span class="line">Jc=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(<span class="built_in">find</span>(visited==k))==<span class="number">0</span>   <span class="comment">%开始时置0</span></span><br><span class="line"></span><br><span class="line">J(Jc)=k;</span><br><span class="line"></span><br><span class="line">Jc=Jc+<span class="number">1</span>;                         <span class="comment">%访问的城市个数自加1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%下面计算待选城市的概率分布</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">length</span>(J)</span><br><span class="line"></span><br><span class="line">P(k)=(Tau(visited(<span class="keyword">end</span>),J(k))^Alpha)*(Eta(visited(<span class="keyword">end</span>),J(k))^Beta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">P=P/(sum(P));</span><br><span class="line"></span><br><span class="line"><span class="comment">%按概率原则选取下一个城市</span></span><br><span class="line"></span><br><span class="line">Pcum=cumsum(P);     <span class="comment">%cumsum，元素累加即求和</span></span><br><span class="line"></span><br><span class="line">Select=<span class="built_in">find</span>(Pcum&gt;=<span class="built_in">rand</span>); <span class="comment">%若计算的概率大于原来的就选择这条路线</span></span><br><span class="line"></span><br><span class="line">to_visit=J(Select(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>)=to_visit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> NC&gt;=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Tabu(<span class="number">1</span>,:)=R_best(NC<span class="number">-1</span>,:);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第四步：记录本次迭代最佳路线</span></span><br><span class="line"></span><br><span class="line">L=<span class="built_in">zeros</span>(m,<span class="number">1</span>);     <span class="comment">%开始距离为0，m*1的列向量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</span><br><span class="line"></span><br><span class="line">R=Tabu(<span class="built_in">i</span>,:);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">L(<span class="built_in">i</span>)=L(<span class="built_in">i</span>)+D(R(<span class="built_in">j</span>),R(<span class="built_in">j</span>+<span class="number">1</span>));    <span class="comment">%原距离加上第j个城市到第j+1个城市的距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">L(<span class="built_in">i</span>)=L(<span class="built_in">i</span>)+D(R(<span class="number">1</span>),R(n));      <span class="comment">%一轮下来后走过的距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">L_best(NC)=min(L);           <span class="comment">%最佳距离取最小</span></span><br><span class="line"></span><br><span class="line">pos=<span class="built_in">find</span>(L==L_best(NC));</span><br><span class="line"></span><br><span class="line">R_best(NC,:)=Tabu(pos(<span class="number">1</span>),:); <span class="comment">%此轮迭代后的最佳路线</span></span><br><span class="line"></span><br><span class="line">L_ave(NC)=mean(L);           <span class="comment">%此轮迭代后的平均距离</span></span><br><span class="line"></span><br><span class="line">NC=NC+<span class="number">1</span>                      <span class="comment">%迭代继续</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第五步：更新信息素</span></span><br><span class="line"></span><br><span class="line">Delta_Tau=<span class="built_in">zeros</span>(n,n);        <span class="comment">%开始时信息素为n*n的0矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">Delta_Tau(Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>),Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>+<span class="number">1</span>))=Delta_Tau(Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>),Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>+<span class="number">1</span>))+Q/L(<span class="built_in">i</span>);          </span><br><span class="line"></span><br><span class="line"><span class="comment">%此次循环在路径（i，j）上的信息素增量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Delta_Tau(Tabu(<span class="built_in">i</span>,n),Tabu(<span class="built_in">i</span>,<span class="number">1</span>))=Delta_Tau(Tabu(<span class="built_in">i</span>,n),Tabu(<span class="built_in">i</span>,<span class="number">1</span>))+Q/L(<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%此次循环在整个路径上的信息素增量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Tau=(<span class="number">1</span>-Rho).*Tau+Delta_Tau; <span class="comment">%考虑信息素挥发，更新后的信息素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第六步：禁忌表清零</span></span><br><span class="line"></span><br><span class="line">Tabu=<span class="built_in">zeros</span>(m,n);             <span class="comment">%%直到最大迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第七步：输出结果</span></span><br><span class="line"></span><br><span class="line">Pos=<span class="built_in">find</span>(L_best==min(L_best)); <span class="comment">%找到最佳路径（非0为真）</span></span><br><span class="line"></span><br><span class="line">Shortest_Route=R_best(Pos(<span class="number">1</span>),:) <span class="comment">%最大迭代次数后最佳路径</span></span><br><span class="line"></span><br><span class="line">Shortest_Length=L_best(Pos(<span class="number">1</span>)) <span class="comment">%最大迭代次数后最短距离</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)                  <span class="comment">%绘制第一个子图形</span></span><br><span class="line"></span><br><span class="line">DrawRoute(C,Shortest_Route)     <span class="comment">%画路线图的子函数</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)                  <span class="comment">%绘制第二个子图形</span></span><br><span class="line"></span><br><span class="line">plot(L_best)</span><br><span class="line"></span><br><span class="line">hold on                         <span class="comment">%保持图形</span></span><br><span class="line"></span><br><span class="line">plot(L_ave,<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line">title(<span class="string">'平均距离和最短距离'</span>)     <span class="comment">%标题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DrawRoute</span><span class="params">(C,R)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%=========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% DrawRoute.m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画路线图的子函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%-------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% C Coordinate 节点坐标，由一个N×2的矩阵存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% R Route 路线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%=========================================================================</span></span><br><span class="line"></span><br><span class="line">N=<span class="built_in">length</span>(R);</span><br><span class="line"></span><br><span class="line">scatter(C(:,<span class="number">1</span>),C(:,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line">plot([C(R(<span class="number">1</span>),<span class="number">1</span>),C(R(N),<span class="number">1</span>)],[C(R(<span class="number">1</span>),<span class="number">2</span>),C(R(N),<span class="number">2</span>)],<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ii=<span class="number">2</span>:N</span><br><span class="line"></span><br><span class="line">plot([C(R(ii<span class="number">-1</span>),<span class="number">1</span>),C(R(ii),<span class="number">1</span>)],[C(R(ii<span class="number">-1</span>),<span class="number">2</span>),C(R(ii),<span class="number">2</span>)],<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title(<span class="string">'旅行商问题优化结果 '</span>)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://idevede.github.io/2015/11/20/蚁群算法/" data-id="cjj9nlmd8000shhqt1vnile5j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/蚁群算法，算法设计/">蚁群算法，算法设计</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/08/我眼中的操作系统中断/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          我眼中的操作系统中断
        
      </div>
    </a>
  
  
    <a href="/2015/10/12/git学习笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">git学习笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/学习心得/">学习心得</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/学习心得/">学习心得</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GUI/">GUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中断/">中断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/哈弗曼树/">哈弗曼树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓/">安卓</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构，算法设计/">数据结构，算法设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件操作/">文件操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动开发/">移动开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络编程/">网络编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/蚁群算法，算法设计/">蚁群算法，算法设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/译码/">译码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件安装/">软件安装</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GUI/" style="font-size: 10px;">GUI</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/中断/" style="font-size: 10px;">中断</a> <a href="/tags/哈弗曼树/" style="font-size: 16.67px;">哈弗曼树</a> <a href="/tags/安卓/" style="font-size: 10px;">安卓</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/数据结构/" style="font-size: 20px;">数据结构</a> <a href="/tags/数据结构，算法设计/" style="font-size: 10px;">数据结构，算法设计</a> <a href="/tags/文件操作/" style="font-size: 16.67px;">文件操作</a> <a href="/tags/最小生成树/" style="font-size: 10px;">最小生成树</a> <a href="/tags/移动开发/" style="font-size: 10px;">移动开发</a> <a href="/tags/编码/" style="font-size: 16.67px;">编码</a> <a href="/tags/网络编程/" style="font-size: 10px;">网络编程</a> <a href="/tags/蚁群算法，算法设计/" style="font-size: 10px;">蚁群算法，算法设计</a> <a href="/tags/译码/" style="font-size: 16.67px;">译码</a> <a href="/tags/软件安装/" style="font-size: 13.33px;">软件安装</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/06/Qemu中TCG操作数的定义及注释/">Qemu中TCG操作数的定义及注释</a>
          </li>
        
          <li>
            <a href="/2018/05/26/defu/">defu</a>
          </li>
        
          <li>
            <a href="/2018/05/26/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/04/05/最小生成树Prim算法理解/">最小生成树Prim算法理解</a>
          </li>
        
          <li>
            <a href="/2016/02/14/我写数据结构排序部分的部分心得/">我写数据结构排序部分的部分心得</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Dove Cao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>