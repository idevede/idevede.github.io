<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Qemu中TCG操作数的定义及注释</title>
      <link href="/2018/04/28/Qemu%E4%B8%ADTCG%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%B3%A8%E9%87%8A/"/>
      <url>/2018/04/28/Qemu%E4%B8%ADTCG%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/80098787" target="_blank" rel="noopener">点这里</a></p><a id="more"></a><p>tcg/tcg.h:</p><p>Define type and accessor macros for TCG variables.</p><!--more--><p>TCG variables are the inputs and outputs of TCG ops, as described<br>in tcg/README. Target CPU front-end code uses these types to deal<br>with TCG variables as it emits TCG code via the tcg_gen_* functions.<br>They come in several flavours:</p><ul><li>TCGv_i32 : 32 bit integer type</li><li>TCGv_i64 : 64 bit integer type</li><li>TCGv_ptr : a host pointer type</li><li>TCGv_vec : a host vector type; the exact size is not exposed<br>to the CPU front-end code.</li><li>TCGv : an integer type the same size as target_ulong<br>(an alias for either TCGv_i32 or TCGv_i64)<br>The compiler’s type checking will complain if you mix them<br>up and pass the wrong sized TCGv to a function.</li></ul><p>Users of tcg_gen_* don’t need to know about any of the internal<br>details of these, and should treat them as opaque types.<br>You won’t be able to look inside them in a debugger either.</p><p>Internal implementation details follow:</p><p>Note that there is no definition of the structs TCGv_i32_d etc anywhere.<br>This is deliberate, because the values we store in variables of type<br>TCGv_i32 are not really pointers-to-structures. They’re just small<br>integers, but keeping them in pointer types like this means that the<br>compiler will complain if you accidentally pass a TCGv_i32 to a<br>function which takes a TCGv_i64, and so on. Only the internals of<br>TCG need to care about the actual contents of the types.</p><p>tcg/optimize.c<br>static TCGArg do_constant_folding_2(TCGOpcode op, TCGArg x, TCGArg y)<br>{<br>uint64_t l64, h64;</p><p>switch (op) {<br>CASE_OP_32_64(add):<br>return x + y;</p><p>CASE_OP_32_64(sub):<br>return x - y;</p><p>CASE_OP_32_64(mul):<br>return x * y;</p><p>CASE_OP_32_64(and):<br>return x &amp; y;</p><p>CASE_OP_32_64(or):<br>return x | y;</p><p>CASE_OP_32_64(xor):<br>return x ^ y;</p><p>case INDEX_op_shl_i32:<br>return (uint32_t)x &lt;&lt; (y &amp; 31);</p><p>可以看到TCGV就是普通的操作数</p>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Chisel </tag>
            
            <tag> QEMU </tag>
            
            <tag> 模拟器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rocket学习常用网址整理</title>
      <link href="/2018/04/27/Rocket%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/"/>
      <url>/2018/04/27/Rocket%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/80098787" target="_blank" rel="noopener">点这里</a></p><a id="more"></a><p>1.<a href="https://github.com/ucb-bar/project-template" target="_blank" rel="noopener">https://github.com/ucb-bar/project-template</a><br>2.<a href="https://github.com/ucb-bar/rocc-template" target="_blank" rel="noopener">https://github.com/ucb-bar/rocc-template</a><br>3.关于谷歌rocket chip生成指令的搜索：<br><a href="https://www.google.com.ar/search?q=rocket+chip+add&amp;oq=rocket+chip+add&amp;aqs=chrome..69i57j69i61l2.4361j0j7&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">https://www.google.com.ar/search?q=rocket+chip+add&amp;oq=rocket+chip+add&amp;aqs=chrome..69i57j69i61l2.4361j0j7&amp;sourceid=chrome&amp;ie=UTF-8</a><br>4.一个官方网站，会议记录:<br><a href="http://eliaskousk.teamdac.com/entry/generating-and-testing-of-a-risc-v-core-week-1-of-gsoc-2016" target="_blank" rel="noopener">http://eliaskousk.teamdac.com/entry/generating-and-testing-of-a-risc-v-core-week-1-of-gsoc-2016</a></p><p>5.会有很多参考资料的列表<br><a href="https://cnrv.io/" target="_blank" rel="noopener">https://cnrv.io/</a></p><p>备注:ROCC这个有问题，应该是跟当前rocket版本不一致</p><p>projiect中可以使用ln软连接。节省内存。</p><p>一个关于指令集拓展的用verilig语言写的百度文库的文章：<br><a href="https://wenku.baidu.com/view/d727eaa33b3567ec112d8a69.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/d727eaa33b3567ec112d8a69.html</a></p><p>Extending RISC-V for application-specific requirements: Steve Cox<br>Sometimes a pre-defined ISA is insufficient. May require an application-optimised ISA. e.g. the Google TPU<br>ASIP designer is a tool for automating ASIP design. The process can start with a pre-existing example model, e..g RISC-V<br>ASIP designer has been used in more than 250 unique SoC products<br>The speaker gives an example of a header compression accelerator. Start with a simple 3-stage RV32IM core. This is 24.5k gates on TSMC 28HPM at 500MHz and 32GPRs.<br>First, consider instruction level parallelism. e.g. switching to a 2-slot VLIW. This reduced cycle could by 21% and increased gate count by 31%.<br>Next, try adding application-specific instructions. This reduced the code size by 56%, cycle count by 67%, and added 9% to the gate count (compared to the original baseline).<br>Next, try adding a compare immediate and branch instruction. This reduces code size by 8% and cycle count by 18% vs the previous result.</p>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Chisel </tag>
            
            <tag> 拓展指令集 </tag>
            
            <tag> Rocket chip </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux常用命令总结及内存分配基本知识</title>
      <link href="/2018/04/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/04/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/80098722" target="_blank" rel="noopener">点这里</a></p><p>主要是自己使用Linux系统时一些常用操作以及对自己之前一直不理解的new 和malloc的分析<br><a id="more"></a></p><p>1.给文件夹下所有sh加权限：chmod –R 777 文件夹名称<br>2.解压缩zip:unzip</p><p>####备注：账号密码：<br>FTP:<br>account:www<br>password:or9A2UU2W</p><p>MySQL:<br>account:root”<br>password:mysql_password</p><p>3.查找文件： find / -name “account.log” -ls<br>4.mysql状态：service mysql status<br>5.启动mysql: service mysql start</p><p>mysql&gt; grant all on <em>.</em> to ‘defu‘@’%’ identified by ‘123456’;<br>Query OK, 0 rows affected (0.01 sec)</p><p>mysql&gt; flush privileges<br>-&gt; ;</p><p>6.传文件<br>rz,z是上传<br>sz是下载</p><p>7.在一个文件夹下递归查找所有包含某关键字的命令:grep “text” . -r -n –color=auto</p><p>Ctrl + a  光标到开头<br>Ctrl + c 中断当前程序<br>Ctrl + d 退出当前窗口或当前用户<br>Ctrl + e 光标到结尾<br>Ctrl + l 清屏 相当与clear<br>Ctrl + u 剪切、删除（光标以前的）内容<br>Ctrl + k 剪切、删除（光标以后的）内容<br>Ctrl + r 查找（最近用过的命令）<br>tab    所有路径以及补全命令<br>Ctrl+shift+c 命令行复制内容<br>Ctrl+shift+v 命令行粘贴内容<br>Ctrl + q 取消屏幕锁定<br>Ctrl + s 执行屏幕锁定</p><p>new/delete和malloc/free的底层实现<br>答：malloc和new的区别：<br>1）malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存；<br>2）new 返回指定类型的指针，并且可以自动计算所需要大小。而 malloc 则必须要由程序员计算字节数，并且在返回后强行转换为实际类型的指针；<br>3）new/delete在对象创建的同时可以自动执行构造函数初始化，在对象在消亡之前会自动执行析构函数。而malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的；<br>既然new/delete的功能覆盖了malloc/free，为什么C++还要保留malloc/free？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。<br><em>new/delete、malloc/free底层实现原理：</em><br>概述：new/delete的底层实现是调用malloc/free函数实现的，而malloc/free的底层实现也不是直接操作内存而是调用系统API实现的。</p>]]></content>
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NLP论文笔记Paraphrasing With Bilingual Parallel Corpora 双语平行语料库释义</title>
      <link href="/2018/04/16/Paraphrasing_With_Bilingual_Parallel_Corpora%20/"/>
      <url>/2018/04/16/Paraphrasing_With_Bilingual_Parallel_Corpora%20/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/80098631" target="_blank" rel="noopener">点这里</a></p><p>在复述模型的研究方面 ,Bannard 和 Callison 2 Burch基于双语平行语料提出了一种复述模型 [10] , 该模型利用外文翻译作为“枢轴”来计算短语 e 2 是 e 1 的复述的概率 P( e 2 | e 1 ) . 具体地 , 设 f 是 e 2 和 e 1 共有的外文翻译 , 则该模型通过计算 P(f | e 1 ) 和 P( e 2 |f)的乘积来得到 P( e 2 | e 1 ) . 同时 , 该模型还结合语言模型来计算 e 2出现在给定上下文中的概率<br><a id="more"></a></p><p>基于枢轴的方法应用于大规模的双语平行语料库 [58] .他们首先使用机器翻译中的词对齐和短语抽取技术从双语平行语料库中抽取出短语翻译对,然后利用外文翻译作为枢轴抽取英文复述短语.设英文短语 e 1 和 e 2 对应的枢轴为 f,则该方法将 e 1 到 f 的翻译概率和 f 到 e 2 的翻译概率的乘积作为 e 1 到 e 2 的复述概率.受该研究的启发,我们将基于枢轴的方法用于复述模板的抽取 [4] .我们使用对数线性(log-linear)模型计算复述概率,抽取出像 consider X 和 take X into consideration 这样的复述模板.</p><p>单语平行语料库的稀缺性。the narrow range of text genres available for monolingual parallel corpora limits the range of contexts in which the paraphrases can be used.</p><p>拓展了一种翻译方法：phrase-based statistical machine translation<br>The essence of our method is to align phrases in a bilingual parallel corpus, and equate different English phrases that are aligned with the same phrase in the other language.<br>Section 2: we rank the extracted paraphrases with a probability assignment<br>Section 3 describes our experimental setup and includes information about how phrases were selected, how we manually aligned parts of the bilingual corpus, and how we evaluated the para- phrases.<br>Section2: 对齐短语：align phrases within sentence pairs<br>2.1 statistical machine translation techniques are used to align phrases within sentence pairs in a bilingual corpus<br>哪些统计技术<br>– recent phrase-based approaches to statistical machine translation</p><p>（1）    The original formulation of statistical  machine translation (Brown et al., 1993) was  defined  as a word-based operation.<br>（2）    More recent approaches to statistical translation calculate  the translation  probability using larger blocks of aligned text.<br>We use the heuristic for phrase alignment  described in Och and Ney (2003) which  aligns phrases by incrementally build- ing longer  phrases from words  and phrases which<br>have adjacent alignment points.<br>（3）     </p><p>2.2如何计算释义的概率：<br>公式3：通过计算短语e和f在平行语料库中对齐的频率，计算最大似然函数。<br>公式4：S allows us to re-rank the candidate paraphrases based on additional contextual information<br>最终：We produced automatic alignments for it with the Giza++ toolkit (Och and Ney, 2003)<br>we also developed a gold standard of word alignments for the set of phrases that we wanted to paraphrase<br>为每个短语提取多种可能的释义：our method frequently extracts more than one possible paraphrase for each phrase.</p><p>2.1NLP中的对齐短语对。<br>2.2 翻译模型概率，， 最大似然估计。</p><p>拓展释义概率。</p><p>补充：协同训练框架图。</p><p>现 有 的 语 料 库 建 设 主 要 表 现 出 以 下 共 同 特 点 ： 第 一 ，句 子 层 面 实 现 对 齐 ，方 便 了 对 特 定 语 言 转 换 现 象 的 大 规 模 观 察 与 分 析 ；第 二 ，自 动 标 注 与 人 工 标 注相 结 合 ，使 得 相 关 研 究 得 以 从 形 式 到 语 义 、语 用 、文 体 等 方 面 深 入 。基 于 平 行 语 料 库 的 翻 译 研 究 主 要 集 中 在 三 个 方 面 ：第 一 ，语 料 库 建 构 技 术 探 索 。 主 要 探 讨 如 何 运 用 计 算 机 技 术 来 研 制 语 料 库 ，尤 其 是 对 汉 语 文 本 的 加 工 、英汉 对齐的处理以及手工标 注 介入 等 问 题 ；第 二 ，基于语料库的实证 研 究 和 理 论 探 讨 。 以 翻 译 共 性 为 例 ，相 关的实证研究不仅关注 单 一类 比 模 式 （ｔｈｅｃｏｍｐａｒａｂｌｅｍｏｄｅ）下 目 标 语 中 翻 译 文 本 与 非 翻 译 文 本 之 间 的 差 异 ，而且也将源文本 作 为 分析 和 解 释 翻 译 文 本 中 特 定 语 言 转 换 现 象 的 一 个 维 度 。既 有 对 翻 译 语言宏观特征 的 探究 ，也 有 对 具 体 语 言 转 换 的 考 察 。 第 三 ，平 行 语 料 库 在 翻 译 教 学 中 的 应 用 ，具 体包括网 络检索平台的辅助翻译 教 学和 自 建 语 料 库 在 课 堂 教 学 中 的 运 用 等 。</p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>deepin系统（unstable 发行版 4.14）安装perf的正确姿势</title>
      <link href="/2018/03/16/deepin_install_perf/"/>
      <url>/2018/03/16/deepin_install_perf/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/79580093" target="_blank" rel="noopener">点这里</a></p><p>想从spec入手分析程序使用状态，发现perf命令相当好用，所以打算安装一下。结果折腾了一上午才发现没有合适的方法。</p><p>Perf是内置于Linux内核源码树中的性能剖析(profiling)工具。</p><p>它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析。</p><p>常用于性能瓶颈的查找与热点代码的定位。<br><a id="more"></a></p><p>安装perf第一个错误的方法：</p><p>安装perf，首先安装内核源码：sudo apt-get install linux-source。</p><p>完成之后，可以再/usr/src下找到src，解压，进入tools/perf，然后make&amp;&amp;make install即可。</p><p>过程中遇到各种依赖问题，失败。</p><p>安装perf第二个错误的方法：</p><p>sudo apt-get install linux-tools-common</p><p>因为是deepin版本问题，一直报错</p><p>无法重定向 linux-tools-common</p><p>查了一下说是版本源的问题，然后去更新deepin版本源<br><img src="https://img-blog.csdn.net/20180316124832252?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2lkZXZlZGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>或者版本更新里面可以自己选定源<br><img src="https://img-blog.csdn.net/20180316124950314?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2lkZXZlZGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>折腾一上午还是不行，</p><p>最后用自己的另一个Ubuntu版本试了一下，发现common一次就过<br><img src="https://img-blog.csdn.net/20180316125738836?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2lkZXZlZGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>心态崩了。。</p><p>然后重新开始调整，发现是deepin版本与Ubuntu不同<br><img src="https://img-blog.csdn.net/20180316130119552?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2lkZXZlZGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>依赖不对。</p><p>正确的安装方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install linux-tools-common linux-tools-generic linux-tools-`uname -r`</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20180316130448156?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2lkZXZlZGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/20180316130302933?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2lkZXZlZGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>直接安装最后一句。</p><p>安装成功</p><p>使用perf list</p><p><img src="https://img-blog.csdn.net/20180316130349979?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2lkZXZlZGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>至此，安装成功。</p>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 性能剖析 </tag>
            
            <tag> 计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chisel 语言（Scala）学习 2 实例化模型和向量操作</title>
      <link href="/2018/03/15/Chisel%20%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%91%E9%87%8F%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/03/15/Chisel%20%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A02%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%91%E9%87%8F%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/79554748" target="_blank" rel="noopener">点这里</a></p><blockquote><p>系列文章主要用来记录学习Chisel和scala过程中遇到的难点或知识点：”</p></blockquote><a id="more"></a><p>##实例化模型：<br>带有进位的加法器<br><img src="https://github.com/ucb-bar/chisel-tutorial/wiki/figs/4_Bit_Adder.jpg" alt="这里写图片描述"></p><p>Chisel代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// A <span class="number">4</span>-bit adder <span class="keyword">with</span> carry <span class="keyword">in</span> <span class="keyword">and</span> carry out</span><br><span class="line">class Adder4 extends Module &#123;</span><br><span class="line">  val io = IO(new Bundle &#123;</span><br><span class="line">    val A    = Input(UInt(<span class="number">4.</span>W))</span><br><span class="line">    val B    = Input(UInt(<span class="number">4.</span>W))</span><br><span class="line">    val Cin  = Input(UInt(<span class="number">1.</span>W))</span><br><span class="line">    val Sum  = Output(UInt(<span class="number">4.</span>W))</span><br><span class="line">    val Cout = Output(UInt(<span class="number">1.</span>W))</span><br><span class="line">  &#125;)</span><br><span class="line">  // Adder <span class="keyword">for</span> bit <span class="number">0</span></span><br><span class="line">  val Adder0 = Module(new FullAdder())</span><br><span class="line">  Adder0.io.a   := io.A(<span class="number">0</span>)</span><br><span class="line">  Adder0.io.b   := io.B(<span class="number">0</span>)</span><br><span class="line">  Adder0.io.cin := io.Cin</span><br><span class="line">  val s0 = Adder0.io.sum</span><br><span class="line">  // Adder <span class="keyword">for</span> bit <span class="number">1</span></span><br><span class="line">  val Adder1 = Module(new FullAdder())</span><br><span class="line">  Adder1.io.a   := io.A(<span class="number">1</span>)</span><br><span class="line">  Adder1.io.b   := io.B(<span class="number">1</span>)</span><br><span class="line">  Adder1.io.cin := Adder0.io.cout</span><br><span class="line">  val s1 = Cat(Adder1.io.sum, s0)</span><br><span class="line">  // Adder <span class="keyword">for</span> bit <span class="number">2</span></span><br><span class="line">  val Adder2 = Module(new FullAdder())</span><br><span class="line">  Adder2.io.a   := io.A(<span class="number">2</span>)</span><br><span class="line">  Adder2.io.b   := io.B(<span class="number">2</span>)</span><br><span class="line">  Adder2.io.cin := Adder1.io.cout</span><br><span class="line">  val s2 = Cat(Adder2.io.sum, s1)</span><br><span class="line">  // Adder <span class="keyword">for</span> bit <span class="number">3</span></span><br><span class="line">  val Adder3 = Module(new FullAdder())</span><br><span class="line">  Adder3.io.a   := io.A(<span class="number">3</span>)</span><br><span class="line">  Adder3.io.b   := io.B(<span class="number">3</span>)</span><br><span class="line">  Adder3.io.cin := Adder2.io.cout</span><br><span class="line">  io.Sum  := Cat(Adder3.io.sum, s2).asUInt</span><br><span class="line">  io.Cout := Adder3.io.cout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##向量操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val myVec = Vec(Seq.fill( &lt;number of elements&gt; ) &#123; &lt;data type&gt; &#125;)</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ufix5_vec10 := Vec(Seq.fill(10) &#123; UInt(5.W) &#125;)</span><br></pre></td></tr></table></figure><p>定义一个向量寄存器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val reg_vec32 = Reg(Vec(Seq.fill(32)&#123; UInt() &#125;))</span><br></pre></td></tr></table></figure><p>定义一个16位加法器（向量的值包含实例时，我们用io来定义）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val FullAdders = </span><br><span class="line">  Vec(Seq.fill(16)&#123; Module(new FullAdder()).io &#125;)</span><br></pre></td></tr></table></figure><p>为了使代码简洁，我们可以用下面这种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val initValues = Seq.fill(4) &#123; 0.U(8.W) &#125;</span><br><span class="line">  val delays = RegInit(Vec(initValues))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> RISC-V </tag>
            
            <tag> Chisel </tag>
            
            <tag> 拓展指令集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chisel 语言学习 1 基本数据类型和操作</title>
      <link href="/2018/03/14/Chisel%20%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/03/14/Chisel%20%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A01%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/79554748" target="_blank" rel="noopener">点这里</a></p><blockquote><p>系列文章主要用来记录学习Chisel和scala过程中遇到的难点或知识点：”</p></blockquote><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>用 <code>[TOC]</code>来生成目录：</p><p>[TOC]</p><h2 id="变量的声明与赋值"><a href="#变量的声明与赋值" class="headerlink" title="变量的声明与赋值"></a>变量的声明与赋值</h2><p> <strong>=</strong> , 　可立即得出数值<br> <strong>:=</strong>，  具体值需要依赖前边变量的值。<br> 在写Scala时要特别注意变量计算需要用“=”还是用“：=”</p><p>##数据位操作</p><p>###截取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ByteSelector extends Module &#123;</span><br><span class="line">  val io = IO(new Bundle &#123;</span><br><span class="line">    val in     = Input(UInt(32.W))</span><br><span class="line">    val offset = Input(UInt(2.W))</span><br><span class="line">    val out    = Output(UInt(8.W))</span><br><span class="line">  &#125;)</span><br><span class="line">  io.out := 0.U(8.W)</span><br><span class="line">  when (io.offset === 0.U(2.W)) &#123;</span><br><span class="line">    io.out := io.in(7,0)</span><br><span class="line">  &#125; .elsewhen (io.offset === 1.U) &#123;</span><br><span class="line">    io.out := io.in(15,8)</span><br><span class="line">  &#125; .elsewhen (io.offset === 2.U) &#123;</span><br><span class="line">    io.out := io.in(23,16)</span><br><span class="line">  &#125; .otherwise &#123;</span><br><span class="line">    io.out := io.in(31,24)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val A = UInt(32.W)</span><br><span class="line">val B = UInt(32.W)</span><br><span class="line">val bus = Cat(A, B) // concatenate A and B</span><br></pre></td></tr></table></figure><p>##练习</p><p>LFSR16<br><img src="http://img.blog.csdn.net/20180314142811666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="LSFR16 chisel"><br>实现一个16位线性反馈移位寄存器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class LFSR16 extends Module &#123;</span><br><span class="line">  val io = IO(new Bundle &#123;</span><br><span class="line">    val inc = Input(Bool())</span><br><span class="line">    val out = Output(UInt(16.W))</span><br><span class="line">  &#125;)</span><br><span class="line">  // ...</span><br><span class="line">  io.out := 0.U</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将代码补充完整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFSR16</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  val io = IO(<span class="keyword">new</span> Bundle &#123;</span><br><span class="line">    val inc = Input(Bool())</span><br><span class="line">    val out = Output(UInt(<span class="number">16</span>.W))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  val res = RegInit(<span class="number">1</span>.U(<span class="number">16</span>.W))</span><br><span class="line">  when (io.inc) &#123; </span><br><span class="line">    val nxt_res = Cat(res(<span class="number">0</span>)^res(<span class="number">2</span>)^res(<span class="number">3</span>)^res(<span class="number">5</span>), res(<span class="number">15</span>,<span class="number">1</span>)) </span><br><span class="line">    res := nxt_res</span><br><span class="line">  &#125;</span><br><span class="line">  io.out := res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用C++实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> reg = <span class="number">0xACE1</span>;</span><br><span class="line">       <span class="keyword">uint16_t</span> bit;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">               bit =((reg &gt;&gt; <span class="number">0</span>) ^</span><br><span class="line">                     (reg &gt;&gt; <span class="number">2</span>) ^</span><br><span class="line">                     (reg &gt;&gt; <span class="number">3</span>) ^</span><br><span class="line">                     (reg &gt;&gt; <span class="number">5</span>) ) &amp; <span class="number">0x0001</span>;</span><br><span class="line">               reg = (reg &gt;&gt; <span class="number">1</span>) | (bit &lt;&lt; <span class="number">15</span>);</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"%04X/n"</span>,reg);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>###进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run-problem.sh LFSR16</span><br></pre></td></tr></table></figure><p>出现问题如下：</p><p><img src="http://img.blog.csdn.net/20180314144040101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="cat出现问题"><br><strong>注意</strong>　连接操作不是chisel内核代码，因此使用时需要进行import</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import chisel3.util.Cat</span><br><span class="line"></span><br><span class="line">import chisel3.util._</span><br></pre></td></tr></table></figure><p>修改之后重新运行：<br><img src="http://img.blog.csdn.net/20180314144900621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Cat成果运行"></p><p><strong>生成的verilog内容如下</strong>　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">`ifdef RANDOMIZE_GARBAGE_ASSIGN</span><br><span class="line">`define RANDOMIZE</span><br><span class="line">`endif</span><br><span class="line">`ifdef RANDOMIZE_INVALID_ASSIGN</span><br><span class="line">`define RANDOMIZE</span><br><span class="line">`endif</span><br><span class="line">`ifdef RANDOMIZE_REG_INIT</span><br><span class="line">`define RANDOMIZE</span><br><span class="line">`endif</span><br><span class="line">`ifdef RANDOMIZE_MEM_INIT</span><br><span class="line">`define RANDOMIZE</span><br><span class="line">`endif</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">module</span> <span class="title">LFSR16</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  input         clock,</span></span></span><br><span class="line"><span class="function"><span class="params">  input         reset,</span></span></span><br><span class="line"><span class="function"><span class="params">  input         io_inc,</span></span></span><br><span class="line"><span class="function"><span class="params">  output [<span class="number">15</span>:<span class="number">0</span>] io_out</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">  reg [<span class="number">15</span>:<span class="number">0</span>] res; <span class="comment">// @[LFSR16.scala 19:20]</span></span><br><span class="line">  reg [<span class="number">31</span>:<span class="number">0</span>] _RAND_0;</span><br><span class="line">  wire  _T_6; <span class="comment">// @[LFSR16.scala 21:26]</span></span><br><span class="line">  wire  _T_7; <span class="comment">// @[LFSR16.scala 21:33]</span></span><br><span class="line">  wire  _T_8; <span class="comment">// @[LFSR16.scala 21:29]</span></span><br><span class="line">  wire  _T_9; <span class="comment">// @[LFSR16.scala 21:40]</span></span><br><span class="line">  wire  _T_10; <span class="comment">// @[LFSR16.scala 21:36]</span></span><br><span class="line">  wire  _T_11; <span class="comment">// @[LFSR16.scala 21:47]</span></span><br><span class="line">  wire  _T_12; <span class="comment">// @[LFSR16.scala 21:43]</span></span><br><span class="line">  wire [<span class="number">14</span>:<span class="number">0</span>] _T_13; <span class="comment">// @[LFSR16.scala 21:55]</span></span><br><span class="line">  wire [<span class="number">15</span>:<span class="number">0</span>] _T_14; <span class="comment">// @[Cat.scala 30:58]</span></span><br><span class="line">  wire [<span class="number">15</span>:<span class="number">0</span>] _GEN_0; <span class="comment">// @[LFSR16.scala 20:17]</span></span><br><span class="line">  assign _T_6 = res[<span class="number">0</span>]; <span class="comment">// @[LFSR16.scala 21:26]</span></span><br><span class="line">  assign _T_7 = res[<span class="number">2</span>]; <span class="comment">// @[LFSR16.scala 21:33]</span></span><br><span class="line">  assign _T_8 = _T_6 ^ _T_7; <span class="comment">// @[LFSR16.scala 21:29]</span></span><br><span class="line">  assign _T_9 = res[<span class="number">3</span>]; <span class="comment">// @[LFSR16.scala 21:40]</span></span><br><span class="line">  assign _T_10 = _T_8 ^ _T_9; <span class="comment">// @[LFSR16.scala 21:36]</span></span><br><span class="line">  assign _T_11 = res[<span class="number">5</span>]; <span class="comment">// @[LFSR16.scala 21:47]</span></span><br><span class="line">  assign _T_12 = _T_10 ^ _T_11; <span class="comment">// @[LFSR16.scala 21:43]</span></span><br><span class="line">  assign _T_13 = res[<span class="number">15</span>:<span class="number">1</span>]; <span class="comment">// @[LFSR16.scala 21:55]</span></span><br><span class="line">  assign _T_14 = &#123;_T_12,_T_13&#125;; <span class="comment">// @[Cat.scala 30:58]</span></span><br><span class="line">  assign _GEN_0 = io_inc ? _T_14 : res; <span class="comment">// @[LFSR16.scala 20:17]</span></span><br><span class="line">  assign io_out = res;</span><br><span class="line">`ifdef RANDOMIZE</span><br><span class="line">  integer initvar;</span><br><span class="line">  initial begin</span><br><span class="line">    `ifndef verilator</span><br><span class="line">      #0.002 begin end</span><br><span class="line">    `endif</span><br><span class="line">  `ifdef RANDOMIZE_REG_INIT</span><br><span class="line">  _RAND_0 = &#123;<span class="number">1</span>&#123;$random&#125;&#125;;</span><br><span class="line">  res = _RAND_0[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">  `endif <span class="comment">// RANDOMIZE_REG_INIT</span></span><br><span class="line">  end</span><br><span class="line">`endif <span class="comment">// RANDOMIZE</span></span><br><span class="line">  always @(posedge clock) begin</span><br><span class="line">    <span class="keyword">if</span> (reset) begin</span><br><span class="line">      res &lt;= <span class="number">16</span><span class="string">'h1;</span></span><br><span class="line"><span class="string">    end else begin</span></span><br><span class="line"><span class="string">      if (io_inc) begin</span></span><br><span class="line"><span class="string">        res &lt;= _T_14;</span></span><br><span class="line"><span class="string">      end</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">  end</span></span><br><span class="line"><span class="string">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> RISC-V </tag>
            
            <tag> Chisel </tag>
            
            <tag> 拓展指令集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RISC V Rocket-chip 模拟器使用笔记（一）</title>
      <link href="/2018/02/22/RISC%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B01/"/>
      <url>/2018/02/22/RISC%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B01/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/79538864" target="_blank" rel="noopener">点这里</a></p><p>“Rocket是一款64bit的标量处理器，5级流水线，采用的是risc-v指令集，集成FPU，并有许多or1200没有的特性，比如：无阻塞缓存、分支预测、返回地址堆栈、硬件页表填充、cache支持ECC、支持多核等。”</p><a id="more"></a><hr><h2 id="1-Rocket-chip可以做什么"><a href="#1-Rocket-chip可以做什么" class="headerlink" title="1.Rocket-chip可以做什么"></a>1.Rocket-chip可以做什么</h2><p>“Rocket是一款64bit的标量处理器，5级流水线，采用的是risc-v指令集，集成FPU，并有许多or1200没有的特性，比如：无阻塞缓存、分支预测、返回地址堆栈、硬件页表填充、cache支持ECC、支持多核等。”</p><p>它允许我们生成不同配置（自定义）的SOC，包括软件工具链。</p><h2 id="2-Rocket-chip的子模块（文件目录）"><a href="#2-Rocket-chip的子模块（文件目录）" class="headerlink" title="2.Rocket-chip的子模块（文件目录）"></a>2.Rocket-chip的子模块（文件目录）</h2><p><img src="https://img-blog.csdn.net/20180313124414767?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="Rocket-chip文件目录"></p><p>1.chisel3：用来进行RTL级建模的HDL</p><p>2.Rocket:Rocket 核心代码以及cache</p><p>3.Uncore: 除内核以外的外部逻辑代码：一致性端口，片上接口，主机接口等</p><p>4.hardfloat：参数化FMA等，文件夹内有README代码</p><p>5.Dramsim2 为模拟器模拟DRAM的时序</p><p>6.RISCVTOOLS：软件工具链</p><p>7.CSRC:为C++模拟器开发的胶水代码（在计算机编程领域，胶水代码也叫粘合代码，用途是粘合那些可能不兼容的代码。可以使用与胶合在一起的代码相同的语言编写，也可以用单独的胶水语言编写。胶水代码不实现程序要求的任何功能，它通常出现在代码中，使现有的库或者程序在外部函数接口（如Java本地接口）中进行互操作。）</p><p>8.Emulator:为C++模拟器创幻目录，生产代码和执行</p><p>9.Fsim:FPGA模拟器</p><p>10.Src: Chisel 源代码</p><p>11.Project：一些配置文件</p><p>12.Vsim：ASIC模拟器</p><h2 id="3-Rocket-chip-配置的参数"><a href="#3-Rocket-chip-配置的参数" class="headerlink" title="3. Rocket chip 配置的参数"></a>3. Rocket chip 配置的参数</h2><p>Tile()，Memory（），Caches()，Core()，Uncore()</p><h2 id="4-生成简单的模拟测试："><a href="#4-生成简单的模拟测试：" class="headerlink" title="4.生成简单的模拟测试："></a>4.生成简单的模拟测试：</h2><p><img src="https://img-blog.csdn.net/20180313131658642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/20180313131725110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><img src="https://img-blog.csdn.net/2018031313175154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>运行成功。</p><p>接下来将学习自己配置和添加接口。</p><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p>初始配置</p><p><img src="https://img-blog.csdn.net/20180313131926399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
            <tag> Chisel </tag>
            
            <tag> 拓展指令集 </tag>
            
            <tag> Rocket chip </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新型硬件发展趋势及其对数据管理与分析的挑战（下）</title>
      <link href="/2018/01/12/%E6%96%B0%E5%9E%8B%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E5%8F%8A%E5%85%B6%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E7%9A%84%E6%8C%912/"/>
      <url>/2018/01/12/%E6%96%B0%E5%9E%8B%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E5%8F%8A%E5%85%B6%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E7%9A%84%E6%8C%912/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/79421117" target="_blank" rel="noopener">点这里</a><br>CCF于1月11日发布了最新一期《中国计算机科学技术发展报告》，对可群智协同计算、软件智能化开发技术等11个方向的研究进展做了详细介绍和讨论。加入CCF会员登录CCF官网，可在数字图书馆栏目下载和浏览。</p><a id="more"></a><hr><h2 id="3-研究挑战与展望"><a href="#3-研究挑战与展望" class="headerlink" title="3 研究挑战与展望"></a>3 研究挑战与展望</h2><h3 id="3-1-研究挑战"><a href="#3-1-研究挑战" class="headerlink" title="3.1 研究挑战"></a>3.1 研究挑战</h3><p>虽然新型硬件环境为数据管理与分析提供了新的设计维度，但是不论从个体的新型硬件发展前景抑或从整体的与现有体系的整合方式来看，都具有较大的不确定性。这些新型硬件能否给上层软件系统带来期望的性能收益取决于如何发掘新型硬件的性能提升空间以及准确界定硬件自身的局限性，洞察他们蕴含的假设条件以及对于系统设计平衡点的影响，这些都是数据管理与分析领域必须面对的挑战：</p><p>1）    首先，要在系统层面洞察新型存储器件和环境可能引入的新瓶颈：新型硬件及其环境对现有技术的影响是系统性的，在消除既有性能瓶颈的同时可能会引入新的性能瓶颈，需要站在更高层的系统上下文中对其影响进行审视。在新型处理器和加速器构建的异构计算环境下，虽然大规模并行能力的瓶颈得以缓解，但是传统的内存墙、冯·诺依曼体系结构瓶颈、功耗墙等问题在新的异构并行计算环境下甚至可能更加严重，而异构处理单元之间的通信延迟、有限的缓存容量、非一致存储访问代价都可能成为新的性能瓶颈；在新型非易失存储环境下，数据访问的I/O栈中面向磁盘的I/O瓶颈能够被消除，但是新型非易失I/O栈将显著地放大传统存储体系下通常被忽略的软件开销，重新设计软件栈以减少其开销比例成为比以往更重要的设计原则；在高性能网络体系中，虽然网络I/O延迟不再是系统设计时的主要瓶颈，但处理器缓存和本地内存的利用效率则变得更为重要。</p><p>2）    其次，新型硬件环境下算法和数据结构的设计思路需要改变：将传统算法和数据结构进行直接迁移或部分调优的方式无法充分挖掘新型硬件及环境的特性。在处理器层面上，适合x86架构处理器的数据结构及以cache为中心的算法设计并不能与以计算为中心的众核协处理器硬件特性相匹配，很多数据库成熟的查询处理技术在众核处理器平台上面临优化技术失效的风险，而且数据库软件长期以来以串行及小规模并行处理为主的程序设计思想，使得传统的查询处理算法难以很好地转换为大规模并行处理模式；在存储层面上，虽然新型非易失存储具有内外存双重优势，但是现阶段非易失存储器仍然存在 I/O读写性能不对称、读写功耗不对称、写耐受性差等特征，这些特征与以往算法和数据结构对于底层存储环境的基本设计假设具有显著差异，因此传统的以优化低速I/O为主要目标的磁盘访问技术、基于块访问的闪存访问技术、读写对称的内存访问技术虽然能够提供很好的借鉴作用，但是都无法在非易失存储环境下获得理想的效果；在网络层面上，由于RDMA集群环境既不是简单的消息传递架构也不是共享内存架构而是一种新型的混合式架构，因此不能将非一致内存访问架构下的技术直接应用到RDMA集群环境中。</p><p>3）    再者，新型硬件及环境对数据管理与分析技术的影响是全面、深度且交叉的：新型硬件环境所具有的新特征不能通过简单的对数据管理软件的既有功能进行裁剪来适配新的硬件环境。在新型处理器和加速器构建的异构计算环境下，并行处理能力获得极大的提升，但是更加丰富的硬件上下文也给数据管理与分析技术在保持高吞吐性能和维护数据一致性等需求上带来了更严峻的挑战；新型存储器的非易失性对日志技术的影响将根本性地改变事务关键路径的长度和执行代价，事务提交时间的减少会进一步加剧锁竞争，进而影响整个系统的并发能力和吞吐性能；低延迟高带宽的高性能网络会改变系统对于分布式事务难以扩展的基本假设以及分布式算法设计时面向最小化网络延迟的优化目标，多核架构下的缓存利用成为新的优化重点；此外，部分既有的数据管理部件本身具有复合型的功能，新型硬件对其影响也具有较强的关联性。例如既有的缓冲区不但用于缓解整个系统的I/O瓶颈，也是减少故障恢复机制开销的重要环节；更加复杂的是，新型硬件与环境之间也存在相互的交叉影响，例如高性能处理器的乱序指令执行技术会导致缓存数据无法按应用逻辑次序存取和执行，如果用单一的NVM简化传统存储层级，就必须要解决NVM上数据的有序化问题。</p><p>4）    最后，软硬件的协同设计和协调发展是新型硬件环境下数据管理与分析技术发展的必然途径：新硬件技术有其固有的优势和不足，并不能完全取代原有的硬件体系结构和设备，在相当长的时间内必然是传统硬件与新硬件并存的格局，在提供多样化的硬件选择的同时也导致系统设计更加复杂，优化技术更加不透明，系统整体性能调优难度增加等问题。在异构计算环境下，采用co-processor还是co-placement实现定制化的数据处理加速对系统架构和技术设计具有显著差异，更加严重的是由于并行编程的门槛越来越高，软硬件之间的鸿沟也越来越大，数据管理与分析软件技术的发展滞后于硬件技术的发展，在很多实际应用中，硬件的实际利用率远低于性能上限[129]；而新型存储器件具有显著的差异化和多样化，如何利用新型非易失存储器构成非易失存储环境具有极大的灵活性和不确定性，构成成分是单纯还是混合，构成地位是对等还是层次都存在可能性，未定型的构成体系也给上层数据管理与分析技术带来了极大的挑战和研究。在高性能网络体系下，虽然InfiniBand从设计之初就考虑了RDMA，但传统的以太网也提出了基于RDMA的解决方案，最终哪种方案能形成完整的产业生态目前也无法给出确切的答案，因此更需要尽早开展前沿性研究，探索适合高性能网络环境的数据管理新架构。</p><h2 id="3-2-研究展望"><a href="#3-2-研究展望" class="headerlink" title="3.2 研究展望"></a>3.2 研究展望</h2><p>从数据管理与分析软件的发展历史来看，近半个世纪以来，作为最主要的数据管理软件，数据库从磁盘数据库闪存数据库内存数据库的发展轨迹充分反映出数据管理软件随底层存储介质一致变化的明显趋势。相似的，Shore-MT、MapD等系统的出现也反映出数据管理与分析技术随处理器共同演化的必要性。由高性能处理器和硬件加速器、新型非易失存储器、高速互联设备催生的异构计算架构、混合存储环境和高性能互联网络等新型硬件环境，必将改变传统的数据管理与分析系统的底层载体支撑，为数据管理与分析系统和关键技术带来重大的发展机遇，未来的研究可以从以下几个方面着手展开：</p><p>1）轻耦合的系统架构与协同设计策略：新型硬件构建的计算、存储以及网络环境具有异构性、多样性和混合性，不同的环境构成对上层数据管理系统架构的设计具有显著影响。如何将新型硬件无缝化地融入数据管理栈是数据管理技术能够有效利用新型硬件能力的重要基础性研究问题。为兼容多样性的硬件环境以及减少与特定硬件高耦合优化技术的失效风险，必须对异质、异构、混合的硬件环境进行有效的抽象和虚拟化。抽象化技术可以提取硬件共有的特征，在确保硬件感知的同时减少低级的过度耦合，为上层技术提供灵活的定制化和服务化的支持；同时，数据处理中不同操作的执行代价以及相互的比例关系在新硬件环境下必然发生变化，系统的瓶颈也在发生迁移，传统软件栈中以往可以忽略不计的开销会被显著的放大。因此，需要在此基础上发现并优化新的性能瓶颈，重新设计合理的软件栈，降低新型硬件环境下的软件开销；此外，新型硬件环境具有的低延迟、高容量、高带宽、高速读写等显著优势为整合OLTP与OLAP系统功能，实现融合的OLTAP系统架构设计带来了新的发展机遇，有必要在新硬件环境下探索面向混合应用负载的融合支持技术；</p><p>2）支持混合异构硬件环境的存储与索引管理技术：新型非易失存储器由于兼具内外存双重能力，模糊了原有存储之间清晰的边界，也为新型非易失存储环境的构成和数据存储方式提供了相当大的自由度，同时配合高效的索引技术以及加速器的优化，能够为加速上层数据处理提供有力的保证。虽然，新型非易失存储环境的高速I/O能力为提高数据访问性能带来了机遇，但是，NVM仅在器件层保证了数据的非易失性，系统层面的缓存机制还可能会引入不一致性的问题，因此未来需要从架构、策略、实现等不同层面研究协同存储技术；此外，作为专用加速硬件，FPGA在加速数据处理方面有其特有的优势，特别是结合非易失存储的特征可以进一步提高其对于数据处理的效率，因此，数据存储引擎的优化与重构技术以及FPGA存储侧的数据访存加速及数据过滤技术，能有效的完成对原始数据的部分预处理工作，减少实际所需传输的数据量，进而缓解大规模数据处理时数据访问的瓶颈；再者，NVM非易失存储环境具有更丰富的存储层级，而另一方面新型处理器技术也为索引提供了额外的数据处理资源，因此面向多层级的、processor-conscious的索引技术也是未来研究的方向；</p><p>3）硬件感知的查询处理与性能优化：查询处理是数据分析中最核心的操作，其涉及数据提取过程中一系列复杂的活动。异构计算架构提供的高度并行能力和可定制能力，以及非易失存储环境全新的I/O特征都使得以往的查询处理和优化机制难以适用。未来研究可能集中在两个方面，一是非易失存储环境下的查询优化技术：NVM的高速读写、字节可寻址以及非对称读写等特征对于传统查询操作，如连接、排序和聚集等都将产生显著影响。同时NVM改变了传统存储层级的构成，也影响了传统的以磁盘存储代价来估算查询代价的度量假设，因此未来有必要研究非易失存储环境下的代价模型，以及Write-limited 算法和数据结构的设计与优化，尽可能地降低NVM 写操作产生的负面影响；另一方面是异构处理器平台下的查询优化技术：由于，新型处理器的引入增加了异构计算平台的维度，导致查询优化技术的复杂度进一步提升，对查询优化器的设计提出巨大的挑战。面对新型异构处理器平台，数据库需要能够提供核心查询处理的技术平台迁移。面向异构处理器平台的协同查询处理技术、面向异构处理器平台的分析型查询优化技术以及混合查询执行计划生成技术等都是全面提高异构计算平台下的查询效率的可能途径；</p><p>4）新型硬件使能的事务处理技术：并发控制和故障恢复是数据管理系统确保事务隔离性和持久性的核心功能，其设计和实现与底层计算和存储环境的关系非常紧密。同时，高性能网络环境也对以往难以扩展的分布式事务处理提供了新的机遇。首先，NVM非易失存储环境中存储层次的架构与不同层次间存储介质的读写特征对事务恢复技术而言都有最直接的影响，需要根据NVM的优异特性优化数据库恢复技术。面向NVM内存环境的恢复技术、NVM 混合非易失环境下的划分技术以及NVM 感知的事务并发控制技术都是亟待开展的研究内容。其次，事务处理通常涉及多种类型操作及其之间的同步，而通用处理器和专用加速器具备不同的数据处理模式，为此将传统方式中由通用处理器CPU完成的事务处理负载进行分离，将部分负载迁移至专用加速处理器，可以达到有效提高事务处理性能的目的，因此研究针对事务处理加速的负载均衡和IO优化技术，是有效解决事务处理性能瓶颈的可能途径；再者，RDMA使能的高性能网络环境下，严格控制或者不使用分布式事务以及使用弱一致性的分布式事务系统设计桎梏将不复存在。RDMA使能的分布式提交协议以及面向RDMA的悲观与乐观并发控制方法可能都是需要研究的内容。</p><h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4 结束语"></a>4 结束语</h2><p>新型硬件及其构建的环境将深度影响整个计算体系的架构模式，并改变上层软件既往的设计假设，在提供更高物理性能的同时，也要求数据管理与分析的软件架构和相关技术能够感知并适应新型硬件的特点。新型硬件环境使得数据管理与分析系统的设计空间的权衡变得更加复杂，带来了多维度的研究挑战。在未来的研究中，迫切需要打破原有数据管理与分析软件架构的封闭性，依据硬件环境的特征以及数据管理与分析系统的核心功能，自底向上探索与研究全新的数据处理模式、架构、策略与技术。</p><blockquote><p>转载自“中国计算机学会”微信公众号</p></blockquote>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能硬件 </tag>
            
            <tag> 数据管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新型硬件发展趋势及其对数据管理与分析的挑战（上）</title>
      <link href="/2018/01/12/%E6%96%B0%E5%9E%8B%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E5%8F%8A%E5%85%B6%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E7%9A%84%E6%8C%91%E6%88%981/"/>
      <url>/2018/01/12/%E6%96%B0%E5%9E%8B%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E5%8F%8A%E5%85%B6%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E7%9A%84%E6%8C%91%E6%88%981/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/79420984" target="_blank" rel="noopener">点这里</a><br>CCF于1月11日发布了最新一期《中国计算机科学技术发展报告》，对可群智协同计算、软件智能化开发技术等11个方向的研究进展做了详细介绍和讨论。加入CCF会员登录CCF官网，可在数字图书馆栏目下载和浏览。</p><a id="more"></a><hr><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>数据管理与分析系统的发展离不开硬件和软件技术的进步。硬件和软件是构成计算系统的两大要素，软件技术的发展既可以享受硬件技术升级在性能提升方面带来的直接红利，但又受到硬件自身特点和局限性的制约，在架构和系统设计中引入不得已的取舍。同时，软件对于性能无止境的需求又反过来推动硬件技术的不断进步和革新。对于数据管理与分析系统而言，硬件技术是载体支撑，决定了数据存取和查询等处理性能的物理极限；软件的目标是优化算法与数据结构的设计以提高软件与硬件的契合度，最大化硬件使用效率同时规避或减少硬件固有的限制。一直以来，不论传统的“计算密集型”应用还是大数据时代的“数据密集型”应用，都持续对底层硬件系统在访问延迟、容量、带宽、能耗、性价比等指标上提出更高的要求。在多样化的应用负载需求下，传统的数据管理与分析技术正在面临前所未有的挑战。而大数据带来的挑战，本质上就是由现有的信息化基础设施的处理能力在多个维度上都难以满足数据处理多样化需求之间的矛盾所引起的。</p><p>信息化基础设施从广义上包含底层硬件环境与上层软件系统两个层次。而上层软件系统从设计原则、架构选型、核心功能、策略模式到优化技术，在很大程度上都是由当时的计算机硬件环境决定的。现今，信息领域的硬件技术和环境正在经历巨大的变化，特别是高性能处理器和硬件加速器、新型非易失存储器以及高速互联网络的出现正在快速改变传统的数据管理与分析系统的底层载体支撑。这些新型硬件有望突破整个计算体系的架构模式，改变上层软件的设计假设，在提供更高物理性能的同时，也要求数据管理与分析的软件架构和相关技术能够感知并适应新型硬件的特点。</p><h2 id="2-新型硬件发展趋势"><a href="#2-新型硬件发展趋势" class="headerlink" title="2 新型硬件发展趋势"></a>2 新型硬件发展趋势</h2><p>当前的计算机系统仍然广泛采用冯·诺依曼型体系结构，即以存储为中心的数据访问和处理架构。近年来，硬件技术在存储器和处理器两大核心部件以及网络连接上的发展取得了突破性进展，如图1所示，一系列高性能、全新架构、新特征的新型硬件不断涌现并逐渐成为主流技术，成为未来计算机平台的硬件发展趋势。趋势表明，高性能处理器和硬件加速器、新型非易失存储器、高速互联设备以及由它们催生的具有丰富硬件上下文的异构计算微架构、以高速持久化为显著特征的混合存储环境和支持远程直接数据存取的高速互联结构正在显著改变传统的数据管理与分析系统的底层支撑载体[1-4]。<br><img src="https://img-blog.csdn.net/2018030211055023" alt=""><br>图1：新型硬件及环境</p><h3 id="2-1-处理器技术发展趋势"><a href="#2-1-处理器技术发展趋势" class="headerlink" title="2.1 处理器技术发展趋势"></a>2.1 处理器技术发展趋势</h3><p>处理器技术发展至今已经经历了四十多年的发展历史，其发展技术路径经历了从提高主频为目标的Scale-up方式到以增加核心数量为目标的Scale-out方式的显著转变。依据摩尔定律的指引，在串行计算时代不断推高处理器的计算频率是提高计算机性能的最主要的发展途径之一，同时，在处理器Scale-up发展时期，指令级并行、流水线、自动预取、分支判断、乱序指令执行、多级cache、超线程等底层硬件优化技术由处理器硬件和编译程序自动识别和利用，数据管理与分析系统可以透明地利用处理器的性能提升而直接获得收益。但是受限于散热、功耗、指令级并行度以及制造工艺等因素，从半导体技术发展角度而言 Scale-up方式遭遇到了天花板，摩尔定律和Dennard Scaling法则在处理器技术的发展模式转向Scale-out的多/众核方式后才得以维系。</p><p>2005年之后，高性能处理器技术正式迈入多核时代，多核并行处理技术成为主流。虽然，更加丰富的硬件上下文显著增强了多核架构下数据处理的并行能力，但是，软件不能依靠多核处理器技术的升级而自动获得并行处理性能的收益，而是需要将传统的串行程序改写为并行程序，并针对多核处理器共享LLC（Last Level Cache）的特点而优化算法性能。随着处理器制程工艺的提高，多核处理器的性能得到显著提升，如采用14nm工艺的Xeon处理器当前最多集成24个核心，支持高达3.07 TB内存和85 GB/s的内存带宽[5]。但这种x86架构的处理器仍存在着集成度低、功耗高、价格昂贵等缺点，而且以通用为主要设计目标、擅长串行和逻辑控制的多核处理器也难以满足高性能应用愈发强烈的高并发需求。处理器的发展需要分化更多的功能，形成面向特定负载、低功耗、高并发的专用硬件加速器。</p><p><img src="https://img-blog.csdn.net/2018030211062711" alt=""><br>表1：代表性处理器的硬件特征</p><p>近年来，以GPU、Xeon Phi、FPGA（Field Programmable Gate Array，可编辑门阵列）等为代表的专用硬件加速器正在快速发展，借助GPU、Xeon Phi众核协处理器的高并行处理能力、高带宽内存访问性能、高性价比，以及FPGA的高度定制化和完全可重置能力，硬件加速器能够有效地独立完成从CPU卸载的部分计算密集型以及数据密集型任务，或者与CPU协作完成复杂的计算任务。表1显示了部分具有代表性的多/众核处理器，在核心数量、内存带宽性能、缓存容量等方面具有的优势硬件特征。可以预见，随着高性能处理器和硬件加速器融合与协作技术的发展趋势，计算机系统内部的处理环境变得越来越复杂化和异构化，也使得数据管理与分析技术需要寻求更多样化的优化途径。</p><h3 id="2-2-存储技术发展趋势"><a href="#2-2-存储技术发展趋势" class="headerlink" title="2.2 存储技术发展趋势"></a>2.2 存储技术发展趋势</h3><p>虽然高性能处理器和硬件加速器技术一直快速发展，但在经典的冯·诺依曼型体系结构下，处理器和存储器分离的架构使得处理器操作数据的速度与从传统内存获取所需数据的速度之间的差距却日益增大[6]，“内存墙”带来的数据访问性能瓶颈效应也不断加剧。面对传统二级存储设备的低速I/O能力，数据管理与分析系统在设计时不得不采用诸如缓存池、并发控制等多种设计策略以及面向磁盘的算法和数据结构以努力缓解或隐藏存储体之间的I/O性能差异，但I/O瓶颈仍然严重制约了数据密集型计算的处理能力。</p><p>近年来以新型非易失存储器（Non-Volatile Memory，NVM）[7]为代表的新型存储介质的发展为突破上述I/O瓶颈提供了基础。新型非易失存储是一类存储技术的概括性术语，其并不代表某个具体的存储技术或者介质，在部分研究文献中也被称为存储级内存（Storage Class Memory，SCM）[8]。具有代表性的新型非易失存储器包括：相变存储器（Phase Change Memory, PCM）、磁阻式存储器（Magnetoresistive Random-Access Memory，MRAM）、阻变式存储器（Resistive Random Access Memory，RRAM）、铁电存储器（Ferroelectronic RAM, FeRAM）等。虽然不同存储器的工作原理以及设计和制造工艺都存在明显差异，但是总体来说，此类存储器普遍具有可持久化、高存储密度、低延迟随机读写、细粒度的按字节寻址等优良特性，如表2所示。从性能指标来看，NVM比较接近DDR内存性能，而且具有非易失性特征，在新的存储体系中可能逐渐成为主要的存储设备，而DDR内存则作为临时数据的缓存使用。闪存（Flash）技术发展最为成熟，当前PCI-e闪存最高单卡容量达到12.8TB，在读写性能上也达到较高的水平，既可以作为磁盘与系统内存之间的数据缓存，也可以替代硬盘作为持久存储设备。从能耗指标来看，内存在高负载时的能耗较低，但由于低负载时仍然需要刷新，因此低负载时的能耗水平高于其他存储设备。非易失存储器共同的特点使它们同时拥有内存式的高速访问以及外存式的持久化双重能力，其有效地解决了传统存储介质在某些关键指标上无法逾越的“性能墙”。<br><img src="https://img-blog.csdn.net/20180302110709559" alt=""><br>表2：不同存储器的关键性能指标对比</p><p>同时，新型存储技术的发展对处理器技术也具有相当重要的影响，提高新型存储容量的高带宽3D堆叠技术可以应用于众核协处理器的板载存储上，为众核处理器强大的并行处理能力提供内存侧的高性能数据缓存支持。随着NVM技术的不断成熟，其构筑的多层级混合非易失存储环境必将打破计算机传统架构中CPU、主存、系统总线、外存之间的平衡性，改变存储金字塔现有结构，优化数据访问关键路径，弥补存储层级间的性能鸿沟，为数据管理和分析技术的设计带来新的机遇[9]。</p><h3 id="2-3-网络技术发展趋势"><a href="#2-3-网络技术发展趋势" class="headerlink" title="2.3 网络技术发展趋势"></a>2.3 网络技术发展趋势</h3><p>除了本地存储体系带来的I/O瓶颈外，网络I/O子系统也是分布式环境下数据中心最主要的性能瓶颈，传统以太网有限的传输能力和对CPU负载的需求在很大程度上影响了分布式环境下的数据处理性能。受此影响，当分布式事务比例较高时，系统整体吞吐量极度下降，导致系统事务处理能力不能有效扩展。基于此，既有的数据管理系统不得不借助协同划分、放松一致性保证、确定性执行等策略或技术来控制和减少分布式事务的比例。但这些手段大都存在部分不尽合理的假设、适用条件以及对应用开发者的不透明性，特别是当负载不具有可划分特征时，系统的可扩展能力仍然受到很大的限制。</p><p>产生该问题的本质并不是访问冲突的增加而是有限的网络带宽和TCP/IP通信栈引入的CPU开销[10]。在传统以太网和TCP/IP协议支撑的网络环境下，软件技术仅能带来一定程度上的优化，无法从根本上解决分布式环境下数据处理系统的可扩展性问题。近年来，RDMA（Remote Direct Memory Access）高性能网络的出现正在大幅改善服务器集群所依赖的高速互联网络环境。RDMA高性能网络从硬件级别保证了可以从用户态绕过内核态直接在网络间收发数据的能力，由于卸载了CPU的负荷也不存在中断等高昂的软件栈开销，极大改善了服务器间跨节点的数据访问性能。InfiniBand、iWARP以及RoCE等都是采用完全由硬件执行I/O交换的具体实现方式、RDMA使能的新型网络技术和协议。借助于高速、低时延、高带宽、低CPU占有率、高可靠等显著优点，高速互联环境提供了近乎与单机内存带宽相当的数据传输能力，消除了以往分布式环境下固有的内在瓶颈。近年来，随着RDMA相关硬件价格的不断降低，其主要应用环境正在从高性能计算领域逐渐向基于普通集群的数据管理领域迁移，也为数据管理与分析系统的设计提供了全新的网络环境，在分布式查询、事务处理等核心功能上提供了新的发展机遇[11]。</p><p>虽然目前新型处理器和加速器、非易失存储器以及高速互联设备的发展具有很大的多样性，硬件环境的构成也具有不确定性，但可以预见的是，未来他们必将成为计算环境中新的硬件组件标准，针对这些新硬件开展数据管理与分析相关技术的研究将成为新的热点。</p>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能硬件 </tag>
            
            <tag> 数据管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>caffe-源码学习——只看一篇就够了</title>
      <link href="/2017/10/15/caffe_%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/10/15/caffe_%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/78606832" target="_blank" rel="noopener">点这里</a></p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>说caffe代码难懂，其实关键点在于caffe中有很多基础的数学运算代码，如果能够对掌握这些数学运算，剩下的就是推公式了。</p><a id="more"></a><hr><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>###sigmoid</p><p>看softmax函数之前先看一下简单的sigmoid, 这个sigmoid layer的cpp实现是非常简洁的。 sigmoid的cpp文件里主要给了三个函数的实现，分别是sigmoid函数，forward_cpu, backward_cpu,在cpp文件里只实现了算法的CPU版本，至于GPU版本的函数实现放在.cu文件里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">inline Dtype sigmoid(Dtype x) &#123;</span><br><span class="line">  return 0.5 * tanh(0.5 * x) + 0.5;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">void SigmoidLayer&lt;Dtype&gt;::Forward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;</span><br><span class="line">  const Dtype* bottom_data = bottom[0]-&gt;cpu_data();</span><br><span class="line">  Dtype* top_data = top[0]-&gt;mutable_cpu_data();</span><br><span class="line">  const int count = bottom[0]-&gt;count();</span><br><span class="line">  for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">    top_data[i] = sigmoid(bottom_data[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">void SigmoidLayer&lt;Dtype&gt;::Backward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,</span><br><span class="line">    const vector&lt;bool&gt;&amp; propagate_down,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) &#123;</span><br><span class="line">  if (propagate_down[0]) &#123;</span><br><span class="line">    const Dtype* top_data = top[0]-&gt;cpu_data();</span><br><span class="line">    const Dtype* top_diff = top[0]-&gt;cpu_diff();</span><br><span class="line">    Dtype* bottom_diff = bottom[0]-&gt;mutable_cpu_diff();</span><br><span class="line">    const int count = bottom[0]-&gt;count();</span><br><span class="line">    for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">      const Dtype sigmoid_x = top_data[i];</span><br><span class="line">      bottom_diff[i] = top_diff[i] * sigmoid_x * (1. - sigmoid_x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###sigmoid函数<br>注意这里的sigmoid函数与标准的定义不太一样。参见ufld里面的定义<br><a href="http://ufldl.stanford.edu/wiki/index.php/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">神经网络UFLD</a></p><p>而在这里 sigmoid = 0.5 tanh(0.5 x) + 0.5, sigmoid变化范围为从0-1, tanh从-1到1，乘于0.5再加上0.5两者变化范围就一样了。</p><blockquote><p>forward_cpu</p></blockquote><p>这个很容易就能看懂，就是对每一个bottom元素计算sigmoid就得到来top的元素。</p><blockquote><p>backward_cpu</p></blockquote><p>发现新版的代码真的很好懂，sigmoid函数的到函数是sigmoid*(1-sigmoid) , 所以这里就直接利用来。其中propagate_down表明这一层是否要反传。</p><blockquote><p>softmaxlayer</p></blockquote><p>这段代码比较复杂，比较好的注释如下。但是这个注释针对的代码版本比较老。<br><a href="http://blog.csdn.net/u010668083/article/details/44857455" target="_blank" rel="noopener">caffe深度学习网络softmax层代码注释</a></p><p>这里我们分析比较新的代码，当前(20170622)比较新的代码是20161202提交的代码，结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/template &lt;typename Dtype&gt;</span><br><span class="line">void SoftmaxLayer&lt;Dtype&gt;::Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;</span><br><span class="line">  softmax_axis_ =</span><br><span class="line">      bottom[0]-&gt;CanonicalAxisIndex(this-&gt;layer_param_.softmax_param().axis());</span><br><span class="line">  //softmax层的输出应该与输入层一致</span><br><span class="line">  top[0]-&gt;ReshapeLike(*bottom[0]);</span><br><span class="line">  vector&lt;int&gt; mult_dims(1, bottom[0]-&gt;shape(softmax_axis_));</span><br><span class="line">  sum_multiplier_.Reshape(mult_dims);</span><br><span class="line">  Dtype* multiplier_data = sum_multiplier_.mutable_cpu_data();</span><br><span class="line">  caffe_set(sum_multiplier_.count(), Dtype(1), multiplier_data);</span><br><span class="line">  outer_num_ = bottom[0]-&gt;count(0, softmax_axis_);</span><br><span class="line">  inner_num_ = bottom[0]-&gt;count(softmax_axis_ + 1);</span><br><span class="line">  vector&lt;int&gt; scale_dims = bottom[0]-&gt;shape();</span><br><span class="line">  // scale_尺寸为：num*1*height*width</span><br><span class="line">  scale_dims[softmax_axis_] = 1;</span><br><span class="line">  scale_.Reshape(scale_dims);</span><br><span class="line">&#125;</span><br><span class="line">//前向计算，得到softmax的值</span><br><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">void SoftmaxLayer&lt;Dtype&gt;::Forward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) &#123;</span><br><span class="line">  const Dtype* bottom_data = bottom[0]-&gt;cpu_data();</span><br><span class="line">  Dtype* top_data = top[0]-&gt;mutable_cpu_data();</span><br><span class="line">  Dtype* scale_data = scale_.mutable_cpu_data();</span><br><span class="line">  int channels = bottom[0]-&gt;shape(softmax_axis_);</span><br><span class="line">  int dim = bottom[0]-&gt;count() / outer_num_;</span><br><span class="line">  caffe_copy(bottom[0]-&gt;count(), bottom_data, top_data);</span><br><span class="line">  // We need to subtract the max to avoid numerical issues, compute the exp,</span><br><span class="line">  // and then normalize.</span><br><span class="line">  // 先找到最大值</span><br><span class="line">  for (int i = 0; i &lt; outer_num_; ++i) &#123;//outer_num就是num输出数据的数目</span><br><span class="line">    // initialize scale_data to the first plane</span><br><span class="line">    caffe_copy(inner_num_, bottom_data + i * dim, scale_data);//dim表示每个数据有多少个不同类别的值.</span><br><span class="line">    for (int j = 0; j &lt; channels; j++) &#123;</span><br><span class="line">      for (int k = 0; k &lt; inner_num_; k++) &#123;</span><br><span class="line">        scale_data[k] = std::max(scale_data[k],//每个元素表示应该是当前位置中所有类别和channel里面最大的那一个。</span><br><span class="line">            bottom_data[i * dim + j * inner_num_ + k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // subtraction 减去最大值 详细分析见后面 </span><br><span class="line">    caffe_cpu_gemm&lt;Dtype&gt;(CblasNoTrans, CblasNoTrans, channels, inner_num_,</span><br><span class="line">        1, -1., sum_multiplier_.cpu_data(), scale_data, 1., top_data);</span><br><span class="line">    // exponentiation 求指数</span><br><span class="line">    caffe_exp&lt;Dtype&gt;(dim, top_data, top_data);</span><br><span class="line">    // sum after exp 求和</span><br><span class="line">    caffe_cpu_gemv&lt;Dtype&gt;(CblasTrans, channels, inner_num_, 1.,</span><br><span class="line">        top_data, sum_multiplier_.cpu_data(), 0., scale_data);</span><br><span class="line">    // division 做除法</span><br><span class="line">    for (int j = 0; j &lt; channels; j++) &#123;</span><br><span class="line">      caffe_div(inner_num_, top_data, scale_data, top_data);</span><br><span class="line">      top_data += inner_num_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename Dtype&gt;</span><br><span class="line">void SoftmaxLayer&lt;Dtype&gt;::Backward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,</span><br><span class="line">    const vector&lt;bool&gt;&amp; propagate_down,</span><br><span class="line">    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) &#123;</span><br><span class="line">  const Dtype* top_diff = top[0]-&gt;cpu_diff();</span><br><span class="line">  const Dtype* top_data = top[0]-&gt;cpu_data();</span><br><span class="line">  Dtype* bottom_diff = bottom[0]-&gt;mutable_cpu_diff();</span><br><span class="line">  Dtype* scale_data = scale_.mutable_cpu_data();</span><br><span class="line">  int channels = top[0]-&gt;shape(softmax_axis_);</span><br><span class="line">  int dim = top[0]-&gt;count() / outer_num_;</span><br><span class="line">  caffe_copy(top[0]-&gt;count(), top_diff, bottom_diff);</span><br><span class="line">  for (int i = 0; i &lt; outer_num_; ++i) &#123;</span><br><span class="line">    // compute dot(top_diff, top_data) and subtract them from the bottom diff</span><br><span class="line">//计算top_diff与top_data的点集</span><br><span class="line">    for (int k = 0; k &lt; inner_num_; ++k) &#123;</span><br><span class="line">      scale_data[k] = caffe_cpu_strided_dot&lt;Dtype&gt;(channels,</span><br><span class="line">          bottom_diff + i * dim + k, inner_num_,</span><br><span class="line">          top_data + i * dim + k, inner_num_);</span><br><span class="line">    &#125;</span><br><span class="line">    // subtraction</span><br><span class="line">    caffe_cpu_gemm&lt;Dtype&gt;(CblasNoTrans, CblasNoTrans, channels, inner_num_, 1,</span><br><span class="line">        -1., sum_multiplier_.cpu_data(), scale_data, 1., bottom_diff + i * dim);</span><br><span class="line">  &#125;</span><br><span class="line">  // elementwise multiplication</span><br><span class="line">  caffe_mul(top[0]-&gt;count(), bottom_diff, top_data, bottom_diff);</span><br><span class="line">&#125;</span><br><span class="line">#ifdef CPU_ONLY</span><br><span class="line">STUB_GPU(SoftmaxLayer);</span><br><span class="line">#endif</span><br><span class="line">INSTANTIATE_CLASS(SoftmaxLayer);</span><br></pre></td></tr></table></figure><blockquote><p>caffe_cpu_gemm减法 </p></blockquote><p>在forward_cpu函数里做减法的时候调用来caffe_cpu_gemm函数，这个函数的实现在 src/caffe/util/math_functions.cpp里面<br><a href="http://blog.csdn.net/seven_first/article/details/47378697#1-caffecpugemm-函数" target="_blank" rel="noopener">caffecpugemm-函数</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">void caffe_cpu_gemm&lt;float&gt;(const CBLAS_TRANSPOSE TransA,</span><br><span class="line">    const CBLAS_TRANSPOSE TransB, const int M, const int N, const int K,</span><br><span class="line">    const float alpha, const float* A, const float* B, const float beta,</span><br><span class="line">    float* C) &#123;</span><br><span class="line">  int lda = (TransA == CblasNoTrans) ? K : M;</span><br><span class="line">  int ldb = (TransB == CblasNoTrans) ? N : K;</span><br><span class="line">  cblas_sgemm(CblasRowMajor, TransA, TransB, M, N, K, alpha, A, lda, B,</span><br><span class="line">      ldb, beta, C, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>功能： C=alphaAB+beta*C<br>A,B,C 是输入矩阵（一维数组格式）<br>CblasRowMajor :数据是行主序的（二维数据也是用一维数组储存的）<br>TransA, TransB：是否要对A和B做转置操作（CblasTrans CblasNoTrans）<br>M： A、C 的行数<br>N： B、C 的列数<br>K： A 的列数， B 的行数<br>lda ： A的列数（不做转置）行数（做转置）<br>ldb： B的列数（不做转置）行数（做转置）</p></blockquote><p>所以这里求减法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caffe_cpu_gemm&lt;Dtype&gt;(CblasNoTrans, CblasNoTrans, channels, inner_num_,</span><br><span class="line">    1, -1., sum_multiplier_.cpu_data(), scale_data, 1., top_data);</span><br></pre></td></tr></table></figure><p>就是： $top_data = top_data - 1 sum_multiplier_.cpu_data()scale_data$， 这里用top_data来减而不用bottom一方面是因为bottom是const的，取的是cpu_data(), 而top_data是mutable_cpu_data,另一方面之前已经把数据从bottom拷贝到top里面去了。</p><p>而在back_ward函数里面也用到了这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caffe_cpu_gemm&lt;Dtype&gt;(CblasNoTrans, CblasNoTrans, channels, inner_num_, 1,</span><br><span class="line">        -1., sum_multiplier_.cpu_data(), scale_data, 1., bottom_diff + i * dim);</span><br></pre></td></tr></table></figure><p>$$bottom_diff + i dim = bottom_diff + i dim - sum_multiplier_.cpu_data() * scale_data$$</p><blockquote><p>caffe_exp指数</p></blockquote><p>caffe_exp函数是用来求指数的，其中一个实现是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt;</span><br><span class="line">void caffe_exp&lt;float&gt;(const int n, const float* a, float* y) &#123;</span><br><span class="line">  vsExp(n, a, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>功能： y[i] = exp(a[i] )</p></blockquote><p>所以， forward_cpu里面的指数就很容易理解了。</p><p>caffe_exp<dtype>(dim, top_data, top_data);</dtype></p><blockquote><p>caffe_cpu_gemv求和</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt;</span><br><span class="line">void caffe_cpu_gemv&lt;float&gt;(const CBLAS_TRANSPOSE TransA, const int M,</span><br><span class="line">    const int N, const float alpha, const float* A, const float* x,</span><br><span class="line">    const float beta, float* y) &#123;</span><br><span class="line">  cblas_sgemv(CblasRowMajor, TransA, M, N, alpha, A, N, x, 1, beta, y, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>功能： y=alphaAx+beta*y<br>其中X和Y是向量，A 是矩阵<br>M：A 的行数<br>N：A 的列数<br>cblas_sgemv 中的 参数1 表示对X和Y的每个元素都进行操作</p></blockquote><p>forward_cpu里面的求和就很容易理解了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// sum after exp 求和</span><br><span class="line">caffe_cpu_gemv&lt;Dtype&gt;(CblasTrans, channels, inner_num_, 1.,</span><br><span class="line">    top_data, sum_multiplier_.cpu_data(), 0., scale_data);</span><br></pre></td></tr></table></figure><p>scale_data =\sum top_data[i]*sum_multiplier_.cpu_data()[i];</p><blockquote><p>caffe_div除法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt;</span><br><span class="line">void caffe_div&lt;float&gt;(const int n, const float* a, const float* b,</span><br><span class="line">    float* y) &#123;</span><br><span class="line">  vsDiv(n, a, b, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>功能 y[i] = a[i] / b[i]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// division 做除法</span><br><span class="line">for (int j = 0; j &lt; channels; j++) &#123;</span><br><span class="line">  caffe_div(inner_num_, top_data, scale_data, top_data);</span><br><span class="line">  top_data += inner_num_;</span><br></pre></td></tr></table></figure><p>top_data[i] = top_data[i] / scale_data[i];</p><blockquote><p>caffe_cpu_strided_dot</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt;</span><br><span class="line">double caffe_cpu_strided_dot&lt;double&gt;(const int n, const double* x,</span><br><span class="line">    const int incx, const double* y, const int incy) &#123;</span><br><span class="line">  return cblas_ddot(n, x, incx, y, incy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>功能： 返回 vector X 和 vector Y 的内积。<br>incx， incy ： 步长，即每隔incx 或 incy 个element 进行操作。</p></blockquote><p>–</p><blockquote><p>caffe_mul</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;&gt;</span><br><span class="line">void caffe_mul&lt;float&gt;(const int n, const float* a, const float* b,</span><br><span class="line">    float* y) &#123;</span><br><span class="line">  vsMul(n, a, b, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能 $y[i]=a[i] * b[i] $</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caffe_mul(top[0]-&gt;count(), bottom_diff, top_data, bottom_diff);</span><br></pre></td></tr></table></figure><p>bottom_diff[i] = bottom_diff[i] * top_data[i]</p><p>##反向传播公式推导<br><a href="https://www.zhihu.com/question/28927103" target="_blank" rel="noopener">Caffe Softmax层的实现原理,知乎</a></p><p>看完softmax layer的实现，我们再来看一下SoftmaxWithLossLayer的代码实现。</p><p>##卷积层</p><p>##计算量与参数量</p><p>每个样本做一次前向传播时卷积计算量为： $ i jMNKL $ ，其中$ij$是卷积核的大小，$M*L$是输出特征图的大小，K是输入特征图通道数，L是输出特征图通道数。</p><p>参数量为：$ iJK*L $</p><p>所以有个比例叫做计算量参数量之比 CPR，如果在前馈时每个批次batch_size = B, 则表示将B个输入合并成一个矩阵进行计算，那么相当于每次的输出特征图增大来B倍，所以CPR提升来B倍，也就是，每次计算的时候参数重复利用率提高来B倍。</p><p>卷积层：局部互连，权值共享，</p><p>##源码学习<br>先用grep函数在caffe根目录下搜索一下包含ConvolutionLayer的文件有哪些，然后从头文件入手慢慢分析，下面是结果，精简来一些无效成分，在caffe的include文件夹下执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n -H -R &quot;ConvolutionLayer&quot;</span><br></pre></td></tr></table></figure><p>-n表示显示行号，-H表示显示文件名，-R表示递归查找 后面部分表示查找的内容<br>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">caffe/layer_factory.hpp:31: * (for example, when your layer has multiple backends, see GetConvolutionLayer</span><br><span class="line">caffe/layers/base_conv_layer.hpp:15: *        ConvolutionLayer and DeconvolutionLayer.</span><br><span class="line">caffe/layers/base_conv_layer.hpp:18:class BaseConvolutionLayer : public Layer&lt;Dtype&gt; &#123;</span><br><span class="line">caffe/layers/base_conv_layer.hpp:20:  explicit BaseConvolutionLayer(const LayerParameter&amp; param)</span><br><span class="line">caffe/layers/deconv_layer.hpp:17: *        opposite sense as ConvolutionLayer.</span><br><span class="line">caffe/layers/deconv_layer.hpp:19: *   ConvolutionLayer computes each output value by dotting an input window with</span><br><span class="line">caffe/layers/deconv_layer.hpp:22: *   DeconvolutionLayer is ConvolutionLayer with the forward and backward passes</span><br><span class="line">caffe/layers/deconv_layer.hpp:24: *   parameters, but they take the opposite sense as in ConvolutionLayer (so</span><br><span class="line">caffe/layers/deconv_layer.hpp:29:class DeconvolutionLayer : public BaseConvolutionLayer&lt;Dtype&gt; &#123;</span><br><span class="line">caffe/layers/deconv_layer.hpp:32:      : BaseConvolutionLayer&lt;Dtype&gt;(param) &#123;&#125;</span><br><span class="line">caffe/layers/im2col_layer.hpp:14: *        column vectors.  Used by ConvolutionLayer to perform convolution</span><br><span class="line">caffe/layers/conv_layer.hpp:31:class ConvolutionLayer : public BaseConvolutionLayer&lt;Dtype&gt; &#123;</span><br><span class="line">caffe/layers/conv_layer.hpp:35:   *    with ConvolutionLayer options:</span><br><span class="line">caffe/layers/conv_layer.hpp:64:  explicit ConvolutionLayer(const LayerParameter&amp; param)</span><br><span class="line">caffe/layers/conv_layer.hpp:65:      : BaseConvolutionLayer&lt;Dtype&gt;(param) &#123;&#125;</span><br><span class="line">caffe/layers/cudnn_conv_layer.hpp:16: * @brief cuDNN implementation of ConvolutionLayer.</span><br><span class="line">caffe/layers/cudnn_conv_layer.hpp:17: *        Fallback to ConvolutionLayer for CPU mode.</span><br><span class="line">caffe/layers/cudnn_conv_layer.hpp:30:class CuDNNConvolutionLayer : public ConvolutionLayer&lt;Dtype&gt; &#123;</span><br><span class="line">caffe/layers/cudnn_conv_layer.hpp:32:  explicit CuDNNConvolutionLayer(const LayerParameter&amp; param)</span><br><span class="line">caffe/layers/cudnn_conv_layer.hpp:33:      : ConvolutionLayer&lt;Dtype&gt;(param), handles_setup_(false) &#123;&#125;</span><br><span class="line">caffe/layers/cudnn_conv_layer.hpp:38:  virtual ~CuDNNConvolutionLayer();</span><br></pre></td></tr></table></figure><p>主要有三个类包含这个卷积层的实现：<br>base_conv_layer：主要是卷积层基类的实现<br>deconv_layer： 目测是反向传播时候的卷积层的逆向过程<br>cudnn_conv_layer：目测是cudnn实现的卷积层版本继承自BaseConvolutionLayer,GPU版本</p><p>接下来我们就打开这三个文件，跳转到相关行，详细看一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class BaseConvolutionLayer : public Layer&lt;Dtype&gt; &#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit BaseConvolutionLayer(const LayerParameter&amp; param)</span><br><span class="line">      : Layer&lt;Dtype&gt;(param) &#123;&#125;</span><br><span class="line">  virtual void LayerSetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);</span><br><span class="line">  virtual void Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,</span><br><span class="line">      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);</span><br><span class="line">  virtual inline int MinBottomBlobs() const &#123; return 1; &#125;</span><br><span class="line">  virtual inline int MinTopBlobs() const &#123; return 1; &#125;</span><br><span class="line">  virtual inline bool EqualNumBottomTopBlobs() const &#123; return true; &#125;</span><br><span class="line"> protected:</span><br><span class="line">  // Helper functions that abstract away the column buffer and gemm arguments.</span><br><span class="line">  // The last argument in forward_cpu_gemm is so that we can skip the im2col if</span><br><span class="line">  // we just called weight_cpu_gemm with the same input.</span><br><span class="line">  void forward_cpu_gemm(const Dtype* input, const Dtype* weights,</span><br><span class="line">      Dtype* output, bool skip_im2col = false);</span><br><span class="line">  void forward_cpu_bias(Dtype* output, const Dtype* bias);</span><br><span class="line">  void backward_cpu_gemm(const Dtype* input, const Dtype* weights,</span><br><span class="line">      Dtype* output);</span><br><span class="line">  void weight_cpu_gemm(const Dtype* input, const Dtype* output, Dtype*</span><br><span class="line">      weights);</span><br><span class="line">  void backward_cpu_bias(Dtype* bias, const Dtype* input);</span><br><span class="line">#ifndef CPU_ONLY</span><br><span class="line">  void forward_gpu_gemm(const Dtype* col_input, const Dtype* weights,</span><br><span class="line">      Dtype* output, bool skip_im2col = false);</span><br><span class="line">  void forward_gpu_bias(Dtype* output, const Dtype* bias);</span><br><span class="line">  void backward_gpu_gemm(const Dtype* input, const Dtype* weights,</span><br><span class="line">      Dtype* col_output);</span><br><span class="line">  void weight_gpu_gemm(const Dtype* col_input, const Dtype* output, Dtype*</span><br><span class="line">      weights);</span><br><span class="line">  void backward_gpu_bias(Dtype* bias, const Dtype* input);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>这里给出来CPU和GPU版本的代码的声明，这些代码比较底层，先放一放以后再看。<br>forward_cpu_gemm:猜测可能是前馈过程计算weight部分，来看看CPP里面的实现吧。</p><p>在BaseConvolutionLayer中的卷积的实现中有一个重要的函数就是<strong>im2col以及col2im，im2colnd以及col2imnd</strong>。前面的两个函数是二维卷积的正向和逆向过程，而后面的两个函数是n维卷积的正向和逆向过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void BaseConvolutionLayer&lt;Dtype&gt;::forward_cpu_gemm(const Dtype* input,</span><br><span class="line">    const Dtype* weights, Dtype* output, bool skip_im2col) &#123;</span><br><span class="line">  const Dtype* col_buff = input;</span><br><span class="line">  if (!is_1x1_) &#123;</span><br><span class="line">    if (!skip_im2col) &#123;</span><br><span class="line">  // 如果没有1x1卷积，也没有skip_im2col  </span><br><span class="line">      // 则使用conv_im2col_cpu对使用卷积核滑动过程中的每一个kernel大小的图像块  </span><br><span class="line">      // 变成一个列向量，形成一个height=kernel_dim_  </span><br><span class="line">      // width = 卷积后图像heght*卷积后图像width  </span><br><span class="line">      conv_im2col_cpu(input, col_buffer_.mutable_cpu_data());</span><br><span class="line">    &#125;</span><br><span class="line">    col_buff = col_buffer_.cpu_data();</span><br><span class="line">  &#125;</span><br><span class="line">  for (int g = 0; g &lt; group_; ++g) &#123;</span><br><span class="line">    caffe_cpu_gemm&lt;Dtype&gt;(CblasNoTrans, CblasNoTrans, conv_out_channels_ /</span><br><span class="line">        group_, conv_out_spatial_dim_, kernel_dim_,</span><br><span class="line">        (Dtype)1., weights + weight_offset_ * g, col_buff + col_offset_ * g,</span><br><span class="line">        (Dtype)0., output + output_offset_ * g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###参考资料<br><a href="http://blog.csdn.net/xizero00/article/details/51049858" target="_blank" rel="noopener">caffe代码阅读10：Caffe中卷积的实现细节</a></p><p>##数据集</p><p>###生成数据集的均值文件<br>这里计算图像的均值使用的是pper_image_mean方法，在natural images上训练的时候，这种方式比较好，以imagenet数据集为例，caffe在使用imagenet数据集的时候需要计算均值文件，详细见 <a href="https://github.com/DragonFive/deep-learning-exercise/blob/master/caffe_python1.ipynb" target="_blank" rel="noopener">python-caffe</a></p><p>###caffe-blob<br><a href="http://blog.csdn.net/chenriwei2/article/details/46367023" target="_blank" rel="noopener">【Caffe代码解析】Blob</a><br><a href="http://blog.csdn.net/lingerlanlan/article/details/24379689" target="_blank" rel="noopener">caffe源码分析–Blob类代码研究</a><br><a href="http://www.cnblogs.com/louyihang-loves-baiyan/p/5149628.html" target="_blank" rel="noopener">Caffe源码解析1：Blob</a></p><p>##结构体分析<br>Blob 是Caffe作为数据传输的媒介，无论是网络权重参数，还是输入数据，都是转化为Blob数据结构来存储，网络，求解器等都是直接与此结构打交道的。</p><p>4纬的结构体（包含数据和梯度)，其4维结构通过shape属性得以计算出来.</p><p>###成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected:</span><br><span class="line"> shared_ptr&lt;SyncedMemory&gt; data_;// 存放数据</span><br><span class="line"> shared_ptr&lt;SyncedMemory&gt; diff_;//存放梯度</span><br><span class="line"> vector&lt;int&gt; shape_; //存放形状</span><br><span class="line"> int count_; //数据个数</span><br><span class="line"> int capacity_; //数据容量</span><br></pre></td></tr></table></figure><p>###成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> const Dtype* cpu_data() const; //cpu使用的数据</span><br><span class="line">  void set_cpu_data(Dtype* data);//用数据块的值来blob里面的data。</span><br><span class="line">  const Dtype* gpu_data() const;//返回不可更改的指针，下同</span><br><span class="line">  const Dtype* cpu_diff() const;</span><br><span class="line">  const Dtype* gpu_diff() const;</span><br><span class="line">  Dtype* mutable_cpu_data();    //返回可更改的指针，下同</span><br><span class="line">  Dtype* mutable_gpu_data();</span><br><span class="line">  Dtype* mutable_cpu_diff();</span><br><span class="line">  Dtype* mutable_gpu_diff();</span><br><span class="line">  </span><br><span class="line">  int offset(const int n, const int c = 0, const int h = 0,const int w = 0) const</span><br><span class="line">// 通过n,c,h,w 4个参数来计算一维向量的偏移量。</span><br><span class="line">Dtype data_at(const int n, const int c, const int h,const int w) const//通过n,c,h,w 4个参数来来获取该向量位置上的值。</span><br><span class="line">Dtype diff_at(const int n, const int c, const int h,const int w) const//同上</span><br><span class="line">inline const shared_ptr&lt;SyncedMemory&gt;&amp; data() const &#123;</span><br><span class="line">    CHECK(data_);</span><br><span class="line">    return data_;//返回数据，不能修改</span><br><span class="line">  &#125;</span><br><span class="line">inline const shared_ptr&lt;SyncedMemory&gt;&amp; diff() const &#123;</span><br><span class="line">    CHECK(diff_);</span><br><span class="line">    return diff_;//返回梯度，不能修改</span><br><span class="line">  &#125;</span><br><span class="line">Reshape(...)//reshape 有多种多态的实现，可以是四个数字，长度为四的vector，其它blob等。</span><br><span class="line">if (count_ &gt; capacity_) &#123;</span><br><span class="line">    capacity_ = count_;</span><br><span class="line">    data_.reset(new SyncedMemory(capacity_ * sizeof(Dtype)));</span><br><span class="line">    diff_.reset(new SyncedMemory(capacity_ * sizeof(Dtype)));</span><br><span class="line">  &#125;//当空间不够的时候，需要扩大容量，reset。</span><br></pre></td></tr></table></figure><p>函数名中带mutable的表示可以对返回的指针内容进行修改。</p><p>##caffe学习资料收集<br><a href="https://absentm.github.io/2016/05/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0Caffe%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">深度学习Caffe系列教程集合</a><br><a href="https://yufeigan.github.io/" target="_blank" rel="noopener">甘宇飞</a><br><a href="https://zhuanlan.zhihu.com/Edison-G" target="_blank" rel="noopener">计算机视觉战队</a></p><p><a href="http://blog.163.com/yuyang_tech/blog/static/2160500832015713105052452/" target="_blank" rel="noopener">caffe源码简单解析——Layer层</a></p><p><a href="http://blog.csdn.net/kkk584520/article/details/41681085" target="_blank" rel="noopener">Caffe代码导读（0）：路线图</a></p><p><a href="https://www.zhihu.com/question/27982282" target="_blank" rel="noopener">知乎问题-深度学习caffe的代码怎么读？</a></p><p><a href="http://www.cnblogs.com/louyihang-loves-baiyan/p/5149628.html" target="_blank" rel="noopener">Caffe源码解析1：Blob</a></p><p><a href="https://zhuanlan.zhihu.com/p/24343706" target="_blank" rel="noopener">深度学习大讲堂——深度学习框架Caffe源码解析</a></p><p><a href="https://zhuanlan.zhihu.com/p/24709689" target="_blank" rel="noopener">Caffe代码夜话1</a></p><p><a href="http://blog.leanote.com/post/fishing_piggy/Caffe%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89" target="_blank" rel="noopener">Caffe源码分析（一）</a></p><blockquote><p>本文作者： DragonFive<br>本文链接： <a href="https://dragonfive.github.io/2017-06-12/caffe_code_study1/" target="_blank" rel="noopener">https://dragonfive.github.io/2017-06-12/caffe_code_study1/</a><br>版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！</p></blockquote>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> caffe </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux C串口常规设置参考</title>
      <link href="/2017/08/15/linux_C%E4%B8%B2%E5%8F%A3%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE%E5%8F%82%E8%80%83/"/>
      <url>/2017/08/15/linux_C%E4%B8%B2%E5%8F%A3%E5%B8%B8%E8%A7%84%E8%AE%BE%E7%BD%AE%E5%8F%82%E8%80%83/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/70370624" target="_blank" rel="noopener">点这里</a><br>据通信的基本方式可分为并行通信与串行通信两种。<br>· 并行通信是指利用多条数据传输线将一个资料的各位同时传送。它的特点是传输速度<br>快，适用于短距离通信，但要求传输速度较高的应用场合。<br>· 串行通信是指利用一条传输线将资料一位位地顺序传送。特点是通信线路简单，利用<br>简单的线缆就可实现通信，降低成本，适用于远距离通信，但传输速度慢的应用场合。</p><a id="more"></a><p>串口设置详解<br>本节主要讲解设置串口的主要方法。<br>如前所述，设置串口中最基本的包括波特率设置，校验位和停止位设置。串口的设置主<br>要是设置struct termios结构体的各成员值，如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">＃include</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termio</span></span></span><br><span class="line"><span class="class">&#123;</span>      </span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span> c_iflag; <span class="comment">/* 输入模式标志 */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span> c_oflag; <span class="comment">/* 输出模式标志 */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span> c_cflag; <span class="comment">/* 控制模式标志*/</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">short</span> c_lflag; <span class="comment">/*本地模式标志 */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">char</span> c_line; <span class="comment">/* line discipline */</span></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">char</span> c_cc[NCC]; <span class="comment">/* control characters */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在这个结构中最为重要的是c_cflag，通过对它的赋值，用户可以设置波特率、字符大小、<br>数据位、停止位、奇偶校验位和硬件流控等。另外c_iflag 和c_cc 也是比较常用的标志。在<br>此主要对这3 个成员进行详细说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">c_cflag支持的常量名称</span><br><span class="line">CBAUD        波特率的位掩码</span><br><span class="line">B0           <span class="number">0</span>波特率（放弃DTR）</span><br><span class="line">B1800        <span class="number">1800</span>波特率</span><br><span class="line">B2400        <span class="number">2400</span>波特率</span><br><span class="line">B4800        <span class="number">4800</span>波特率</span><br><span class="line">B9600        <span class="number">9600</span>波特率</span><br><span class="line">B19200       <span class="number">19200</span>波特率</span><br><span class="line">B38400       <span class="number">38400</span>波特率</span><br><span class="line">B57600       <span class="number">57600</span>波特率</span><br><span class="line">B115200      <span class="number">115200</span>波特率</span><br><span class="line">EXTA         外部时钟率</span><br><span class="line">EXTB         外部时钟率</span><br><span class="line">CSIZE        数据位的位掩码</span><br><span class="line">CS5          <span class="number">5</span>个数据位</span><br><span class="line">CS6          <span class="number">6</span>个数据位</span><br><span class="line">CS7          <span class="number">7</span>个数据位</span><br><span class="line">CS8          <span class="number">8</span>个数据位</span><br><span class="line">CSTOPB       <span class="number">2</span>个停止位（不设则是<span class="number">1</span>个停止位）</span><br><span class="line">CREAD        接收使能</span><br><span class="line">PARENB       校验位使能</span><br><span class="line">PARODD       使用奇校验而不使用偶校验</span><br><span class="line">HUPCL        最后关闭时挂线（放弃DTR）</span><br><span class="line">CLOCAL       本地连接（不改变端口所有者）</span><br><span class="line">LOBLK        块作业控制输出</span><br><span class="line">CNET_CTSRTS  硬件流控制使能</span><br><span class="line"></span><br><span class="line">      c_iflag支持的常量名称</span><br><span class="line">INPCK        奇偶校验使能</span><br><span class="line">IGNPAR       忽略奇偶校验错误</span><br><span class="line">PARMRK       奇偶校验错误掩码</span><br><span class="line">ISTRIP       除去奇偶校验位</span><br><span class="line">IXON         启动出口硬件流控</span><br><span class="line">IXOFF        启动入口软件流控</span><br><span class="line">IXANY        允许字符重新启动流控</span><br><span class="line">IGNBRK       忽略中断情况</span><br><span class="line">BRKINT       当发生中断时发送SIGINT信号</span><br><span class="line">INLCR        将NL映射到CR</span><br><span class="line">IGNCR        忽略CR</span><br><span class="line">ICRNL        将CR映射到NL</span><br><span class="line">IUCLC        将高位情况映射到低位情况</span><br><span class="line">IMAXBEL      当输入太长时回复ECHO</span><br><span class="line">c_cc 支持的常量名称</span><br><span class="line">VINTR     中断控制，对应键为CTRL+C</span><br><span class="line">VQUIT     退出操作，对应键为CRTL+Z</span><br><span class="line">VERASE    删除操作，对应键为Backspace（BS）</span><br><span class="line">VKILL     删除行，对应键为CTRL+U</span><br><span class="line">VEOF      位于文件结尾，对应键为CTRL+D</span><br><span class="line">VEOL      位于行尾，对应键为Carriage <span class="keyword">return</span>（CR）</span><br><span class="line">VEOL2     位于第二行尾，对应键为Line feed（LF）</span><br><span class="line">VMIN      指定了最少读取的字符数</span><br><span class="line">VTIME     指定了读取每个字符的等待时间</span><br><span class="line"></span><br><span class="line">串口控制函数</span><br><span class="line">Tcgetattr         取属性(termios结构)</span><br><span class="line">Tcsetattr         设置属性(termios结构)</span><br><span class="line">cfgetispeed     得到输入速度</span><br><span class="line">Cfgetospeed           得到输出速度</span><br><span class="line">Cfsetispeed            设置输入速度</span><br><span class="line">Cfsetospeed           设置输出速度</span><br><span class="line">Tcdrain           等待所有输出都被传输</span><br><span class="line">tcflow           挂起传输或接收</span><br><span class="line">tcflush           刷清未决输入和/或输出</span><br><span class="line">Tcsendbreak           送BREAK字符</span><br><span class="line">tcgetpgrp              得到前台进程组ID</span><br><span class="line">tcsetpgrp               设置前台进程组ID</span><br></pre></td></tr></table></figure><pre><code>[color=#ff0000]完整的串口配置模板，实用！把常用的选项在函数里面列出，可大大方便用户的调试使用[/color]</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_opt</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> nSpeed, <span class="keyword">int</span> nBits, <span class="keyword">char</span> nEvent, <span class="keyword">int</span> nStop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">newtio</span>,<span class="title">oldtio</span>;</span></span><br><span class="line">    <span class="comment">/*保存测试现有串口参数设置，在这里如果串口号等出错，会有相关的出错信息*/</span></span><br><span class="line">    <span class="keyword">if</span> ( tcgetattr( fd,&amp;oldtio) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"SetupSerial 1"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    bzero( &amp;newtio, <span class="keyword">sizeof</span>( newtio ) );</span><br><span class="line">    <span class="comment">/*步骤一，设置字符大小*/</span></span><br><span class="line">    newtio.c_cflag |= CLOCAL | CREAD;</span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line">    <span class="comment">/*设置停止位*/</span></span><br><span class="line">    <span class="keyword">switch</span>( nBits )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            newtio.c_cflag |= CS7;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            newtio.c_cflag |= CS8;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*设置奇偶校验位*/</span></span><br><span class="line">    <span class="keyword">switch</span>( nEvent )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'O'</span>: <span class="comment">//奇数</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag |= PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'E'</span>: <span class="comment">//偶数</span></span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'N'</span>: <span class="comment">//无奇偶校验位</span></span><br><span class="line">            newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*设置波特率*/</span></span><br><span class="line">    <span class="keyword">switch</span>( nSpeed )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2400</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B2400);</span><br><span class="line">            cfsetospeed(&amp;newtio, B2400);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4800</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B4800);</span><br><span class="line">            cfsetospeed(&amp;newtio, B4800);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9600</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">115200</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B115200);</span><br><span class="line">            cfsetospeed(&amp;newtio, B115200);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">460800</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B460800);</span><br><span class="line">            cfsetospeed(&amp;newtio, B460800);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*设置停止位*/</span></span><br><span class="line">    <span class="keyword">if</span>( nStop == <span class="number">1</span> )</span><br><span class="line">        newtio.c_cflag &amp;= ~CSTOPB;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( nStop == <span class="number">2</span> )</span><br><span class="line">        newtio.c_cflag |= CSTOPB;</span><br><span class="line">    <span class="comment">/*设置等待时间和最小接收字符*/</span> </span><br><span class="line">    newtio.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line">    newtio.c_cc[VMIN] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*处理未接收字符*/</span></span><br><span class="line">    tcflush(fd,TCIFLUSH);</span><br><span class="line">    <span class="comment">/*激活新配置*/</span></span><br><span class="line">    <span class="keyword">if</span>((tcsetattr(fd,TCSANOW,&amp;newtio))!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"com set error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"set done!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[b]串口使用详解[/b]<br>在配置完串口的相关属性后，就可对串口进行打开，读写操作了。其使用方式与文件操作一样，区别在于串口是一个终端设备。</p><p>[b]打开串口[/b]<br>fd = open( “/dev/ttyS0”, O_RDWR|O_NOCTTY|O_NDELAY);</p><p>   Open函数中除普通参数外，另有两个参数O_NOCTTY和O_NDELAY。<br>   O_NOCTTY: 通知linix系统，这个程序不会成为这个端口的控制终端。<br>   O_NDELAY: 通知Linux系统不关心DCD信号线所处的状态（端口的另一端是否激活或者停止）。<br>然后，恢复串口的状态为阻塞状态，用于等待串口数据的读入。用fcntl函数：<br>       fcntl（fd, F_SETFL, 0）;</p><p>   接着，测试打开的文件描述府是否引用一个终端设备，以进一步确认串口是否正确打开。<br>       isatty(STDIN_FILENO);<br>串口的读写与普通文件一样，使用read,write函数。<br>       read(fd,buff,8);<br>       write(fd,buff,8);<br>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">＃i nclude stdio.h&gt;</span><br><span class="line">＃i nclude <span class="built_in">string</span>.h&gt;</span><br><span class="line">＃i nclude sys/types.h&gt;</span><br><span class="line">＃i nclude errno.h&gt;</span><br><span class="line">＃i nclude sys/stat.h&gt;</span><br><span class="line">＃i nclude fcntl.h&gt;</span><br><span class="line">＃i nclude unistd.h&gt;</span><br><span class="line">＃i nclude termios.h&gt;</span><br><span class="line">＃i nclude stdlib.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_opt</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> nSpeed, <span class="keyword">int</span> nBits, <span class="keyword">char</span> nEvent, <span class="keyword">int</span> nStop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">newtio</span>,<span class="title">oldtio</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ( tcgetattr( fd,&amp;oldtio) != <span class="number">0</span>) &#123; </span><br><span class="line">        perror(<span class="string">"SetupSerial 1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bzero( &amp;newtio, <span class="keyword">sizeof</span>( newtio ) );</span><br><span class="line">    newtio.c_cflag |= CLOCAL | CREAD; </span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE; </span><br><span class="line">    <span class="keyword">switch</span>( nBits )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        newtio.c_cflag |= CS7;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        newtio.c_cflag |= CS8;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>( nEvent )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'O'</span>:</span><br><span class="line">        newtio.c_cflag |= PARENB;</span><br><span class="line">        newtio.c_cflag |= PARODD;</span><br><span class="line">        newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'E'</span>: </span><br><span class="line">        newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">        newtio.c_cflag |= PARENB;</span><br><span class="line">        newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'N'</span>: </span><br><span class="line">        newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">switch</span>( nSpeed )</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2400</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B2400);</span><br><span class="line">        cfsetospeed(&amp;newtio, B2400);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4800</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B4800);</span><br><span class="line">        cfsetospeed(&amp;newtio, B4800);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9600</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">        cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">115200</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B115200);</span><br><span class="line">        cfsetospeed(&amp;newtio, B115200);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">        cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( nStop == <span class="number">1</span> )</span><br><span class="line">        newtio.c_cflag &amp;= ~CSTOPB;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( nStop == <span class="number">2</span> )</span><br><span class="line">    newtio.c_cflag |= CSTOPB;</span><br><span class="line">    newtio.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line">    newtio.c_cc[VMIN] = <span class="number">0</span>;</span><br><span class="line">    tcflush(fd,TCIFLUSH);</span><br><span class="line">    <span class="keyword">if</span>((tcsetattr(fd,TCSANOW,&amp;newtio))!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"com set error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"set done!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_port</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> comport)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *dev[]=&#123;<span class="string">"/dev/ttyS0"</span>,<span class="string">"/dev/ttyS1"</span>,<span class="string">"/dev/ttyS2"</span>&#125;;</span><br><span class="line">    <span class="keyword">long</span> vdisable;</span><br><span class="line">    <span class="keyword">if</span> (comport==<span class="number">1</span>)</span><br><span class="line">    &#123;    fd = open( <span class="string">"/dev/ttyS0"</span>, O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == fd)&#123;</span><br><span class="line">            perror(<span class="string">"Can't Open Serial Port"</span>);</span><br><span class="line">            <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"open ttyS0 .....\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(comport==<span class="number">2</span>)</span><br><span class="line">    &#123;    fd = open( <span class="string">"/dev/ttyS1"</span>, O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == fd)&#123;</span><br><span class="line">            perror(<span class="string">"Can't Open Serial Port"</span>);</span><br><span class="line">            <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"open ttyS1 .....\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (comport==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open( <span class="string">"/dev/ttyS2"</span>, O_RDWR|O_NOCTTY|O_NDELAY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == fd)&#123;</span><br><span class="line">            perror(<span class="string">"Can't Open Serial Port"</span>);</span><br><span class="line">            <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"open ttyS2 .....\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fcntl(fd, F_SETFL, <span class="number">0</span>)<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fcntl failed!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fcntl=%d\n"</span>,fcntl(fd, F_SETFL,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span>(isatty(STDIN_FILENO)==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"standard input is not a terminal device\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"isatty success!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd-open=%d\n"</span>,fd);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> nread,i;</span><br><span class="line">    <span class="keyword">char</span> buff[]=<span class="string">"Hello\n"</span>;</span><br><span class="line">    <span class="keyword">if</span>((fd=open_port(fd,<span class="number">1</span>))<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"open_port error"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((i=set_opt(fd,<span class="number">115200</span>,<span class="number">8</span>,<span class="string">'N'</span>,<span class="number">1</span>))<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"set_opt error"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd=%d\n"</span>,fd);</span><br><span class="line"><span class="comment">//    fd=3;</span></span><br><span class="line">    nread=read(fd,buff,<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nread=%d,%s\n"</span>,nread,buff);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> C语言 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是P问题、NP问题和NPC问题</title>
      <link href="/2017/07/15/P%E9%97%AE%E9%A2%98NP%E9%97%AE%E9%A2%98%E5%92%8CNPC%E9%97%AE%E9%A2%98/"/>
      <url>/2017/07/15/P%E9%97%AE%E9%A2%98NP%E9%97%AE%E9%A2%98%E5%92%8CNPC%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/70160796" target="_blank" rel="noopener">点这里</a><br>这或许是众多OIer最大的误区之一。<br>你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是 NPC问题是一个多大的错误。</p><a id="more"></a><p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n^2)的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a^n)的指数级复杂度，甚至O(n!)的阶乘级复杂度。不会存在O(2<em>n^2)的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，O (n^3+n^2)的复杂度也就是O(n^3)的复杂度。因此，我们会说，一个O(0.01</em>n^3)的程序的效率比O(100*n^2)的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n^3)的复杂度将远远超过O(n^2)。我们也说，O(n^100)的复杂度小于O(1.01^n)的复杂度。<br>容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是O(1),O(log(n)),O(n^a)等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p><p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。The Halting Problem就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p><p>下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。<br>接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。<br>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p><p>很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。<br>NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问<br>题，好比物理学中的大统一和数学中的歌德巴赫猜想等。<br>目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p><p>为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。<br>简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。<br> “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。<br>很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。<br>现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。<br>当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p><p>好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p><p>NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。<br>既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p><p>顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><p>不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。<br>下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。<br>逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。<br>什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。<br>  ┌───┐<br>  │ 输入1├─→┐    ┌──┐<br>  └───┘    └─→┤    │<br>                      │ or ├→─┐<br>  ┌───┐    ┌─→┤    │    │    ┌──┐<br>  │ 输入2├─→┤    └──┘    └─→┤    │<br> &amp;<br>nbsp;└───┘    │                ┌─→┤AND ├──→输出<br>                └────────┘┌→┤    │<br>  ┌───┐    ┌──┐            │  └──┘<br>  │ 输入3├─→┤ NOT├─→────┘<br>  └───┘    └──┘<br>这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。<br>有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。<br>  ┌───┐<br>  │输入1 ├→─┐    ┌──┐<br>  └───┘    └─→┤    │<br>                      │AND ├─→┐<br>                ┌─→┤    │    │<br>                │    └──┘    │  ┌──┐<br>                │                └→┤    │<br>  ┌───┐    │                    │AND ├─→输出<br>  │输入2 ├→─┤  ┌──┐      ┌→┤    │<br>  └───┘    └→┤NOT ├→──┘  └──┘<br>                    └──┘<br>上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。<br>回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。<br>逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p><p>有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p><p>出处：<a href="http://www.matrix67.com/blog/archives/105" target="_blank" rel="noopener">http://www.matrix67.com/blog/archives/105</a></p>]]></content>
      
      <categories>
          
          <category> 算法设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计 </tag>
            
            <tag> 我的心得 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>特殊的输入方式</title>
      <link href="/2017/06/10/%E7%89%B9%E6%AE%8A%E7%9A%84%E8%BE%93%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/06/10/%E7%89%B9%E6%AE%8A%E7%9A%84%E8%BE%93%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/62889865" target="_blank" rel="noopener">点这里</a></p><a id="more"></a><p>##1.数据开始和结束的标志为字符型数据<br>通常需要将测试数据中的每行数据以字符形式读入，然后用strcmp函数来判断是否是测试数据开始和结束的标志。</p><p>##2.读入数据时上一行换行符的问题<br>-（C语言为例）<br>–基础<br>(1)scanf()函数输入，printf()函数输出（使用%s控制符）。在读入字符串时以空格，tab键和回车符作为分隔字符串的标志，所以不能读入包含空格的字符串。<br>(2)gets()函数输入。以回车符作为分隔字符串的标志，所以可以读入包含空格的字符串。<br>–问题<br>首先要明白，每行数据末尾都有一个换行符，是否需要用专门的语句跳过上一换行符需要分以下情况：<br>（1）scanf函数（使用%s控制符）：一行一行的读入字符串，它会自动跳过上一行的换行符。<br>（2）scanf函数（使用%c控制符）：一个一个字符的读入字符串，不会跳过上一行的回车键。<br>（3）gets函数：一行一行地读字符串，最初要读入数据的前一行数据末尾的换行符不能跳过，但是要读入数据后面的换行符都会自动跳过。<br>–解决<br>一旦不能自动跳过上一行的换行符，那就需要在读入有用的字符数据前用专门的语句读入上一行的换行符，常用的方法有：<br>（1）getchar()//读入上一行的换行符，不赋值给任何变量<br>（2）c=getchar();//赋值给c，c是一个没有其他用途的临时变量<br>（3）scanf(“%c”,&amp;c)//赋值给c,c是一个没有其他用途的临时变量</p>]]></content>
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 我的心得 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>莱迪思产品ICEstick Evaluation Kit 简介</title>
      <link href="/2017/05/14/%E8%8E%B1%E8%BF%AA%E6%80%9D%E4%BA%A7%E5%93%81/"/>
      <url>/2017/05/14/%E8%8E%B1%E8%BF%AA%E6%80%9D%E4%BA%A7%E5%93%81/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/61930997" target="_blank" rel="noopener">点这里</a></p><p>USB驱动、拇指大小的评估板 —— iCEstick评估套件是一款易于使用、小体积的评估板，通过使用板上莱迪思半导体公司的iCE40 FPGA系列，您可以以极低的成本快速实现系统功能的开发。</p><a id="more"></a><p>##摘自官网##</p><p>IrDA和Digilent PMOD™ 接口 —— 用户可以与一个IrDA收发器进行通信，一个Digilent PMOD™外设连接器可用于许多传感器扩展功能，还有16个通用I/O和LED。</p><p>##产品图片##<br><img src="http://img.blog.csdn.net/20170313205246231?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ICEstick Evaluation Kit 正视图"></p><p>##各部件介绍##<br><img src="http://img.blog.csdn.net/20170313205353408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ICEstick Evaluation Kit 框图"></p><p>###1.FT2232H###<br>FT2232H是USB／RS232双向转换器，支持480 Mb/s的USB 2．0高速规范，提供2个支持USB 2．0高速规范且可配置的并行／串行接口，并且内部集成有USB协议，无须编写USB固件程序。<br>引脚布局如下：<br><img src="http://img.blog.csdn.net/20170313205719380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="FT2232H 引脚布局"></p><p>###2.LDO–LT3030###<br>LT3030是一款具备 1.8V 至 20V 的宽输入电压范围，提供低至 1.215V 和高达 19.5V 的输出电压的低压差稳压器</p><p>###3.93LC56###<br>一款存储芯片。cmos serial eeprom（串行电可擦除只读存储器）<br>框图如下：<br><img src="http://img.blog.csdn.net/20170313211934660?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="93LC56内部电路图"><br>管脚图如下：<br><img src="http://img.blog.csdn.net/20170313212009489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="93LC56管脚图"></p><p>###4.SPI–N25Q32 SPI闪存###<br>  串行闪存是一种尺寸和功耗都很小的采用SPI(串行外设接口)总线的 NOR 闪存芯片. SPI 又叫”四线”串行总线,用于顺序数据缓存器.当被嵌入式系统用于代码或参数存储器时,串行闪存在印制电路板上需要的连线数量比并行闪存少,因为串行闪存是把数据串 行化,所需的输入/输出引脚比较少,每个时钟周期只传送一位数据.这些特性有助于降 低电路板空间,功耗和系统总体成本,这就是串行闪存在嵌入式系统设计社区不断升温的原因.</p><p>常见用途：</p><ol><li>代码存储<br>代码存储分大两大类：<br>1.1. 标准性能:从外部闪存执行代码(XIP)<br>对于没有严格的时间限制的应用，控制器可以直接从串行闪存执行代码，不过存取操作的时间较长。但是，在执行代码时，如果经常出现地址跳转命令，那么最好还是使用能够同时发送地址位和数据位的并行闪存，以改进数据传输时间(&gt;40ns)。并行通信需要的引脚数量多，因此封装尺寸也就相对较大。<br>1.2. <strong><em>高性能:从RAM内存执行代码(代码映射技术)</em></strong><br>很多应用对性能要求很高，因此不能直接从闪存执行代码，只能从存取时间较短的RAM内存执行程序(&gt;5ns)。因为RAM是易失性存储器，这些应用还需要一个非易失性存储器(闪存)在断电时保存代码，每次应用系统上电时还要把代码下载到RAM，这种方法叫做代码映射技术。<br>因为数据从闪存下载到RAM是按照一定顺序的(无地址跳转)，所以从成本和紧凑性考虑，串行闪存是这种应用的最佳解决方案。代码映射技术还能压缩代码，降低对闪存的密度需求。<br>串行闪存产品组合(M25Pxx系列的密度从512Kb到128Mb)，这些产品使很多利用代码映射技术的应用发生了革命性的变化，如硬盘驱动器、显卡、无线网卡、光驱、打印机、计算机(台式机或笔记本电脑的BIOS)、服务器、FPGA配置、液晶显示器、电视、数字电视、机顶盒、汽车收音机、POS机和游戏机等应用领域。无疑，串行外设接口(SPI)产品还将继续渗透到其它的代码映射技术应用领域。<br>2.2.数据存储<br>任何一种特定应用还需要存储器保存数据，例如调整参数、查阅表、历史日志、测量信息等，因为系统上电后立即下载代码，数据可以与代码共用存储器，两者之间不会出现任何冲突。液晶显示器(用户配置)、PC主板(BIOS配置)等应用就属于这种情况。其它应用设备使用专用存储器保存数据，如应答机(语音信息)、测量工具(数值)、医疗设备(记录)、游戏机(用户配置和分数)。因为这些数据不要求很快的读取速度，所以串行闪存仍是最佳的选择。<br>###5.FPGA–ICE40HX1K###<br>属 HX系列超低功耗FPGA系列，在网上找到一个中文文档：<a href="http://www.ic37.com/LATTICE_CN/ICE40HX4K-TQ144_datasheet_12974957/" title="戳这里" target="_blank" rel="noopener">戳这里</a><br>相关英文文档传送门：<br><a href="http://download.csdn.net/detail/idevede/9779921" title="ICE管脚图" target="_blank" rel="noopener">ICE40管脚图</a><br><a href="http://download.csdn.net/detail/idevede/9779925" title="ICE40管脚详解" target="_blank" rel="noopener">ICE40管脚及使用修改版</a><br>###6.PMOD###<br>Pmod接口是将外设与FPGA开发板进行组合和匹配的一种方式。<br>###7.IrDA###<br>使用IrDA协议的红外连接设备。</li></ol><p><img src="http://img.blog.csdn.net/20170313220834203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> FPGA </tag>
            
            <tag> 硬件编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CCF 消除类问题</title>
      <link href="/2017/04/12/CCF_%E6%B6%88%E9%99%A4%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/12/CCF_%E6%B6%88%E9%99%A4%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/61637187" target="_blank" rel="noopener">点这里</a></p><a id="more"></a><p>送分题，用结构体数组实现的，考虑边界问题。我是直接考虑了所有情况，进一步简化代码的时候考虑合并几种情况。<br>问题描述<br>　　消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。<br>　　现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。<br>　　请注意：一个棋子可能在某一行和某一列同时被消除。</p><p>输入格式<br>　　输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。<br>　　接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。<br>输出格式<br>　　输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。</p><p>样例输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">2 2 3 1 2</span><br><span class="line">3 4 5 1 4</span><br><span class="line">2 3 2 1 3</span><br><span class="line">2 2 2 4 4</span><br></pre></td></tr></table></figure></p><p>样例输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2 3 0 2</span><br><span class="line">3 4 5 0 4</span><br><span class="line">2 3 2 0 3</span><br><span class="line">0 0 0 4 4</span><br></pre></td></tr></table></figure></p><p>样例说明<br>　　棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。</p><p>样例输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">2 2 3 1 2</span><br><span class="line">3 1 1 1 1</span><br><span class="line">2 3 2 1 3</span><br><span class="line">2 2 3 3 3</span><br></pre></td></tr></table></figure></p><p>样例输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2 3 0 2</span><br><span class="line">3 0 0 0 0</span><br><span class="line">2 3 2 0 3</span><br><span class="line">2 2 0 0 0</span><br></pre></td></tr></table></figure></p><p>样例说明<br>　　棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。</p><p>评测用例规模与约定<br>　　所有的评测用例满足：1 ≤ n, m ≤ 30。</p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct xiaochu</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    int flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct xiaochu xiaochu1;</span><br><span class="line">xiaochu1 xiaochu[31][31];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    int i,j;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for( i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for( j=0;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;xiaochu[i][j].value;</span><br><span class="line">            xiaochu[i][j].flag=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n&gt;=3)</span><br><span class="line">    &#123;</span><br><span class="line">        if(m&gt;=3)</span><br><span class="line">        &#123;</span><br><span class="line">            for(i=0;i&lt;n;i++)//对每一行来说看列</span><br><span class="line">            &#123;</span><br><span class="line">                for(j=0;j&lt;m-2;j++)</span><br><span class="line">                    if(xiaochu[i][j].value==xiaochu[i][j+1].value&amp;&amp;xiaochu[i][j].value==xiaochu[i][j+2].value)</span><br><span class="line">                &#123;</span><br><span class="line">                    xiaochu[i][j].flag=1;xiaochu[i][j+1].flag=1;xiaochu[i][j+2].flag=1;</span><br><span class="line">                    int count=3;</span><br><span class="line">                    while(j+count&lt;m)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if(xiaochu[i][j].value==xiaochu[i][j+count].flag)</span><br><span class="line">                        &#123;</span><br><span class="line">                             xiaochu[i][j+count].flag=1;</span><br><span class="line">                             count++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        else</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            for(j=0;j&lt;m;j++)//对每一列来说看行</span><br><span class="line">            &#123;</span><br><span class="line">                for(i=0;i&lt;n-2;i++)</span><br><span class="line">                    if(xiaochu[i][j].value==xiaochu[i+1][j].value&amp;&amp;xiaochu[i][j].value==xiaochu[i+2][j].value)</span><br><span class="line">                &#123;</span><br><span class="line">                    xiaochu[i][j].flag=1;xiaochu[i+1][j].flag=1;xiaochu[i+2][j].flag=1;</span><br><span class="line">                    int count=3;</span><br><span class="line">                    while(i+count&lt;n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if(xiaochu[i][j].value==xiaochu[i+count][j].flag)</span><br><span class="line">                        &#123;</span><br><span class="line">                             xiaochu[i+count][j].flag=1;</span><br><span class="line">                             count++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        else</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else if(m&gt;=3)//行数小于3，只需要看列数</span><br><span class="line">    &#123;</span><br><span class="line">         for(i=0;i&lt;n;i++)//对每一行来说看列</span><br><span class="line">            &#123;</span><br><span class="line">                for(j=0;j&lt;m-2;j++)</span><br><span class="line">                    if(xiaochu[i][j].value==xiaochu[i][j+1].value&amp;&amp;xiaochu[i][j].value==xiaochu[i][j+2].value)</span><br><span class="line">                &#123;</span><br><span class="line">                    xiaochu[i][j].flag=1;xiaochu[i][j+1].flag=1;xiaochu[i][j+2].flag=1;</span><br><span class="line">                    int count=3;</span><br><span class="line">                    while(j+count&lt;m)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if(xiaochu[i][j].value==xiaochu[i][j+count].flag)</span><br><span class="line">                        &#123;</span><br><span class="line">                             xiaochu[i][j+count].flag=1;</span><br><span class="line">                             count++;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        else</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(xiaochu[i][j].flag==1)</span><br><span class="line">                xiaochu[i][j].value=0;</span><br><span class="line">            cout &lt;&lt; xiaochu[i][j].value&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i!=n-1)</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法设计 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单源最短路径-Dijkstra算法</title>
      <link href="/2017/03/06/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84_Dijkstra%E7%AE%97%E6%B3%95/"/>
      <url>/2017/03/06/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84_Dijkstra%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/60572715" target="_blank" rel="noopener">点这里</a></p><p>迪杰斯特拉算法解决的事带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。他在运行过程中维护的关键信息是一组节点集合S。算法重复从节点集V-S中选择最短路径估计最小的节点u，将u加入到集合S中，然后对所有从u发出的边进行松弛。</p><p>我们使用最小优先队列Q来保存节点集合，每个节点的关键值为其d值</p><a id="more"></a><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>G={V,E}</p><ol><li>初始时令 S={V0},T=V-S={其余顶点}，T中顶点对应的距离值<br>若存在\&lt;V0,Vi&gt;，d(V0,Vi)为\&lt;V0,Vi&gt;弧上的权值<br>若不存在\&lt;V0,Vi&gt;，d(V0,Vi)为∞</li><li>在（T）未确定的点中选取当前以得的最短路径（与S中顶点有关联边且权值最小）</li><li>对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值<br>4.重复上述步骤2、3，直到S中包含所有顶点，即W=Vi为止</li></ol><p>##　算法举例</p><p><img src="http://images2015.cnblogs.com/blog/1046690/201612/1046690-20161214112603339-1886806307.jpg" alt=""><br><img src="http://images2015.cnblogs.com/blog/1046690/201612/1046690-20161214112617448-1703879788.jpg" alt=""></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;    </span><br><span class="line">#include &quot;stdlib.h&quot;   </span><br><span class="line">#include &quot;io.h&quot;  </span><br><span class="line">#include &quot;math.h&quot;  </span><br><span class="line">#include &quot;time.h&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#define MAXEDGE 20</span><br><span class="line">#define MAXVEX 20</span><br><span class="line">#define INFINITY 65535</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */ </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int vexs[MAXVEX];</span><br><span class="line">int arc[MAXVEX][MAXVEX];</span><br><span class="line">int numVertexes, numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">typedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */</span><br><span class="line">typedef int ShortPathTable[MAXVEX];/* 用于存储到各点最短路径的权值和 */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* 构件图 */</span><br><span class="line">void CreateMGraph(MGraph *G)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* printf(&quot;请输入边数和顶点数:&quot;); */</span><br><span class="line">G-&gt;numEdges=16;</span><br><span class="line">G-&gt;numVertexes=9;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;vexs[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</span><br><span class="line">&#123;</span><br><span class="line">for ( j = 0; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (i==j)</span><br><span class="line">G-&gt;arc[i][j]=0;</span><br><span class="line">else</span><br><span class="line">G-&gt;arc[i][j] = G-&gt;arc[j][i] = INFINITY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">G-&gt;arc[0][1]=1;</span><br><span class="line">G-&gt;arc[0][2]=5; </span><br><span class="line">G-&gt;arc[1][2]=3; </span><br><span class="line">G-&gt;arc[1][3]=7; </span><br><span class="line">G-&gt;arc[1][4]=5; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">G-&gt;arc[2][4]=1; </span><br><span class="line">G-&gt;arc[2][5]=7; </span><br><span class="line">G-&gt;arc[3][4]=2; </span><br><span class="line">G-&gt;arc[3][6]=3; </span><br><span class="line">G-&gt;arc[4][5]=3;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">G-&gt;arc[4][6]=6;</span><br><span class="line">G-&gt;arc[4][7]=9; </span><br><span class="line">G-&gt;arc[5][7]=5; </span><br><span class="line">G-&gt;arc[6][7]=2; </span><br><span class="line">G-&gt;arc[6][8]=7;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">G-&gt;arc[7][8]=4;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">for(i = 0; i &lt; G-&gt;numVertexes; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(j = i; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;arc[j][i] =G-&gt;arc[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    </span><br><span class="line">/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  </span><br><span class="line">void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)</span><br><span class="line">&#123;    </span><br><span class="line">int v,w,k,min;    </span><br><span class="line">int final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */</span><br><span class="line">for(v=0; v&lt;G.numVertexes; v++)    /* 初始化数据 */</span><br><span class="line">&#123;        </span><br><span class="line">final[v] = 0;/* 全部顶点初始化为未知最短路径状态 */</span><br><span class="line">(*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */</span><br><span class="line">(*P)[v] = -1;/* 初始化路径数组P为-1  */       </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">(*D)[v0] = 0;  /* v0至v0路径为0 */  </span><br><span class="line">final[v0] = 1;    /* v0至v0不需要求路径 */        </span><br><span class="line">/* 开始主循环，每次求得v0到某个v顶点的最短路径 */   </span><br><span class="line">for(v=1; v&lt;G.numVertexes; v++)   </span><br><span class="line">&#123;</span><br><span class="line">min=INFINITY;    /* 当前所知离v0顶点的最近距离 */        </span><br><span class="line">for(w=0; w&lt;G.numVertexes; w++) /* 寻找离v0最近的顶点 */    </span><br><span class="line">&#123;            </span><br><span class="line">if(!final[w] &amp;&amp; (*D)[w]&lt;min)             </span><br><span class="line">&#123;                   </span><br><span class="line">k=w;                    </span><br><span class="line">min = (*D)[w];    /* w顶点离v0顶点更近 */            </span><br><span class="line">&#125;        </span><br><span class="line">&#125;        </span><br><span class="line">final[k] = 1;    /* 将目前找到的最近的顶点置为1 */</span><br><span class="line">for(w=0; w&lt;G.numVertexes; w++) /* 修正当前最短路径及距离 */</span><br><span class="line">&#123;</span><br><span class="line">/* 如果经过v顶点的路径比现在这条路径的长度短的话 */</span><br><span class="line">if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[w]))   </span><br><span class="line">&#123; /*  说明找到了更短的路径，修改D[w]和P[w] */</span><br><span class="line">(*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */               </span><br><span class="line">(*P)[w]=k;        </span><br><span class="line">&#125;       </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;   </span><br><span class="line">int i,j,v0;</span><br><span class="line">MGraph G;    </span><br><span class="line">Patharc P;    </span><br><span class="line">ShortPathTable D; /* 求某点到其余各点的最短路径 */   </span><br><span class="line">v0=0;</span><br><span class="line"></span><br><span class="line">CreateMGraph(&amp;G);</span><br><span class="line"></span><br><span class="line">ShortestPath_Dijkstra(G, v0, &amp;P, &amp;D);  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">printf(&quot;最短路径倒序如下:\n&quot;);    </span><br><span class="line">for(i=1;i&lt;G.numVertexes;++i)   </span><br><span class="line">&#123;       </span><br><span class="line">printf(&quot;v%d - v%d : &quot;,v0,i);</span><br><span class="line">j=i;</span><br><span class="line">while(P[j]!=-1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,P[j]);</span><br><span class="line">j=P[j];</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;    </span><br><span class="line">printf(&quot;\n源点到各顶点的最短路径长度为:\n&quot;);  </span><br><span class="line">for(i=1;i&lt;G.numVertexes;++i)        </span><br><span class="line">printf(&quot;v%d - v%d : %d \n&quot;,G.vexs[0],G.vexs[i],D[i]);     </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法设计 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POJ题单及算法训练练习顺序</title>
      <link href="/2017/02/28/POJ/"/>
      <url>/2017/02/28/POJ/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/58601807" target="_blank" rel="noopener">点这里</a></p><p>逛论坛时下面的回复，扒下来自己看的，具体出处也是不祥，总之慢慢学习咯~</p><a id="more"></a><p>初期:</p><p>一.基本算法:<br>     (1)枚举. (poj1753,poj2965)<br>     (2)贪心(poj1328,poj2109,poj2586)<br>     (3)递归和分治法.<br>     (4)递推.<br>     (5)构造法.(poj3295)<br>     (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)<br>二.图算法:<br>     (1)图的深度优先遍历和广度优先遍历.<br>     (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)<br>        (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)<br>     (3)最小生成树算法(prim,kruskal)<br>        (poj1789,poj2485,poj1258,poj3026)<br>     (4)拓扑排序 (poj1094)<br>     (5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)<br>     (6)最大流的增广路算法(KM算法). (poj1459,poj3436)<br>三.数据结构.<br>     (1)串 (poj1035,poj3080,poj1936)<br>     (2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)<br>     (3)简单并查集的应用.<br>     (4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)<br>        (poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)<br>     (5)哈夫曼树(poj3253)<br>     (6)堆<br>     (7)trie树(静态建树、动态建树) (poj2513)<br>四.简单搜索<br>     (1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)<br>     (2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)<br>     (3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)<br>五.动态规划<br>     (1)背包问题. (poj1837,poj1276)<br>     (2)型如下表的简单DP(可参考lrj的书 page149):<br>       1.E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)<br>       2.E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)<br>         (poj3176,poj1080,poj1159)<br>       3.C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)<br>六.数学<br>     (1)组合数学:<br>        1.加法原理和乘法原理.<br>        2.排列组合.<br>        3.递推关系.<br>          (POJ3252,poj1850,poj1019,poj1942)<br>     (2)数论.<br>        1.素数与整除问题<br>        2.进制位.<br>        3.同余模运算.<br>          (poj2635, poj3292,poj1845,poj2115)<br>     (3)计算方法.<br>        1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)<br>七.计算几何学.<br>     (1)几何公式.<br>     (2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)<br>     (3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)<br>         (poj1408,poj1584)<br>     (4)凸包. (poj2187,poj1113)</p><p>中级:<br>一.基本算法:<br>     (1)C++的标准模版库的应用. (poj3096,poj3007)<br>     (2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)<br>二.图算法:<br>     (1)差分约束系统的建立和求解. (poj1201,poj2983)<br>     (2)最小费用最大流(poj2516,poj2516,poj2195)<br>     (3)双连通分量(poj2942)<br>     (4)强连通分支及其缩点.(poj2186)<br>     (5)图的割边和割点(poj3352)<br>     (6)最小割模型、网络流规约(poj3308, )<br>三.数据结构.<br>     (1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)<br>     (2)静态二叉检索树. (poj2482,poj2352)<br>     (3)树状树组(poj1195,poj3321)<br>     (4)RMQ. (poj3264,poj3368)<br>     (5)并查集的高级应用. (poj1703,2492)<br>     (6)KMP算法. (poj1961,poj2406)<br>四.搜索<br>     (1)最优化剪枝和可行性剪枝<br>     (2)搜索的技巧和优化 (poj3411,poj1724)<br>     (3)记忆化搜索(poj3373,poj1691)</p><p>五.动态规划<br>     (1)较为复杂的动态规划(如动态规划解特别的施行商问题等)<br>         (poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)<br>     (2)记录状态的动态规划. (POJ3254,poj2411,poj1185)<br>     (3)树型动态规划(poj2057,poj1947,poj2486,poj3140)<br>六.数学<br>     (1)组合数学:<br>        1.容斥原理.<br>        2.抽屉原理.<br>        3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).<br>        4.递推关系和母函数.</p><pre><code>(2)数学.   1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)   2.概率问题. (poj3071,poj3440)   3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)(3)计算方法.   1.0/1分数规划. (poj2976)   2.三分法求解单峰(单谷)的极值.   3.矩阵法(poj3150,poj3422,poj3070)   4.迭代逼近(poj3301)(4)随机化算法(poj3318,poj2454)(5)杂题.    (poj1870,poj3296,poj3286,poj1095)</code></pre><p>七.计算几何学.<br>        (1)坐标离散化.<br>        (2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).<br>            (poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)<br>        (3)多边形的内核(半平面交)(poj3130,poj3335)<br>        (4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)</p><p>高级:<br>一.基本算法要求:<br>      (1)代码快速写成,精简但不失风格<br>          (poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)<br>      (2)保证正确性和高效性. poj3434<br>二.图算法:<br>      (1)度限制最小生成树和第K最短路. (poj1639)<br>      (2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)<br>         (poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446<br>      (3)最优比率生成树. (poj2728)<br>      (4)最小树形图(poj3164)<br>      (5)次小生成树.<br>      (6)无向图、有向图的最小环<br>三.数据结构.<br>      (1)trie图的建立和应用. (poj2778)<br>      (2)LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法<br>          (RMQ+dfs)).(poj1330)<br>      (3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的<br>          目的). (poj2823)<br>      (4)左偏树(可合并堆).<br>      (5)后缀树(非常有用的数据结构,也是赛区考题的热点).<br>         (poj3415,poj3294)<br>四.搜索<br>      (1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)<br>      (2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A<em>算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)<br>      (3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA</em>算法. (poj3131,poj2870,poj2286)<br>五.动态规划<br>      (1)需要用数据结构优化的动态规划.<br>         (poj2754,poj3378,poj3017)<br>      (2)四边形不等式理论.<br>      (3)较难的状态DP(poj3133)<br>六.数学<br>      (1)组合数学.<br>        1.MoBius反演(poj2888,poj2154)<br>        2.偏序关系理论.<br>      (2)博奕论.<br>        1.极大极小过程(poj3317,poj1085)<br>        2.Nim问题.<br>七.计算几何学.<br>      (1)半平面求交(poj3384,poj2540)<br>      (2)可视图的建立(poj2966)<br>      (3)点集最小圆覆盖.<br>      (4)对踵点(poj2079)<br>      八.综合题.<br>      (poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263)</p><hr><hr><p>以及补充<br>Dp状态设计与方程总结</p><p>1.不完全状态记录</p><p><1>青蛙过河问题</1></p><p><2>利用区间dp<br>2.背包类问题</2></p><p><1> 0-1背包，经典问题</1></p><p><2>无限背包，经典问题</2></p><p><3>判定性背包问题</3></p><p><4>带附属关系的背包问题</4></p><p><5> + -1背包问题</5></p><p><6>双背包求最优值</6></p><p><7>构造三角形问题</7></p><p><8>带上下界限制的背包问题(012背包)<br>3.线性的动态规划问题</8></p><p><1>积木游戏问题</1></p><p><2>决斗（判定性问题）</2></p><p><3>圆的最大多边形问题</3></p><p><4>统计单词个数问题</4></p><p><5>棋盘分割</5></p><p><6>日程安排问题</6></p><p><7>最小逼近问题(求出两数之比最接近某数/两数之和等于某数等等)</7></p><p><8>方块消除游戏(某区间可以连续消去求最大效益)</8></p><p><9>资源分配问题</9></p><p><10>数字三角形问题</10></p><p><11>漂亮的打印</11></p><p><12>邮局问题与构造答案</12></p><p><13>最高积木问题</13></p><p><14>两段连续和最大</14></p><p><15>2次幂和问题</15></p><p><16>N个数的最大M段子段和</16></p><p><17>交叉最大数问题<br>4.判定性问题的dp(如判定整除、判定可达性等)   </17></p><p><1>模K问题的dp</1></p><p><2>特殊的模K问题，求最大(最小)模K的数</2></p><p><3>变换数问题<br>5.单调性优化的动态规划</3></p><p><1>1-SUM问题</1></p><p><2>2-SUM问题</2></p><p><3>序列划分问题(单调队列优化)<br>6.剖分问题(多边形剖分/石子合并/圆的剖分/乘积最大)</3></p><p><1>凸多边形的三角剖分问题</1></p><p><2>乘积最大问题</2></p><p><3>多边形游戏(多边形边上是操作符,顶点有权值)</3></p><p><4>石子合并(N^3/N^2/NLogN各种优化)<br>7.贪心的动态规划</4></p><p><1>最优装载问题</1></p><p><2>部分背包问题</2></p><p><3>乘船问题</3></p><p><4>贪心策略</4></p><p><5>双机调度问题Johnson算法<br>8.状态dp</5></p><p><1>牛仔射击问题(博弈类)</1></p><p><2>哈密顿路径的状态dp</2></p><p><3>两支点天平平衡问题</3></p><p><4>一个有向图的最接近二部图<br>9.树型dp</4></p><p><1>完美服务器问题(每个节点有3种状态)</1></p><p><2>小胖守皇宫问题</2></p><p><3>网络收费问题</3></p><p><4>树中漫游问题</4></p><p><5>树上的博弈</5></p><p><6>树的最大独立集问题</6></p><p><7>树的最大平衡值问题</7></p><p><8>构造树的最小环</8></p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>太用力的人跑不远</title>
      <link href="/2017/02/26/%E5%A4%AA%E7%94%A8%E5%8A%9B%E7%9A%84%E4%BA%BA%E8%B7%91%E4%B8%8D%E8%BF%9C/"/>
      <url>/2017/02/26/%E5%A4%AA%E7%94%A8%E5%8A%9B%E7%9A%84%E4%BA%BA%E8%B7%91%E4%B8%8D%E8%BF%9C/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/57079919" target="_blank" rel="noopener">点这里</a></p><p>写在最前面</p><p>上午还在低气压来着，突然看到这篇文章，有点茅塞顿开的感觉，自己太在意这条路上的一些东西了，反倒整天紧张做不好自己原本应该做的本职工作。对未来忧心忡忡没有用，再担心该来的还是会来的，只要做好自己手下的本职工作，努力向前，以后发生的，以后再说好了。</p><a id="more"></a><p>写在前面</p><p>有阶段的自己，会用蛮力去学习一些东西，就是这东西不管是否适合目前自己的知识体系， 觉得学了之后会更牛逼就去学，但是这样的东西往往学了记不住。 学习的过程越用力反而显得越吃力， 太吃力的事情，自然就无法有恒心， 这就是很多人会觉得自己做事总是无法持之以恒的原因。</p><p>努力不应该是某种需要被时常觉知的东西，意志力是短期内会用完的精神能量。<br>真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p><p>太用力的人更容易产生期望落差，更不愿接受自己找错了方向的事实——没有什么比这样的“失落”更能让人心寒的了，太用力的人大多都因心累而倒在了半途中。</p><p>精神上的用力并不会让你跑得更快，但是精神上的疲惫却可以让你停下。</p><p>人越用力，就会越想要得到及时的良好刺激。越用力的人对于正刺激的需求就越高，越不能忍受暂时的负反馈。遗憾的是，人生常常是没有下文的考卷，这种刺激来得太慢、太不稳定。</p><p>真正的坚持归于平静，靠的是温和的发力，而不是时时刻刻的刺激。</p><p>太用力的人增加了执行的功耗。纠结，是太用力的一种表现，造成内部的运转处于空转的状态——意识与行动的主观脱节；从心所欲，就是把运转效率最大化后的结果——所想即所为。执行阶段最大的敌人，是纠结，是埋怨，是内心的冲突——太用力，就是心理额外动作太多。想好之后就只管去做。</p><p>我一直告诫自己不要用力过猛，以保持自己对困难的顿感和不顺的接受程度。<br>短期的过度用力极容易造成身体和心理上的挫伤。哪怕你在做的事情非常重要，也要保证基本的休息和放松。</p><p>不论是以后的工作还是将来的创业，都要保持一颗平常心。你需要更多的“寸劲”而不是“用力感”。在找到受力点“all in”之前，一切都要顺势而行，自然随和。</p><p>人在学习的过程会经历一系列的过程，先是笨拙期，再是熟练期——这两个过程他虽然能运用出技能，但是头脑中仍然能感受到使用时的提取感。这两个阶段都需要用力，但是用力的程度却大幅度减小。</p><p>技能掌握的最后阶段是运用自如期，就是张三丰把太极拳的形态全部都忘了的阶段。这个时候头脑中已经能下意识地去进行活动，达到了能耗最低的理想阶段。</p><p>从用力感，到毫无感觉，是一种技能掌握上的纯熟。年轻的时候太认真是件好事，或许只有用力过了，才能体会从心所欲、顺其自然的难得。</p><p>IT人员怎么用力<br>总有在校的学生问我现在 X,Y,Z… 技术很火热，应该学哪个？ 我看他列出的那些准备学习的选项中，其实前景和热门程度都差不多。 这让他陷入了选择焦虑症，不管做什么决定都怕「一失足成千古恨」。</p><p>对技术发展趋势关心是好事，就像之前那篇「不要总是选择困难模式」里面说的那样。 但是其实在「不要总是选择困难模式」里面忽略了很重要的一点，就是你个人的兴趣。 比如有的人对苹果的东西有天生的热爱，所以选择「iOS开发」对他来说就更容易做好。 尽可能选择会让自己 Enjoy 的技术方向，路还很长，不享受过程的话容易半途而废。</p><p>太用力的人跑不远<br>记得之前本科的时候喜欢和舍友一起打Dota，打Dota开局之前一般要等人齐， 等人的这段时间我有时候会切出来写写代码，叫舍友开局了告诉我一声。 然后别人看到我在打Dota间隙都在写代码，就觉得我有多努力多努力，给人了一种非常「刻苦」的印象。 以至于上次和一个本科同学吃饭他还说起这个事情，觉得我能做到这样非常「牛逼」。</p><p>但是其实这样的事情，如果对于真的对写代码有经历过热爱的人，是不会觉得有多么刻苦的事情。 这是自然而然的事情，甚至其实有些代码，那种满足好奇心的快感，是比打游戏有意思的多， 是件很Enjoy的事情，而不是所谓的「刻苦」。</p><p>就像跑步，「太用力的人跑不远」。</p><p>不要用蛮力去学编程<br>记得当年初学 C++ 的同学，听别人说 C++ 很基础也很重要的一个知识点就是STL， 然后听说要学好 STL 就应该去看看侯捷的「STL源码剖析」。 然后就买了书硬啃，然后没啃几天就放弃了，觉得太讳莫如深了没法理解。</p><p>但是如果换个学习的方式， 先假设现在没有STL这个标准库， 让你用已有的C++语法知识去自己写一个仿造STL标准库的功能， 哪怕是最最简单的 vector 。 你在编写的时候就会自然而然得体会到内存动态扩展的一些缺点和潜在的坑。 会知道为什么适当使用 reserve 和 swap 能非常明显的提高性能。</p><p>然后在自己思考的过程中会提出很多相关的疑惑， 带着疑惑再去翻看「STL源码剖析」， 就会让你对一个个数据结构恍然大悟知根知底。 自然而然你的看书体验会非常的 Enjoy， 而不是觉得苦涩难咽。</p><p>编程和求知本身是一件愉悦身心的事情， 如果只是为了高薪，而用蛮力去写代码，只会让自己疲惫不堪。</p><p>最后<br>希望对在学习编程的路上很挣扎的朋友有所帮助。 毕竟工作是生活的很大一部分， 如果工作不开心，生活怎么办。</p>]]></content>
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的心得 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UART的基础知识及使用</title>
      <link href="/2017/02/25/UART%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/02/25/UART%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/57075138" target="_blank" rel="noopener">点这里</a></p><p>S3C2410内部具有3个独立的UART控制器，每个控制器都可以工作在Interrupt（中断）模式或DMA（直接内存访问）模式，也就是说UART控制器可以在CPU与UART控制器传送数据的时候产生中断或DMA请求。并且每个UART控制器均具有16字节的FIFO（先入先出寄存器），支持的最高波特率可达到115.2Kbps<br><a id="more"></a></p><ul><li><strong>S3C2410内置的UART控制器</strong></li></ul><p>下图是S3C2410内部UART控制器的结构图<br><img src="http://www.ec66.com/article/pic/2006727050275365.gif" alt=""><br>通过上图我们可以看到，每个UART控制器中大抵分为发送器和接收器两部分，在发送器中如果当前UART处于FIFO模式，则有16B的发送缓冲寄存器，一般在发送数据时CPU会将数据先暂存到这16B中来，如果当前UART处于非FIFO模式，则这16B的缓冲寄存器是没用的，我们只用到了这16B中最低一个字节的缓冲寄存器来存放数据也叫做Transmit Holding Register，而关键的一点是在发送器中发送缓冲器中的数据并不是直接送到输出引脚上的，还必须要先送到发送移位寄存器也就是Transmit Shifter，然后再由Transmit Shifter送出到输出引脚。而接收端这边大概都是一样，发送移位寄存器和接收移位寄存器对数据的发送和接收都是在波特率发生器产生的波特率下来进行控制的。而波特率的产生也需要在时钟源的控制下才行</p><ul><li><strong>UART的操作</strong><br>UART的操作分为以下几个部分分别是数据发送、数据接收、产生中断、产生波特率、Loopback模式、红外模式以及自动流控模式。<br><em>数据发送：</em><br>发送的数据帧格式是可以编程设置的。它包含了起始位、5~8个数据位、可选的奇偶校验位以及1~2位停止位。这些都是通过UART的控制寄存器 ULCONn 来设置的。<br><em>数据接收：</em><br>同发送一样，接收的数据帧格式也是可以进行编程设置的。此外，还具备了检测溢出出错、奇偶校验出错、帧出错等出错检测，并且每种错误都可以设置相应的错误标志。<br><em>自动流控模式：</em><br>S3C2410的UART0和UART1都可以通过各自的nRTS和nCTS信号来实现自动流控。在自动流控（AFC）模式下nRTS取决于接收端的状态，而nCTS控制了发送端的操作。具体地说：只有当nCTS有效时（表明接收方的FIFO已经准备就绪来接收数据了因为接收端的nRTS是和发送端的nCTS连接的nCTS有效也就表示接收端的nRTS有效也就表示接收方的FIFO已经准备好接收数据啦），UART才会将FIFO中的数据发送出去。在UART接收资料之前，只要当接收FIFO有至少2-byte空余的时候，nRTS就会被置为有效。下图是UART自动流控模式的连接方式<br><img src="http://www.ec66.com/article/pic/20067270501724033.gif" alt=""></li></ul><p><em>中断/DMA请求产生</em><br>S3C2410的每个UART都有7种状态，分别是：溢出覆盖（Overrun）错误、奇偶校验错误、帧出错、断线错误(暂停态)、接收就绪(接收缓冲区准备好)、发送缓冲空闲、发送移位器空闲。它们在UART状态寄存器 UTRSTATn / UERSTATn 中有相应的标志位。<br><em>波特率发生器</em><br>每个UART控制器都有各自的波特率发生器来产生发送和接收资料所用的序列时钟，波特率发生器的时钟源可以由CPU内部的系统时钟(PCLK)，也可以从CPU的 UCLK (外部UART设备的时钟)管脚由外部取得时钟信号，并且可以通过 UCONn 选择各自的时钟源。<br>波特率产生的具体计算方法如下：<br>当选择CPU内部时钟(PCLK)时：<br>UBRDIVn=(int)(PCLK/(bps<em>16))-1,bps为所需要的波特率值，PCLK为CPU内部外设总线（APB）的工作时钟。<br>当需要得到更精确的波特率时，可以选择由 UCLK 引入的外部时钟来生成。<br>UBRDIVn=(int)(UCLK/(bps</em>16))-1<br><em>LoopBack操作模式：</em><br>S3C2410 CPU的UART提供了一种测试模式，也就是这里所说的LoopBack模式。在设计系统的具体应用时，为了判断通讯故障是由于外部的数据链路上的问题，还是CPU内驱动程序或CPU本身的问题，这就需要采用LoopBack模式来进行测试。在LoopBack模式中，资料发送端TXD在UART内部就从逻辑上与接收端RXD连在一起，并可以来验证资料的收发是否正常。<br><em>UART控制寄存器</em><br>下面将针对UART的各个控制寄存器逐一进行讲解，以期对UART的操作和设置能有更进一步的了解。<br>ULCONn （UART Line Control Register）<br><img src="http://www.ec66.com/article/pic/20067270503237451.gif" alt=""></p><p>Word Length ：决定每帧的数据位数<br>Number of Stop Bit ：停止位数<br>Parity Mode ：奇偶校验位类型<br>Infra-Red Mode ：UART/红外模式选择（当以UART模式工作时，需设为“0”）<br>UCONn （UART Control Register）见图5-14<br>Receive Mode ：选择接收模式。如果是采用DMA模式的话，还需要指定说使用的DMA信道。<br>Transmit Mode ：同上。<br>Send Break Signal ：选择是否在传送一帧数据中途发送Break信号。<br>Loopback Mode ：选择是否将UART置于Loopback测试模式。<br>Rx Error Status Interrupt Enable ：选择是否使能当发生接收异常时，是否产生接收错误中断。<br>Rx Time Out Enable ：是否使能接收超时中断。<br>Rx Interrupt Type ：选择接收中断类型。<br>选择0：Pulse（脉冲式/边沿式中断。非FIFO模式时，一旦接收缓冲区中有资料，即产生一个中断；为FIFO模式时，一旦当FIFO中的资料达到一定的触发水平后，即产生一个中断）</p><p>选择1：Level（电平模式中断。非FIFO模式时，只要接收缓冲区中有资料，即产生中断；为FIFO模式时，只要FIFO中的资料达到触发水平后，即产生中断）<br>Tx Interrupt Type ：类同于Rx Interrupt Type<br>Clock Selection ：选择UART波特率发生器的时钟源。<br><img src="http://www.ec66.com/article/pic/20067270505261993.gif" alt=""></p><p>UFCONn （UART FIFO Conrtol Register）用于对收发缓冲的管理，包括缓冲的触发字节数的设置，FIFO的使能见下图<br>FIFO Enable ：FIFO使能选择。<br>Rx FIFO Reset ：选择当复位接收FIFO时是否自动清除FIFO中的内容。<br>Tx FIFO Reset ：选择当复位发送FIFO时是否自动清除FIFO中的内容。<br>Rx FIFO Trigger Level ：选择接收FIFO的触发水平。<br>Tx FIFO Trigger Level ：选择发送FIFO的触发水平。<br><img src="http://www.ec66.com/article/pic/2006727051811787.gif" alt=""><br>UMCONn （UART Modem Control Register）见下图<br>Request to Send ：如果在AFC模式下，该位将由UART控制器自动设置；否则的话就必须由用户的软件来控制。<br>Auto Flow Control ：选择是否使能自动流控（AFC）。<br><img src="http://www.ec66.com/article/pic/20067270512368317.gif" alt=""><br>UTRSTATn （UART TX/RX Status Register）见图<br>Receive buffer data ready :当接收缓冲寄存器从UART接收端口接收到有效资料时将自动置“1”。反之为“0”则表示缓冲器中没有资料。<br>Transmit buffer empty ：当发送缓冲寄存器中为空，自动置“1”；反之表明缓冲器中正有资料等待发送。<br>Transmitter empty ：当发送缓冲器中已经没有有效资料时，自动置“1”；反之表明尚有资料未发送。<br><img src="http://www.ec66.com/article/pic/20067270513773946.gif" alt=""><br>UERSTATn （UART Error Status Register）见图<br>Overrun Error ：为“1”，表明发生Overrun错误。<br>Frame Error ：为“1”。表明发生Frame（帧）错误。<br><img src="http://www.ec66.com/article/pic/20067270514940468.gif" alt=""><br>UFSTATn　：（UART　FIFO Status Register）见图<br>Rx FIFO Count :接收FIFO中当前存放的字节数。<br>　Tx FIFO Count :发送FIFO中当前存放的字节数。<br>　Rx FIFO Full :为“1“表明接收FIFO已满。<br>　Tx FIFO Full :为“1“表明发送FIFO已满。<br> <img src="http://www.ec66.com/article/pic/2006727052233073.gif" alt=""><br> UMSTATn　：（UART　FIFO Status Register）见图<br>Clear to Send ：为“0”表示CTS无效；为“1”表示CTS有效。<br>Delta CTS ：指示自从上次CPU访问该位后，nCTS的状态有无发生改变。<br>为“0”则说明不曾改变；反之表明nCTS信号已经变化了。<br><img src="http://www.ec66.com/article/pic/20067270521514532.gif" alt=""><br>UTXHn 和 URXHn 分别是UART发送和接收资料寄存器<br>这两个寄存器存放着发送和接收的资料，当然只有一个字节８位资料。需要注意的是在发生溢出错误的时候，接收的资料必须要被读出来，否则会引发下次溢出错误</p><p>UBRDIVn ：（UART Baud Rate Divisor Register）见图<br><img src="http://www.ec66.com/article/pic/20067270522964203.gif" alt=""></p><p>接着我们通过结合代码来看看具体在程序中怎样来操作UART的流程：</p><p>先来看看在C代码中对用到的UART多个寄存器的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#define UART_CTL_BASE 0x50000000  //UART0的寄存器的起始地址也就是ULCON0的地址</span><br><span class="line">#define UART0_CTL_BASE UART_CTL_BASE</span><br><span class="line">#define bUART(x, Nb) __REGl(UART_CTL_BASE + (x)*0x4000 + (Nb))  //因为考虑到UART1与UART0相应的寄存器地址相差0x4000所以这里也考虑到了对UART1和UART2的使用，而上面__REGl的定义：</span><br><span class="line"></span><br><span class="line">#define __REG(x) (*(volatile unsigned long *)(x))</span><br><span class="line">#define __REGl(x) __REG(x)</span><br><span class="line">#define bUARTb(x, Nb) __REGb(UART_CTL_BASE + (x)*0x4000 + (Nb)) //#define __REGb(x) (*(volatile unsigned char *)(x))</span><br><span class="line">/* offset */</span><br><span class="line">#define oULCON  0x00</span><br><span class="line">#define oUCON  0x04</span><br><span class="line">#define oUFCON  0x08</span><br><span class="line">#define oUMCON  0x0c</span><br><span class="line">#define oUTRSTAT 0x10</span><br><span class="line">#define oUERSTAT 0x14</span><br><span class="line">#define oUFSTAT  0x18</span><br><span class="line">#define oUMSTAT  0x1c</span><br><span class="line">#define oUTXHL  0x20</span><br><span class="line">#define oUTXHB  0x23</span><br><span class="line">#define oURXHL  0x24</span><br><span class="line">#define oURXHB  0x27</span><br><span class="line">#define oUBRDIV  0x28</span><br><span class="line">/* Registers */</span><br><span class="line">#define ULCON0  bUART(0, oULCON)</span><br><span class="line">#define UCON0  bUART(0, oUCON)</span><br><span class="line">#define UFCON0  bUART(0, oUFCON)</span><br><span class="line">#define UMCON0  bUART(0, oUMCON)</span><br><span class="line">#define UTRSTAT0 bUART(0, oUTRSTAT)</span><br><span class="line">#define UERSTAT0 bUART(0, oUERSTAT)</span><br><span class="line">#define UFSTAT0  bUART(0, oUFSTAT)</span><br><span class="line">#define UMSTAT0  bUART(0, oUMSTAT)</span><br><span class="line">#define UTXH0  bUART(0, oUTXHL)</span><br><span class="line">#define URXH0  bUART(0, oURXHL)</span><br><span class="line">#define UBRDIV0  bUART(0, oUBRDIV)</span><br><span class="line">/* state */</span><br><span class="line">#define UTRSTAT_TX_EMPTY (1 &lt;&lt; 2)</span><br><span class="line">#define UTRSTAT_RX_READY (1 &lt;&lt; 0)</span><br><span class="line">#define UART_ERR_MASK  0x0f</span><br></pre></td></tr></table></figure></p><p>再来看看真正对UART的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void init_uart(void)</span><br><span class="line">&#123;</span><br><span class="line"> ULCON0 = vULCON0; //#define vULCON0 0x03  表示每帧有8个数据位，1个停止位，不进行奇偶校验，正常模式</span><br><span class="line"> UCON0 = vUCON0;  //#define vUCON0 0x245 表示接收模式和发送模式都是中断或轮询模式，当发生接收异常时，产生接收错误中断，发送中断类型为Level，接收中断类型为Pulse，波特率时钟源为PCLK</span><br><span class="line"> UFCON0 = vUFCON0;</span><br><span class="line"> UMCON0 = vUMCON0;</span><br><span class="line"> UBRDIV0 = 12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void putc(char c)</span><br><span class="line">&#123;</span><br><span class="line"> char i;</span><br><span class="line"></span><br><span class="line"> while (!(UTRSTAT0 &amp; UTRSTAT_TX_EMPTY)) &#123;  //不断的查询，直到发送缓冲寄存器和和移位寄存器都不为空，就可以发送数据</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> for (i=0; i&lt;10; i++) &#123;</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> UTXH0 = c; //直接将要发送的字符赋值给发送寄存器发送出去</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char getc(void)</span><br><span class="line">&#123;</span><br><span class="line"> while (!(UTRSTAT0 &amp; UTRSTAT_RX_READY)) &#123;</span><br><span class="line">  ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return URXH0;  //直接从接收寄存器中返回接收到的1个字节的数据</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;原文地址&gt;</p>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> Xilinx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决Xilinx-ISE 14.7在Win10下选择“open project”崩溃闪退的问题</title>
      <link href="/2017/02/20/%E8%A7%A3%E5%86%B3Xilinx_ISE%E5%B4%A9%E6%BA%83%E9%97%AA%E9%80%80%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/02/20/%E8%A7%A3%E5%86%B3Xilinx_ISE%E5%B4%A9%E6%BA%83%E9%97%AA%E9%80%80%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/56024153" target="_blank" rel="noopener">点这里</a></p><p>亲测可用并十分好用<br><a id="more"></a></p><ul><li><p><strong>问题描述</strong></p><p>ISE 14.7对win10无法完美支持，在使用64位ISE时点击OPEN之类的东西时程序都会崩溃，虽然使用32位不会有这个问题，但是工程的默认打开方式不能改为32位。 </p></li><li><p><strong>解决方法如下</strong></p></li></ul><hr><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>寻找安装Xilinx_ISE的安装目录下的文件夹：<br>D:\Xilinx\14.7\ISE_DS\ISE\lib\nt64<br>对文件夹下的两个文件作如下操作：<br>将libPortability.dll重名为libPortability.dll.orig<br>将 libPortabilityNOSH.dll 复制一份，然后将这个复制重命名为libPortability.dll<br><img src="http://img.blog.csdn.net/20170220201233631?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Xilinx"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>寻找安装Xilinx_ISE的安装目录下的文件夹：<br>D:\Xilinx\14.7\ISE_DS\common\lib\nt64</p><p>在该文件夹下进行如下操作：</p><p>将libPortability.dll重名为libPortability.dll.orig<br>然后将已经复制好的libPortabilityNOSH.dll文件复制到该文件夹下，并重命名为libPortability.dll</p><p><img src="http://img.blog.csdn.net/20170220201616742?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Xilinx\14.7\ISE_DS\common\lib\nt64"></p><p>至此，64位ISE在打开项目等方面已经不会闪退，但是 PlanAhead等高级功能面前还是会闪退，如有大神了解解决方法，欢迎留言或者私戳</p>]]></content>
      
      <categories>
          
          <category> 硬件编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> Xilinx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Socket编程--自己动手的HTTP代理服务器</title>
      <link href="/2017/02/03/Socket%E7%BC%96%E7%A8%8B_%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E7%9A%84HTTP%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/02/03/Socket%E7%BC%96%E7%A8%8B_%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E7%9A%84HTTP%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/54834992" target="_blank" rel="noopener">点这里</a><br>自己动手的HTTP代理服务器<br><a id="more"></a></p><p>##浏览器使用代理：Firefox浏览器：<br>选项-&gt;高级-&gt;连接-&gt;设置，选择手动配置代理。<br><img src="http://img.blog.csdn.net/20170202112848693?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="浏览器使用代理"></p><p>##实现http代理：<br>1.等待来自一个客户端的连接；<br>2.启动一个新线程来处理连接；<br>InputStream cis = null,sis=null;<br>OutputStream cos = null,sos=null;<br>try{<br>            csocket.setSoTimeout(TIMEOUT);<br>cis=csocket.getInputStream();<br>            cos=csocket.getOutputStream();<br>}<br>上面的代码定义了代理服务器与目标服务器间套接字并初试化，其中cis为客户端输入流，sis为目标主机输入流，socket为套接字。同时设置了超时控制，如果某个Socket不可用，另一个仍旧有机会进行处理，不必创建一个新的线程。<br>我的类直接从Thread类继承了下来.并且通过构造函数传递引用和客户Socket建立了联系.这样每个线程就有了一个通讯管道（pipe）。同样重写run方法，把代理工作交给线程来完成。这样多客户并行的Socket就建立起来了<br>3.读浏览器请求的第一行(包含终点url的行)；<br>4.解析请求第一行中终点Http服务器名及其端口号；<br>URL=getRequestURL(buffer);<br>int n;<br>       n=URL.indexOf(“//“);<br>         if (n!=-1)<br>                        host=URL.substring(n+2);    // <a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com/</a><br>          n=host.indexOf(‘/‘);<br>           if (n!=-1)<br>                          host=host.substring(0,n);// <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>           // 分析可能存在的端口号<br>          n=host.indexOf(‘:’);<br>           if (n!=-1) {<br>               port=Integer.parseInt(host.substring(n+1));<br>               host=host.substring(0,n);<br>          }<br>5.打开一个到终点Http服务器的套接字；<br>while (retry–!=0) {<br>               try {<br>                   //与目标服务器建立连接<br>                    ssocket=new Socket(host,port);    //尝试建立与目标主机的连接<br>                    break;<br>                } catch (Exception e) { }<br>                    Thread.sleep(CONNECT_PAUSE);//线程等待几毫秒<br>           }<br>6.通过该套接字发送/Http请求；<br>if(ssocket!=null){<br>               ssocket.setSoTimeout(TIMEOUT);//设置套接字超时时间<br>               sis=ssocket.getInputStream();<br>               sos=ssocket.getOutputStream();//从sscoket中得到输出流<br>               sos.write(buffer.getBytes());        //将请求头写入，向目标服务器输出http命令<br>7.发送从终点Http服务器(通过套接字)返回给浏览器请求的数据；<br>pipe(cis,sis,sos,cos);    这个方法用来实现套接字之间的数据交换。<br>8.关闭套接字，等待下一次连接。<br>由于关闭套接字时会抛异常，所以我用try,catch来包围代码块。</p><p>##Socket 编程的客户端和服务器端主要步骤<br>1.编写服务器端，实例化ServerSocket对象，这里要定义ip和端口，实例化Socket，从ServerSocket对象中accept() 获取，这里要涉及到流，输入输出流在Socket中获取。<br>2.编写客户端，实例化Socket对象，ip，端口，流，在Socket中获取：<br>1.创建服务器端SocketServer,并定义SocketServer的监听端口;<br>2、ServerSocket调用accept( )方法，是指处于阻塞；<br>3、创建客户端的Socket，并设置服务器的IP和端口；<br>4、客户端发送连接请求，建立连接；<br>5、分别取得服务器和客户端Socket的InputStream和OutputStream；<br>6、利用Socket和ServerSocket进行数据传输</p><p>##HTTP 代理服务器的基本原理：<br>HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。</p><p>##HTTP 代理服务器的程序流程图<br><img src="http://img.blog.csdn.net/20170202113311846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="HTTP 代理服务器的程序流程图"></p><p>##实现 HTTP 代理服务器的关键技术及解决方案:<br>理解Socket编程技术，分析HTTP代理应用程序设计原理和程序流程，选择合适的开发环境，参考已有的HTTP程序功能，设计实现HTTP代理功能的应用程序。<br>解决方案：Java实现socket编程并实现多线程。</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网上调研：主流网络技术和设备的性能与市场</title>
      <link href="/2017/02/02/%E4%B8%BB%E6%B5%81%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%92%8C%E8%AE%BE%E5%A4%87%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E5%B8%82%E5%9C%BA/"/>
      <url>/2017/02/02/%E4%B8%BB%E6%B5%81%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%92%8C%E8%AE%BE%E5%A4%87%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E5%B8%82%E5%9C%BA/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/54834914" target="_blank" rel="noopener">点这里</a></p><p>一个简单的例子<br><a id="more"></a></p><p>[TOC]</p><p>##一．当前主要的网络技术的进展–以太网的进展</p><p>###以太网的历史<br>1972年底，Bob Metcalfe（被尊称为“以太网之父”）设计了一套网络，把Alto计算机连接起来。在研制过程中，因为该网络是以ALOHA系统（一种无线电网络系统）为基础的，而又连接了众多的ALTO计算机，所以Metcalfe把它命名为ALTO ALOHA网络。ALTO ALOHA网络在1973年5月开始运行，Metcalfe把这个网络正式改名为以太网（Ethernet），这就是最初的以太网试验原型，该网络运行的速率为2.94Mbps，网络运行的介质为粗同轴电缆。1976年6月， Metcalfe和Boggs发表了题为：“以太网：局域网的分布型信息包交换”的著名论文。1977年底，Metcalfe和他的三位合作者获得了“具有冲突检测的多点数据通信系统”的专利，多点传输系统被称为CSMA／CD(带冲突检测的载波侦听多路访问)。从此，以太网就正式诞生了。<br>70年代末，涌现出了数十种局域网技术，以太网正是其中的一员。1979年，Digital Equipment　Corporation（DEC）、Intel公司与Xerox公司联盟，促进了以太网的标准化。1980年9月30日，DEC、Intel和Xerox公布了第三稿的“以太网，一种局域网：数据链路层和物理层规范，1.0版”，这就是现在著名的以太网蓝皮书，也称为DIX(取三家公司名字的第一个字母而组成的)版以太网1.0规范。如前所述，最初的实验型以太网工作在2.94Mbps，而DIX规范定义的以太网工作在10Mbps。1982年，DIX联盟发布了以太网的第二个版本，即Ethernet II。<br>在1981年6月，IEEE 802工程决定组成802.3分委员会，以产生基于DIX工作成果的国际公认标准，1983年6月IEEE 802.3工作组发布了第一个关于以太网技术的IEEE标准，即IEEE 10BASE5。<br>10BASE5的速率仍然是10Mbps，使用的传输介质仍然是粗同轴电缆，允许节点间的最长距离为500米。1984年美国联邦政府以 FIPS PUB107的名字采纳802.3标准。1989年ISO以标准号 IS88023采纳802.3以太网标准，至此，IEEE标准802.3正式得到国际上的认可。<br>90年代初，逐渐出现了多端口网桥，用于多个LAN的互连。共享式以太网逐渐向LAN交换机发展。1993年，Kalpana公司使以太网技术有了另外一个突破——全双工以太网。全双工的优点是很明显的，可以同时发送和接收数据，这在理论上可以使传输速度翻一番。<br>1993年10月，FEA公布了它的100BASE-X互操作规范，1995年3月，IEEE802.3u规范被它的成员和执委会所通过。于是快速以太网的时代宣布来临。1995年末，各厂家日新月异地不断推出新的快速以太网产品，快速以太网达到了鼎盛时代。<br>1995年11月，IEEE802.3标准委员会组建了一个新的“高速研究组(High-Speed Study Group)”，研究1000Mbps速率的以太网。1996年3月，IEEE组建了新的802.3z工作组，负责研究干兆位以太网，制订相应的标准。1998年，IEEE发布802.3z，1000Mbps的以太网标准。<br>2002年，10GE以太网标准802.3ae正式发布，10GE以太网与1000M以太网相比，10GE只支持全双工，只支持光纤作为传输介质，10GE可以应用于广域网WAN物理层技术SONET/SDH。<br>随着以太网技术的发展，以太网已经不仅仅局限于一种局域网技术，以太网技术逐渐应用于城域网MAN和广域网WAN</p><p>###以太网的相关标准：<br>10Base5以太网<br>一种以太网标准，该标准用于使用粗同轴电缆、速度为10Mbps的基带局域网络，在总线型网络中，最远传输距离为500米。网络节点装有收发器，该收发器插在网卡上的15针连接单元接口（Attachment Unit Interface）中，并接到电缆上。也作thick Ethernet,ThickNet,ThickWare。另见coaxial cable,Ethernet 指的是使用标准的（粗）50Ω基带同轴电缆的10Mbit/s的基带以太网规范。它是IEEE802.3基带物理层规范的一部分，在每个网段上的距离限制是500m,整个网络最大跨度为2500m，每个网段最多终端数量为100台，每个工作站距离为2.5m的整数倍。<br>10BASE5的命名原则<br>10代表传输速度为10Mbps，BASE指的是基带传输，5指的是大致的传输距离，10BASE5的最大传输距离不会超过500米。<br>10base2<br>10Base2，也叫做便宜网路或细缆，是一个 10-Mbps 基带以太网标准，其使用 50 欧姆的细同轴电缆。10Base2，其被定义在 IEEE 802.3a 标准中，每段有 185 米的长度限制。 10Base2 基于曼彻斯特信号编码通过细同轴电缆进行传输。，接头采用工业标准的bnc 连接器组成 t 型插座；每一段内仅能使用30 台计算机，段数最高为 30。<br>　　其中的10代表传输速率10Mbps，BASE代表表示基带传输，2表示最大传输距离185米。<br>其他标准：<br>1000BASE-T使用非屏蔽双绞线作为传输介质传输的最长距离是100米。<br>100base-tx：使用 5 类以上双绞线，网段长度最长可为100m。<br>100base-fx ：使用一对多模或者单模光纤，使用多模光纤的时候，计算机到集线器之间的距离最大可到2km，使用单模光纤时最大可达10km。<br>1000base-t：使用 5 类以上双绞线，网段长度最长可为100m。<br>1000base-f： 使用一对多模或者单模光纤，使用多模光纤的时候，计算机到集线器之间的距离最大可到300-550m（500m），使用单模光纤时最大可达3km。<br>1000base-lx可以接单、多模光纤； 1000base-sx只能接多模光纤。<br>1000base-lx用单模光纤传 5公里<br>1000base-lx用多模光纤(50um)传 550m<br>1000base-lx用多模光纤(62.5um)传 550m<br>1000base-sx用多模光纤(50um)传 275m<br>1000base-sx用多模光纤(62.5um)传 550m<br>100base-fx单模模块用单模光纤传 10-20 公里<br>100base-fx多模模块用多模光纤传 2 公里</p><p>1000Base-T以太网技术</p><p>在以上9种千兆以太网规范中，性价比最高的就是1000Base-T这种采用普通5类以上双绞线的千兆以太网规范。尽管在双绞线千兆以太网规范中还有1000Base-TX规范，但是它只能使用6类以上的双绞线，网络建设成本明显要高于1000Base-T规范。所以在此专门介绍一下这种应用最广的千兆以太网规范。<br>1000Base-T是专门为在5类双绞线上进行千兆速率数据传输而设计的。它采用了双绞线的全部4对芯线，并且是全双工传输的，也就是每对双绞线都可以同时进行数据的发送和接收，这样一来1Gb/s的传送速率可以等效地看作在4对双绞线上，每对的传送速率为250Mb/s（1000Mb/s / 4 = 250Mb/s）。因为1000Base-T只支持全双工传输，所以与1000Base-T千兆以太网端口直接相连的端口也必须是支持全双工的以太网端口（最佳情况是同时为1000Base-T千兆以太网端口），而不能是是半双工的，否则一方面性能会严重下降，达不到千兆的效果，另一方面还会有严重的丢包现象。<br>1000Base-TX尽管也是采用了全部的4对双绞芯线，但是它是两对发送，两对接收。在100Base-TX规范中所采用的仅是两对芯线，发送和接收各一对。 1000Base-T规范中各芯线的具体作用下图所示。每条芯线上分担的速率都是250Mb/s，所以，在全双工模式下，它可以实现2Gb/s的传输速率。<br><img src="http://img.blog.csdn.net/20170202104251714?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1000Base-T规范中各双绞芯线的作用"><br>1000Base-T规范中各双绞芯线的作用<br><img src="http://img.blog.csdn.net/20170202104354808?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1000Base-Tx规范中各双绞芯线的作用"><br>1000Base-Tx规范中各双绞芯线的作用<br>1000Base-T与100Base-TX采用相同的传送时钟频率（125MHz），但是利用了一种更加强大的信号传输和编/解码方案–PAM（Pulse Amplitude Modulation，脉冲调幅）-5。PAM-5编码使用-2、-1、0、+1、+2五种电平，其中-2、-1、+1、+2四种电平用于信号编码，0电平用于前向纠错编码（FEC）；而在100Base-TX中采用的是3级MLT（3Multi-Level Transmission，多级传送）编码方案MLT-3。对应的编码格式如图5-15所示。PAM-5编码方使用-1、0、+1三种电平，其-1和+1用于信号传输，0电平用于前向纠错。由此可见，PAM-5方案可以在链路上较100Base-TX多传送一倍的数据。<br><img src="http://img.blog.csdn.net/20170202104716959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>另外，1000Base-T规范中的双绞线收发模块内置了一块功能强大的物理层芯片，可以支持1000Base-X规范中的串行（SERDES）接口，即可以与现有的千兆光纤模块完全兼容，充分体现了其强大的适应力。1000Base-T双绞线收发模块同时还能支持由思科提出的SGMII接口，该接口能支持模块在10M/100M/1000M多种速率下工作，使得1000Base-T模块比千兆光纤模块有更大的生存力。<br>1000Base-T规范具有许多优良的特性。首先，它支持以太网MAC，而且可以后向兼容10Mb/s、l00Mb/s以太网技术。其次，很多的1000Base-T产品都将支持100/1000自动协商功能，1000Base-T因此可以直接在快速以太网络中通过升级实现。最后，1000Base-T是一种高性能技术，它每传送100亿比特，其中错误的数据位不会超过一个（误比特率低于10^(-10)，这与100Base-T的误比特率相当）。<br>总体而言，1000Base-T规范最吸引人的地方在于为企业提供了一种除多模光纤以太网方案外的更廉价千兆方案，用户可以在原来100Base-T的基础上进行平滑升级到1000Base-T。该规范主要用于结构化布线中同一层建筑的通信，可以利用现有以太网或快速以太网已铺设的UTP 电缆进行网络升级，也可被用作大楼内的网络主干，大大节省成本。这是目前最主要应用的千兆以太局域网方案。   </p><p>###以太网现状<br>过去若干年来，以太网的发展大致是以10倍速来进行的。10M、100M、1G、10G、40G、100G，但从近两年开始，2.5G、5G、25G开始步入人们的视野。以太网联盟代表David Chalupsky告诉记者，这一切的起因，是源于用户现实的需求。<br>（<a href="http://network.cnw.com.cn/network-carrier-ethernet/htm2015/20150513_319910.shtml）" target="_blank" rel="noopener">http://network.cnw.com.cn/network-carrier-ethernet/htm2015/20150513_319910.shtml）</a><br>2014年<br>根据Infonetics报告称，在2014年第四季度全球以太网交换机的销售额为59亿美元。而在2014年全年，全球以太网交换机销售额为217亿美元，比去年同期增长5%。<br>在报告中还提及，中国以太网交换机市场增速强劲，从2013年到2014年增长17%。其中华为在该市场的表现尤其抢眼，相比2013年收入增长72%，分析认为是因为其渠道的不断扩展，以及在欧洲知名度的提升。思科在整体市场的权重也在提升，在2014年四季度增长1%。<br>2015年<br>以太网社区在2014年取得了长足进步，打破了将现有速率以10倍为一级别进行提升的传统惯例将目标定为25GbE，并开始探索2.5GbE和5GbE的可行性。<br>参考资料<a href="http://fiber.ofweek.com/2015-01/ART-210022-8440-28923650_2.html" target="_blank" rel="noopener">http://fiber.ofweek.com/2015-01/ART-210022-8440-28923650_2.html</a><br>据Dell’Oro最新研究数据，尽管面临一些经济逆风，2015年全球二层和三层以太网交换机市场超过240亿美元。Arista、博科、思科、华为和Juniper是真正最快速的五家厂商。<br>（<a href="http://www.c114.com.cn/market/177/a942297.html）" target="_blank" rel="noopener">http://www.c114.com.cn/market/177/a942297.html）</a><br>2016年<br>全球知名数据统计机构IDC，日前发布了全球首季度以太网交换机和路由器市场研究报告。2016年第一季度全球以太网交换机市场规模为54.8亿元，与去年同期相比增长了1.4%。与此同时，全球企业和运营商路由器市场规模为34.7亿美元，同比增长了3.3%。（<a href="http://www.199it.com/archives/480993.html）" target="_blank" rel="noopener">http://www.199it.com/archives/480993.html）</a><br>据市场调研公司Dell’Oro Group的最新报告显示，2016年Q2全球以太网交换机第二和第三层市场营收超过60亿美元，同比增幅达6%。当中，企业园区的反弹，中国地区季度的记录销量，加之云计算强势增长，都成为Q2业绩增长的催化剂。（<a href="http://network.pconline.com.cn/836/8362260.html）" target="_blank" rel="noopener">http://network.pconline.com.cn/836/8362260.html）</a></p><p>##二：当前主要网络技术的应用–大学校园使用的技术和设备状况</p><p>###西南民族大学校园网<br>华为智慧可运营校园网络解决方案采用扁平化设计，在网络核心部署BRAS设备对全网实现一体化认证和管理，有线部分实施PPPoE认证改造，大大提高网络的使用性和管理性；在校园各场景因地制宜部署适合的AP，实现无线覆盖整个校园；网络核心采用华为高端核心网络交换机，以适应不断发展的校园网络高速率要求。 </p><p>####具体设备及部署方案说明：<br>1) 网络出口部署华为BRAS设备ME60设备作为校园认证，两台作为ME60实现双机热备，保障校园内业务的持续稳定运行；<br> 2) 新校区和校本部的核心采用CE12800设备作为网络核心，启用CS和VSS两重虚拟化支持校内多业务的并发不干扰运行；<br>3) 汇聚层和接入层使用SX700系列，全面替换原有交换机，二层模式部署，部分需要为无线AP提供POE接入；</p><p>4) 数据中心核心部署CE12800作为校园教育云数据中心的网络核心，并部署USG5500构建数据中心的安全防 御能力；</p><p>5) 在整体网络结构设计中，无线部分作为网络补充，完全融入有线的网络之中，为校园内的用户提供一体化 的网络使用体验。</p><p><img src="http://img.blog.csdn.net/20170202104912982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="西南民族大学校园网"></p><p>####技术特点：<br>精细化管理方案</p><p>全网采用实名认证，使用BRAS实现全网推送，并由BRAS统一管理整个学校上网权限，对每个实现PPPoE 认证的用户下发单独基于账号的VLAN，上层使用QinQ实现通道共用，全网的所有上网账号实现安全隔离， 上网互不影响，并对下层流量使用配置多层的HQoS，实现精细化流量控制，为业务稳定运行设定良好框 架。整网的管理方案能实现针对用户、针对应用实现精细化管理，并且管理简单，维护方便。</p><p>扁平化大二层网络设计</p><p>网络核心部署BRAS设备来实现全网的认证管理，并且作为网关设备，下层所有汇聚和接入交换机都只启 用二层转发。整个网络在逻辑上就是一个大型的二层网络，下层交换机除了启用VLAN之外，就只负责基础 的数据转发工作，这样就去除了大量复杂和繁琐的底层设备维护工作量。在整个大二层网络中，由BRAS设备 针对每个用户账号的VLAN信息，保证网络使用的安全隔离和互不影响。</p><p>有线无线一体化设计</p><p>网络改造方案舍弃了原来维护性和使用性不佳的802.1X认证方案，采用了有线PPPoE认证，无线采用 WEB认证，有线与无线上网账号共用，权限一致。网络层的认证设备与安全设备账号信息互通，从而实现极 为简便的精细化全网管理。</p><p>易于维护的精细化管理网络方案设计，降低学校运维成本</p><p>西南民族大学采用华为BRAS设备ME60对校园的认证进行改造，取消原来的802.1X认证，启用PPPoE认 证。PPPoE认证能把所有的认证接入管理工作会汇聚到核心的BRAS设备上，因此大幅减少了对接入网络设备 的维护量；底层的设备仅仅作为基本的数据转发，因此也大幅降低了出现网络故障的几率；PPPoE针对每个 账号下发单独的VLAN，每个账号上网互不影响，这样就在极大的程度上实现了整网的稳定；另外PPPoE认证 对接入网络设备没有特殊要求性，因此让校园后续的网络设备扩容摆脱了对网络设备供应商的依赖性。</p><p>高效率的复用型网络平台，多种复杂校园业务同时承载</p><p>华为CloudEngine12800系列交换机可构建业界最大的360T无阻塞交换平台，并具备分布式大缓存能力， 满足核心网络以及数据中心内超大规模服务器集群计算需求。VS+CSS的两层虚拟化能力能让CE12800可以完 美应用于校园的多业务共用的核心网络和云计算数据中心中，打造资源复用的网络平台，稳定支撑校园内的 大量用户访问。</p><p>有线无线融合一体化，提升师生校园上网使用体验</p><p>在西南民族大学的网络结构设计中，使用ME60做为校园内统一的账号认证管理，有线和无线统一化， 在整个校园中具有网络权限的用户可以在任何一个地点，实现一致性的网络访问，无论是使用PC还是其他智 能终端，都可以使用统一的账号认证登陆，并且在无线AC覆盖范围内，实现园区内的无缝漫游。</p><p>高可靠和稳定的基础网络设备，提供永续的数字化校园信息化业务承载</p><p>在西南民族大学校园的网络改造中，使用了大量华为Sx700系列路由器使用在网络的汇聚层和接入层。 华为的Sx700系列交换机具有包括硬件BFD、硬件OAM，支持SEP半环保护技术等多种独家可靠性技术保障网 络的可靠性；另外，Sx700系列交换机和华为WLAN室外AP系列有出色的环境适应能力，6Kv防雷、高密度防 尘等。</p><p>融合安全技术，保障绿色和谐的校园网络环境</p><p>华为把安全技术融入网络体系中，在西南民族大学的校园网络方案中， ME60实现了对全网的实名管理， 并且对全网下发5层HQoS保证整网流量使用的稳定性，并且在网络边界使用了统一防火墙USG5500，安全系统 与BRAS认证管理系统实现信息互通，建立统一的安全保障体系，从而增强校园网络的安全性和可管控性。</p><p>##三：探索身边的网络</p><p>###1.tracert工具发现自己的机器如何连到网络<br><img src="http://img.blog.csdn.net/20170202105040701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="tracert工具发现自己的机器如何连到网络"></p><p>###2.用telnet连接服务器<br>1.telnet  192.168.254.1<br><img src="http://img.blog.csdn.net/20170202105151872?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="用telnet连接服务器"><br><img src="http://img.blog.csdn.net/20170202105205247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="用telnet连接服务器"><br>了解到设备是由杭州华三通信技术有限公司提供的。杭州华三通信技术有限公司（简称华三通信），致力于IT基础架构产品及方案的研究、开发、生产、销售及服务，拥有完备的路由器、以太网交换机、无线、网络安全、服务器、存储、IT管理系统、云管理平台等产品。（<a href="http://www.h3c.com.cn/）" target="_blank" rel="noopener">http://www.h3c.com.cn/）</a><br>2.telnet 202.194.0.49<br><img src="http://img.blog.csdn.net/20170202105238139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>连接提示显示MX960-1-re0，查询网络得知该MX960是一款Juniper产的以太网业务边缘路由器。</p><p>##四：IPV6技术与设备</p><p>###IPV6基础知识<br>IPv6是Internet Protocol Version 6的缩写，其中Internet Protocol译为“互联网协议”。IPv6是IETF（互联网工程任务组，Internet Engineering Task Force）设计的用于替代现行版本IP协议（IPv4）的下一代IP协议。目前IP协议的版本号是4（简称为IPv4），它的下一个版本就是IPv6。</p><p>####IPV6的特点：<br>（1）IPV6地址长度为128位，地址空间增加了2^128-2^32个。<br>（2）灵活的IP报文头部格式。使用一系列固定格式的扩展头部<br>取代了IPV4中可变长度的选项字段。IPV6中选项部分的出现方式也有所变化，使路由器可以简单路过选项而不做任何处理，加快了报文处理速度；<br>（3）IPV6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量；<br>（4）提高安全性。身份认证和隐私权是IPV6的关键特性；<br>（5）支持更多的服务类型；<br>（6）允许协议继续演变，增加新的功能，使之适应未来技术的发展；</p><p>####IPV6技术发展现状<br>（1）IPV6当前的主要价值还在于解决地址问题，因此地址相对短缺而信息技术发展快的东亚地区，IPV6相关技术发展快；<br>（2）IPV6的网络技术正在趋于完善，在路由协议、组播、移动等方面待完善；<br>（3）IPV6的操作系统技术已经发展比较完善；<br>（4）IPV6的应用技术尚非常匮乏，欠缺发展；<br>（5）围绕着应用优化网络及相关部分，是下一步发展的重点；<br>（6）IPv6的标准还在不断更新，IP地址、ICMP的标准还在改变；<br>（7）IPv6的业务和管理标准还不满足构建大系统的要求。</p><p>####IPV6设备支持<br>（1）主流网络设备厂商对于IPV6的支持已经较为完善。CISCO、Juniper、华为/华为3Com均已提供完善的IPV6产品序列和解决方案；<br>（2）大部分路由器厂商支持双协议栈和完善的隧道技术；<br>（3）最新的交换机可支持IPV6的转发，未来将陆续支持OSPF V3等IPV6路由协议；<br>（4）围绕着信息家电等应用驱动，IPV6在终端侧的发展也较快；<br>（5）微软的下一代操作系统全面支持IPV6。<br><img src="http://img.blog.csdn.net/20170202105500297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="华为H3C交换机系列：从二层接入到核心，H3C可以全面支持IPV6的交换机"><br>华为H3C交换机系列：从二层接入到核心，H3C可以全面支持IPV6的交换机</p><p>###身边的IPV6-东北大学六维空间</p><p>####1．拓扑设计<br>东北大学六维空间校园网采用环形万兆核心三层网络拓扑结构。主干网共5个节点，采用万兆互联、多环形拓扑结构；汇聚层共7个节点，其中3个负载较重的节点采用万兆上联、千兆备份结构，其余节点采用双千兆上联结构；接入层采用单千兆光纤上联结构。总体拓扑与目前网络基本一致，后期建设主要是更换2个核心节点设备，升级部分千兆链路为万兆。</p><p>####2．主干网和接入网设计<br>(1)主干网技术设计方案</p><p>主干网节点采用万兆多环形结构，通过Cisco 7609独立光纤1Gbps上联CERNET网络，通过Cisco 12404独立光纤1Gbps上联CNGI-CERNET2网络。</p><p>(2)汇聚层技术设计方案</p><p>汇聚层采用双光纤链路上联方案。对负载较重的3个节点采用一条万兆链路、一条千兆链路上联，其余节点采用双千兆上联。使用BGP4+协议对业务路由进行更新。<br> <img src="http://img.blog.csdn.net/20170202105653114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="东北大学IPV6拓扑规划"><br> 东北大学IPV6拓扑规划</p><p>3.未来预期<br>主干拓扑实现万兆多环结构；接入信息点数量可达到3万以上，使用IPv6协议上网用户数达2万以上；在IPv6的网络上提供DNS服务、BLOG服务、电子邮件服务、个人主页托管服务、视频会议服务、VOD点播服务、在线网络电视服务、FTP服务、BT服务，以及统一的Web门户系统和统一认证服务；完成标准机房改造；向校内提供IPv6托管服务；完成纯IPv6子网的建设。</p><p>##五：未来网络技术发展方向</p><p>###5G 移动通信网络关键技术<br>1   超密集异构网络<br>未来 5G 网络正朝着网络多元化、宽带化、综合 化、智能化的方向发展。随着各种智能终端的普及， 面向 2020 年及以后，移动数据流量将呈现爆炸式增 长。在未来 5G 网络中，减小小区半径，增加低功率 节点数量，是保证未来 5G 网络支持 1 000 倍流量增 长的核心技术之一。因此，超密集异构网络成 为未来 5G 网络提高数据流量的关键技术。</p><p>2   自组织网络<br>自组织网络技术解决的关键问题主要有以下 2 点:①网络部署阶段的自规划和自配置;②网络维护 阶段的自优化和自愈合。自配置即新增网络节点的配置可实现即插即用，具有低成本、安装简易等 优点。自优化的目的是减少业务工作量，达到提升网络质量及性能的效果，其方法是通过 UE 和 eNB 测量，在本地 eNB 或网络管理方面进行参数自 优化。自愈合指系统能自动检测问题、定位问题和 排除故障，大大减少维护成本并避免对网络质量和用户体验的影响。自规划的目的是动态进行网络规划并执行，同时满足系统的容量扩展、业务监测或优 化结果等方面的需求<br>3   D2D通信<br>D2D ( de- vice-to-device  communication，D2D)通信是一种基于蜂窝系统的近距离数据 直接传输技术。D2D 会话的数据直接在终端之间 进行传输，不需要通过基站转发，而相关的控制信令，如会话的建立、维持、无线资源分配以及计费、鉴权、识别、移动性管理等仍由蜂窝网络负责<br> <img src="http://img.blog.csdn.net/20170202105819945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="D2D 通信系统"><br> D2D 通信系统<br>4   SDN /NFV<br>随着网络通信技术和计算机技术的发展，互联网 + 、三网融合、云计算服务等新兴产业对互联网在 可扩展性、安全性、可控可管等方面提出了越来越高 的要求。SDN(software-defined networking，软件定义网络) / NFV(network  function  virtualization，网络功能 虚拟化)作为一种新型的网络架构与构建技术，其 倡导的控制与数据分离、软件化、虚拟化思想，为突破现有网络的困境带来了希望。在欧盟公布 的 5G 愿景中，明确提出将利用 SDN / NFV 作为基础 技术支撑未来 5G 网络发展。<br>SDN 架构的核心特点是开放性、灵活性和可编 程性。下图 所示为 ONF组织提出的 SDN 架构。<br>主要分为 3 层:基础设施层位于网络最底层，包括大量基础网络设备，该层根据控制层下发的规则处理和转发数据;中间层为控制层，该层主要负责对数据转发面的资源进行编排，控制网络拓扑、收集全局状 态信息等;最上层为应用层，该层包括大量的应用服务，通过开放的北向 API 对网络资源进行调用。<br> <img src="http://img.blog.csdn.net/20170202105854086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="SDN架构"><br>Sdn架构<br>NFV( network  function  virtualize，网络功能虚拟 化)是由欧洲电信标准组织(ETSI)从网络运营商 的角度出发提出的一种新的网络架构，通过通用的 IT 技术与平台对网元进行功能虚拟化，针对不同的业务 应用需求，在 VNF 的基础上进行相应的功能块连接 与编排。ETSI 定义的 NFV 框架如下图 所示。</p><p> <img src="http://img.blog.csdn.net/20170202105924815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="NFV架构"><br>    NFV 架构<br>5  软件定义无线网络<br>软件定义无线网络保留了 SDN 的核心思想，即将控制平面从分布式网络设备中解耦，实现逻辑上的网络集中控制，数据转发规则由集中控制器统一 下发。软件定义无线网络的架构分为3个层面，如下图所示。在软件定义无线网络中，控制平面可以获取、更新、预测全网信息，例如:用户属性、动态网络需求以及实时网络状态。因此，控制平面能够 很好地优化和调整资源分配、转发策略、流表管理 等，简化了网络管理，加快了业务创新的步伐。<br> <img src="http://img.blog.csdn.net/20170202110004831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWRldmVkZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="软件定义无线网络架构"><br>软件定义无线网络架构<br>软件定义无线网络的提出给无线网络领域带来崭新的发展前景，但是软件定义无线网络架构中南 北向接口尚未形成统一的标准。在未来 5G 网络 中，传统网络将与软件定义无线网络长期共存，如何 解决异构网络之间的兼容性问题，如何规范编程接 口，如何发现灵活有效的控制策略都是软件定义无线网络面临的挑战。</p><p>###IP路由技术发展趋势</p><p>####未来 IP 路由器特征</p><p>未来，传统 IP 路由器不会在短期内消失，而是会逐渐向能力开放与虚拟化方向演进，同 时 ，以可编程为特征的新型IP 路由器也将会出现，并在中低端路由器市场逐渐占据优势。未来 的 IP 路由器主要具备以下特征：<br>1  容量扩展支撑流量持续增长<br>无论设备形态如何，单设备容量提升仍是IP路由器研发的主要发展方向。具体表现在围绕着设备单槽能力的提升，不断提升芯片处理能力 、端口吞吐量 、背板能力以及整机降耗水 平 ，其研发重点在于提升芯片性能以及 SerDes速 率 ，并逐步利用硅光子 [6]等技术突破电域技术瓶颈 。<br>2  虚拟化提升资源调度精度<br>虚拟化主要表现为路由器虚拟化与网络功能虚拟化（network function virtualization ，NFV）。 逻辑路由器属于典 型的路由器虚拟化（在一个物理路由器划分独立硬件资源 以及网络功能实例 ，形成逻辑路由器 ）；NFV 强调通过通用 x86 架构实现路由器功，并通过云化技术实现路由器能力拓展，打破专用硬件的限制 。<br>3  开放架构推动网络能力开放<br>传 统 IP 路由器的接口开放只能实现部分的能力开放。网络能力开放需借助于路由器的开放架构。在开放架构下，路由器由一组逻辑分离且接口标准化的实体组成，各个实体可作为标准部件开发。客户按需利用实体建构路由器。现阶段，“白牌”路由器已具备开放架构雏形。另外，基于 NFV 的设备实现也是开放架构研究的重点 。<br>4  软件可编程实现业务灵活加载<br>软件可编程是网络能力开放的高级形式。路由器的软件可编程特性可基于网络定位，通过数据编排来分配资源和定义业务流程，从而实现业务的灵活、动态部署。路由器的软件可编程主要体现在系统架构 、网络接口 、数据报文处理流程 、新协议升级以及网络管理方式等<br>方 面 ，强调用户对网络自定义。现阶段 ，OpenFlow交换机是软件可编程设备的代表 。</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> ipv6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统：Nachos，java实现线程部分</title>
      <link href="/2016/12/09/Nachos%E6%93%8D%E4%BD%9C%E7%B3%BB_%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/"/>
      <url>/2016/12/09/Nachos%E6%93%8D%E4%BD%9C%E7%B3%BB_%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/53096331" target="_blank" rel="noopener">点这里</a></p><p>操作系统进程的状态以及进程状态的转换<br>进程是程序的一次执行活动，它是一种动态的概念，而这种动态在宏观上表现为状态的变化。<br><a id="more"></a><br>进程在运行中，有三种基本状态：</p><p>l  运行态：进程分配到处理机运行。</p><p>l  就绪态：进程已经可以在处理机上运行，只是暂时没有分配到处理机。</p><p>l  阻塞态：进程因等待某一个事件发生而暂时不能调度上处理机运行。</p><p>一个系统中的进程在一定条件下可以在这三种状态之间转换。一般有四种类型的转换。</p><p>l 运行态 -&gt; 就绪态</p><p>进程占用CPU运行了一段时间，但是没有运行结束。为使各就绪进程能比较平衡地共享CPU，此时调度程序需要将其它就绪进程调度上处理机运行，于是原来占据处理机的进程成为就绪态，等待下一次被调度上处理机运行。</p><p>l 就绪态 -&gt; 运行态</p><p>进程处于就绪态，调度程序总是有机会将其调度上处理机，于是该进程从就绪态转为运行态，并从上一次运行的中断点继续运行。</p><p>l 运行态 -&gt; 阻塞态</p><p>进程运行过程中可能因等待某种事件发生而暂时停止，比如等待一次键盘事件或者磁盘输入输出。进程进入阻塞态时，调度程序会调度一个就绪态进程上处理机运行。</p><p>l 阻塞态 -&gt; 就绪态</p><p>当进程进入阻塞态之前等待发生的事件业已发生，则该进程从阻塞态转为就绪态，于是它可以再被调度上处理机继续运行。</p><p>除了个别进程外，一般进程都需要经历这三种状态，并在这三种状态中反复变换直至运行终止。</p><h2 id="Nachos进程的状态以及进程状态的转换"><a href="#Nachos进程的状态以及进程状态的转换" class="headerlink" title="Nachos进程的状态以及进程状态的转换"></a>Nachos进程的状态以及进程状态的转换</h2><p><img src="https://img-blog.csdn.net/20161109094502097" alt="Nachos进程的状态以及进程状态的转换"><br>           Nachos中系统线程和用户进程</p><p>Nachos为线程提供的功能函数有:</p><ol><li><p>生成一个线程(Fork)</p></li><li><p>使线程睡眠等待(Sleep)</p></li><li><p>结束线程(Finish)</p></li><li><p>设置线程状态(setStatus)</p></li><li><p>放弃处理机(Yield)<br>上面这5个方法对于我们实现自己selftest方法来说是必须掌握的。</p></li></ol><p><img src="https://img-blog.csdn.net/20161109094819816" alt=""><br>            Nachos系统结构</p><h2 id="Nachos线程管理同实际进程管理的不同"><a href="#Nachos线程管理同实际进程管理的不同" class="headerlink" title="Nachos线程管理同实际进程管理的不同"></a>Nachos线程管理同实际进程管理的不同</h2><p>Nachos除了在线程管理上作了一系列的简化外，和实际的进程管理还有以下的不同：</p><p>l  不存在系统中所有线程的列表</p><p>在一般的操作系统中，进程的数目总是有限的，但是Nachos中的线程数目可以是无限的（当然，用户进程的数目应该也是有限的。当虚拟机内存以及虚拟内存都耗尽时，就不能产生新的用户线程）。这是因为，线程的控制结构和系统线程的运行是占用宿主机的。能够开多少线程完全由宿主机条件限制，理论上是无限的。</p><p>l  线程的调度比较简单</p><p>在启动了时钟中断的情况下，当时钟中断到来时，如果就绪线程队列中有就绪线程，就必须进行线程切换；当没有启动时钟中断的情况下，Nachos使用非抢占式调度。</p><p>l  没有实现父子线程的关系</p><p>可以说，所有的Nachos线程都是Nachos的一个子线程。但是Nachos线程之间的父子关系没有实现。这样产生的混乱体现在线程的空间释放上，一个线程空间的释放是由下一个被切换的线程也即兄弟线程进行的，而这两个线程可以是没有任何关系的。这样的情况对以后进一步进行系统扩充是不利的。</p><p>没有实现父子线程关系这点很重要！！！这直接导致了fork函数跟我们正常操作系统中的巨大差异：</p><p>简单来说Nachos的fork就是将创建的线程加入到ready队列当中，但是Linux的fork函数描述是：内核根据父进程复制出一个子进程，父进程和子进程的PCB信息相同，用户态代码和数据也相同。因此，子进程现在的状态看起来和父进程一样，做完了初始化，刚调用了fork进入内核，还没有从内核返回。</p><p><img src="https://img-blog.csdn.net/20161109095416136" alt="Nachos线程转换图"><br>Nachos线程转换图</p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
            <tag> Nachos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>静态块 简单例子</title>
      <link href="/2016/12/05/%E9%9D%99%E6%80%81%E5%9D%97/"/>
      <url>/2016/12/05/%E9%9D%99%E6%80%81%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/53465744" target="_blank" rel="noopener">点这里</a></p><p>一个简单的例子<br><a id="more"></a></p><ol><li><p>所有静态的(无论其是变量还是块)都按顺序执行. </p></li><li><p>所有的非静态的块都在静态的(无论其是变量还是块)后执行. </p></li><li><p>所有的块(无论是静态的还是非静态的)都在构造之前执行.</p></li><li><p>静态块在类被加载到内存后就开始执行</p></li><li><p>非静态块是在创建对象时，构造之前被调用</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TestStaticMode &#123;  </span><br><span class="line">    public TestStaticMode() &#123;  </span><br><span class="line">        System.out.println(&quot;in structure&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    static int i = 0;  </span><br><span class="line">  </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(&quot;in first no static i=&quot; + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    static &#123;  </span><br><span class="line">        i = 1;  </span><br><span class="line">        System.out.println(&quot;in static i=&quot; + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(&quot;in second no static i=&quot; + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String args[]) &#123;  </span><br><span class="line">        TestStaticMode testStaticMode = new TestStaticMode();  </span><br><span class="line">        System.out.println(&quot;i=&quot; + i);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TestStaticMode &#123;</span><br><span class="line">public TestStaticMode() &#123;</span><br><span class="line">System.out.println(&quot;in structure&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int i = 0;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;in first no static i=&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static &#123;</span><br><span class="line">i = 1;</span><br><span class="line">System.out.println(&quot;in static i=&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;in second no static i=&quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">TestStaticMode testStaticMode = new TestStaticMode();</span><br><span class="line">System.out.println(&quot;i=&quot; + i);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in static i=1 </span><br><span class="line">in first no static i=1 </span><br><span class="line">in second no static i=1 </span><br><span class="line">in structure</span><br><span class="line">i=1</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 静态块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之Decorator(油漆工) 装饰者模式</title>
      <link href="/2016/12/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BDecorator%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/12/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BDecorator%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/53401252" target="_blank" rel="noopener">点这里</a></p><p>装饰模式:Decorator常被翻译成”装饰”,我觉得翻译成”油漆工”更形象点,油漆工(decorator)是用来刷油漆的,那么被刷油漆的对象我们称decoratee.这两种实体在Decorator模式中是必须的.<br><a id="more"></a></p><p><em>Decorator定义:</em><br>动态给一个对象添加一些额外的职责,就象在墙上刷油漆.使用Decorator模式相比用生成子类方式达到功能的扩充显得更为灵活.</p><p><em>为什么使用Decorator?</em></p><p>我们通常可以使用继承来实现功能的拓展,如果这些需要拓展的功能的种类很繁多,那么势必生成很多子类,增加系统的复杂性,同时,使用继承实现功能拓展,我们必须可预见这些拓展功能,这些功能是编译时就确定了,是静态的.<br>使用Decorator的理由是:这些功能需要由用户动态决定加入的方式和时机.Decorator提供了”即插即用”的方法,在运行期间决定何时增加何种功能.</p><p><em>如何使用?</em><br>举Adapter中的打桩示例,在Adapter中有两种类:方形桩 圆形桩,Adapter模式展示如何综合使用这两个类,在Decorator模式中,我们是要在打桩时增加一些额外功能,比如,挖坑 在桩上钉木板等,不关心如何使用两个不相关的类.</p><p>我们先建立一个接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Work</span><br><span class="line">&#123; </span><br><span class="line">　　public void insert();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口Work有一个具体实现:插入方形桩或圆形桩,这两个区别对Decorator是无所谓.我们以插入方形桩为例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class SquarePeg implements Work&#123;</span><br><span class="line">　　public void insert()&#123;</span><br><span class="line">　　　　System.out.println(&quot;方形桩插入&quot;);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在有一个应用:需要在桩打入前,挖坑,在打入后,在桩上钉木板,这些额外的功能是动态,可能随意增加调整修改,比如,可能又需要在打桩之后钉架子(只是比喻).</p><p>那么我们使用Decorator模式,这里方形桩SquarePeg是decoratee(被刷油漆者),我们需要在decoratee上刷些”油漆”,这些油漆就是那些额外的功能.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Decorator implements Work&#123;</span><br><span class="line"></span><br><span class="line">　　private Work work;</span><br><span class="line">　　//额外增加的功能被打包在这个List中</span><br><span class="line">　　private ArrayList others = new ArrayList();</span><br><span class="line"></span><br><span class="line">　　//在构造器中使用组合new方式,引入Work对象;</span><br><span class="line">　　public Decorator(Work work)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　this.work=work;</span><br><span class="line">　　 </span><br><span class="line">　　　　others.add(&quot;挖坑&quot;);</span><br><span class="line"></span><br><span class="line">　　　　others.add(&quot;钉木板&quot;);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　public void insert()&#123;</span><br><span class="line"></span><br><span class="line">　　　　newMethod();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line">　　//在新方法中,我们在insert之前增加其他方法,这里次序先后是用户灵活指定的 　　 </span><br><span class="line">　　public void newMethod()</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　otherMethod();</span><br><span class="line">　　　　work.insert();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">　　&#125; </span><br><span class="line"></span><br><span class="line">　　public void otherMethod()</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　ListIterator listIterator = others.listIterator();</span><br><span class="line">　　　　while (listIterator.hasNext())</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　System.out.println(((String)(listIterator.next())) + &quot; 正在进行&quot;);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上例中,我们把挖坑和钉木板都排在了打桩insert前面,这里只是举例说明额外功能次序可以任意安排.</p><p>好了,Decorator模式出来了,我们看如何调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Work squarePeg = new SquarePeg(); </span><br><span class="line">Work decorator = new Decorator(squarePeg);</span><br><span class="line">decorator.insert();</span><br></pre></td></tr></table></figure></p><p>Decorator模式至此完成.</p><p>如果你细心,会发现,上面调用类似我们读取文件时的调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = new FileReader(filename);</span><br><span class="line">BufferedReader br = new BufferedReader(fr);</span><br></pre></td></tr></table></figure></p><p>实际上Java 的I/O API就是使用Decorator实现的,I/O变种很多,如果都采取继承方法,将会产生很多子类,显然相当繁琐.</p><p>Jive中的Decorator实现<br>在论坛系统中,有些特别的字是不能出现在论坛中如”打倒XXX”,我们需要过滤这些”反动”的字体.不让他们出现或者高亮度显示.</p><p>在IBM Java专栏中专门谈Jive的文章中,有谈及Jive中ForumMessageFilter.java使用了Decorator模式,其实,该程序并没有真正使用Decorator,而是提示说:针对特别论坛可以设计额外增加的过滤功能,那么就可以重组ForumMessageFilter作为Decorator模式了.</p><p>所以,我们在分辨是否真正是Decorator模式,以及会真正使用Decorator模式,一定要把握好Decorator模式的定义,以及其中参与的角色(Decoratee 和Decorator).</p><p>更多资料，见《JAVA实用系统开发指南》</p>]]></content>
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>总结－从键盘按下字符到它出现在显示器的过程详解</title>
      <link href="/2016/11/30/%20%E4%BB%8E%E9%94%AE%E7%9B%98%E6%8C%89%E4%B8%8B%E5%AD%97%E7%AC%A6%E5%88%B0%E5%AE%83%E5%87%BA%E7%8E%B0%E5%9C%A8%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2016/11/30/%20%E4%BB%8E%E9%94%AE%E7%9B%98%E6%8C%89%E4%B8%8B%E5%AD%97%E7%AC%A6%E5%88%B0%E5%AE%83%E5%87%BA%E7%8E%B0%E5%9C%A8%E6%98%BE%E7%A4%BA%E5%99%A8%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/53188542" target="_blank" rel="noopener">点这里</a></p><p>计算机的组成<br><a id="more"></a></p><p>１．键盘被按下后，产生了硬件中断信号。<br>２．计算机高级中断控制器（IOAPIC）选择CPU处理核心以及软件中断编号,并发送给中断描述符表（IDT）处理。<br>３．计算机根据IDT选择中断处理函数。<br>４．处理函数处理并通知端口驱动获取按键的信息。<br>５．端口驱动将数据封装，以IRP（I/O request package）形式传递给上层处理程序。<br>６．等待输入的进程获得数据，处理并交给目标进程。<br>７．目标进程显示输入。</p>]]></content>
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象之桥梁模式</title>
      <link href="/2016/11/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/11/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/53227827" target="_blank" rel="noopener">点这里</a></p><p>桥梁模式（Bridge Patter）也叫做桥接模式，是一个比较简单的模式。</p><p>定义：</p><p>将抽象和实现解耦，使得两者可以独立地变化。<br><a id="more"></a></p><p>通用类图：<br><img src="http://images.cnblogs.com/cnblogs_com/muzongyan/WindowsLiveWriter/d3b7abddfc3c_F852/image_thumb.png" alt=""></p><p>●　Abstraction——抽象化角色</p><p>它主要的职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。</p><p>●　Implementro——实现化角色</p><p>它是接口或者抽象类，定义角色必须的行为和属性。</p><p>●　RefinedAbstraction——修正抽象化角色</p><p>它引用实现化角色对抽象化角色进行修正。</p><p>●　ConcreteImplementor——具体实现化角色</p><p>它实现接口或抽象类定义的方法和属性。</p><p>其中imp的地方就是一个组合。Abstraction就是饮料这个例子里的杯子。，它的子类RefinedAbstraction就是杯子的大小等型号。Implementor是加的物品类类，ConcreteImplementorA和ConcreteImplementorB分别是加糖和柠檬。</p><p>整个设计模式的关键就是组合的使用。</p><p>通用代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> 实现化角色</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface Implementor</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    //</span><br><span class="line"> 基本方法</span><br><span class="line">    public void doSomething();</span><br><span class="line"> </span><br><span class="line">    public void doAnything();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> 具体实现化角色</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ConcreteImplementor1</span><br><span class="line">implements Implementor</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    public void doAnything()</span><br><span class="line"> &#123;</span><br><span class="line">        //</span><br><span class="line"> 业务处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void doSomething()</span><br><span class="line"> &#123;</span><br><span class="line">        //</span><br><span class="line"> 业务处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> 具体实现化角色</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ConcreteImplementor2</span><br><span class="line">implements Implementor</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    public void doAnything()</span><br><span class="line"> &#123;</span><br><span class="line">        //</span><br><span class="line"> 业务处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void doSomething()</span><br><span class="line"> &#123;</span><br><span class="line">        //</span><br><span class="line"> 业务处理逻辑</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> 抽象化角色</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public abstract class Abstraction</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    //</span><br><span class="line"> 定义对实现化角色的引用</span><br><span class="line">    private Implementor</span><br><span class="line"> imp;</span><br><span class="line"> </span><br><span class="line">    //</span><br><span class="line"> 约束子类必须实现该构造函数</span><br><span class="line">    public Abstraction(Implementor</span><br><span class="line"> _imp) &#123;</span><br><span class="line">        this.imp</span><br><span class="line"> = _imp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //</span><br><span class="line"> 自身的行为和属性</span><br><span class="line">    public void request()</span><br><span class="line"> &#123;</span><br><span class="line">        this.imp.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //</span><br><span class="line"> 获得实现化角色</span><br><span class="line">    public Implementor</span><br><span class="line"> getImp() &#123;</span><br><span class="line">        return this.imp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> 具体抽象化角色</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class RefinedAbstraction</span><br><span class="line">extends Abstraction</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    //</span><br><span class="line"> 覆写构造函数</span><br><span class="line">    public RefinedAbstraction(Implementor</span><br><span class="line"> _imp) &#123;</span><br><span class="line">        super(_imp);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //</span><br><span class="line"> 修正父类的行为</span><br><span class="line">    @Override</span><br><span class="line">    public void request()</span><br><span class="line"> &#123;</span><br><span class="line">        /*</span><br><span class="line">         *</span><br><span class="line"> 业务处理</span><br><span class="line">         */</span><br><span class="line">        super.request();</span><br><span class="line">        super.getImp().doAnything();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> 场景类</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client</span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line"> @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[]</span><br><span class="line"> args) &#123;</span><br><span class="line">        //</span><br><span class="line"> 定义一个实现化角色</span><br><span class="line">        Implementor</span><br><span class="line"> imp = new ConcreteImplementor1();</span><br><span class="line"> </span><br><span class="line">        //</span><br><span class="line"> 定义一个抽象化角色</span><br><span class="line">        Abstraction</span><br><span class="line"> abs = new RefinedAbstraction(imp);</span><br><span class="line"> </span><br><span class="line">        //</span><br><span class="line"> 执行行文</span><br><span class="line">        abs.request();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥梁模式是一个非常简单的模式，它只是使用了类间的聚合关系、继承、覆写等常用功能，但是它却提供了一个非常清晰、稳定的架构。</p><p>理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。</p><p>•抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</p><p>•实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</p><p>•脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。</p><p>桥梁模式的优点：</p><p>●　抽象和实现分离</p><p>这是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。</p><p>●　优秀的扩展能力</p><p>●　实现细节对客户透明</p><p>客户不用关心细节的实现，它已经由抽象层通过聚合关系完成了封装。</p><p>桥梁模式的使用场景：</p><p>●　不希望或不适用使用继承的场景</p><p>例如继承层次过渡、无法更细化设计颗粒等场景，需要考虑使用桥梁模式。</p><p>●　接口或抽象类不稳定的场景</p><p>明知道接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失的，也是比较失败的做法。</p><p>●　重用性要求较高的场景</p><p>设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。</p><p>桥梁模式的注意事项：</p><p>使用桥梁模式时主要考虑如何拆分抽象和实现，并不是一涉及继承就要考虑使用该模式，那还要继承干什么。</p><p>桥梁模式的意图还是对变化的封装，尽量把可能变化的因素封装到最细、最小的逻辑单元中，避免风险扩散。</p><p>系统设计时，发现类的继承有N层时，可以考虑使用桥梁模式。</p>]]></content>
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机系统原理之程序是怎么运行的</title>
      <link href="/2016/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
      <url>/2016/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B9%8B%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/53188341" target="_blank" rel="noopener">点这里</a></p><p>计算机的组成</p><p>计算机是由硬件和软件组成的，这两个部分共同协作完成程序的运行。这两部分如何协作完成程序的运行，是本系列的重点。<br><a id="more"></a></p><p><em>信息的表示</em></p><p>信息的表示说到底就是位加上下文。举个小例子，比如11011101这一串二进制，在表示整数的时候它表示221，但是如果放在Java的class文件当中，它可能代表一个JVM的指令。</p><p><em>程序的编译</em></p><p>对于一个简单的C语言程序来说，一般要经过预处理器、编译器、汇编器和链接器的处理，才能被翻译成一段可执行的二进制文件。</p><p> 比如对于一个简单的C语言程序，如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">     printf(&quot;hello,world\n&quot;);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们保存在hello.c当中，那么它的翻译过程如下。</p><p><img src="http://images.cnitblog.com/blog/558323/201309/19215446-28cd336ade294ec8a88db75092e836e8.jpg" alt=""></p><p><em>程序的运行</em> </p><p>程序的运行由解释器负责，它将逐个解释最终生成的二进制文件并执行。</p><p><em>计算机的硬件组成</em></p><p>首先，我们来看下计算机中硬件的大致分布，如下图。<br><img src="http://images.cnitblog.com/blog/558323/201309/20012001-b4516f4b8df44165abeaf329bc6865bf.jpg" alt=""></p><p> 其中有几个非常重要的部分，一一看下都是什么作用。</p><p> _总线_：贯穿整个系统的是一组电子管道（其实就是传输数据的线路），也就是总线。总线传送的是字，字的大小与系统相关，比如在32位操作系统当中，一个字是4个字节。</p><p><em>I/O设备</em>：I/O设备是系统与外部联系的通道。I/O设备（键盘、鼠标、显示器等）由控制器（USB控制器）或者适配器（图形适配器，也就是显卡）与I/O总线相连，两者的区别在于一个是主板上的芯片组，一个是主板插槽上的卡。</p><p>_主存_：它是计算机中的一个临时存储设备，在处理器执行程序的时候，主存就是临时存放数据的地方。物理上来说，它是由动态随即存取存储器芯片组成，逻辑上来说，它是一组连续的字节数组，每一个字节都有唯一的地址。</p><p><em>处理器</em>：全称中央处理单元，是解释存储在主存中指令的引擎。处理器的核心是一个程序计数器，它在整个计算机运行的期间都会指向一个主存中的一个内存地址，而地址当中则是一个计算机指令。处理器所做的，就是不停的执行程序计数器所指向的每一条指令。处理器所做的操作是围绕主存、寄存器文件以及算术/逻辑单元进行的，这里面处理器做的最多的动作就是加载（从主存将数据复制到寄存器）、存储（从寄存器将数据复制到主存）、操作（将两个寄存器的内容复制到算术/逻辑单元进行操作，结果会再次复制到寄存器）以及跳转（改变程序计数器当中的内容）。</p><p>处理器当中提到的是指令集结构，不过实际当中指令集的实现是非常复杂的，这么做的目的是为了加速CPU的运算速度。我们可以这样去区分指令集机构以及微体系结构，指令集结构是指令集的抽象描述，而微体系结构则是这个抽象描述的某一个具体实现，类似于JAVA虚拟机与JAVA虚拟机实现的关系。</p><p>总结 ：计算机是由软件与硬件组成的，而硬件又包括了总线、I/O设备、主存以及处理器，其中信息是由位以及上下文表示的，而信息则是从I/O设备以位的形式通过总线进入主存，然后由处理器从主存将信息取出处理。</p><p>一个程序的执行，是经历了预处理器、编译器、汇编器以及链接器的处理之后，才最终成为可执行的文件。当程序成为可执行文件时就已经保存在了磁盘上，具体的执行过程在下一章再总结。</p><p><em>Hello world的执行</em></p><p>我们以Linux系统为例，当我们执行一个简单的打印字符串的C程序时，我们需要在命令行输入./hello以及回车去执行该程序。在整个执行过程中，计算机主要做了三件事，或者说经历了三个阶段来完成程序的运行。</p><p>1、linux的外壳扫描用户输入的字符</p><p>当我们在键盘输入./hello时，linux的外壳程序（也就是命令行）会扫描我们输入的字符，将这些字符一一读入到寄存器当中，然后再一一放入主存。换句话说，./hello这几个字符是经过了CPU中的寄存器从而到达了主存。下面LZ将这一过程的图示画出来。</p><p><img src="http://images.cnitblog.com/blog/558323/201309/20174444-1afe1aadf42d43148d6b761c39498d5b.jpg" alt=""></p><p>2、加载hello文件的代码以及数据到主存</p><p>这一过程的触发是在我们按下回车的那一刻，此时系统会将存储在磁盘上的hello文件加载到主存，而此过程会利用一种叫做存储器存取的技术，使得数据不通过寄存器直接到达主存。下图是这一过程的图示。</p><p><img src="http://images.cnitblog.com/blog/558323/201309/20175327-764fa6dc592a4178aeb2933054bb7e6e.jpg" alt=""></p><p>3、根据主存中代码的指令执行程序</p><p>在代码以及程序所需要的数据加载到主存后，CPU就开始从main函数的起始位置，依次执行代码中的指令。由于我们的代码只是简单的输出“hello world”这样的字符串，因此系统只是将这个字符串依次加载到寄存器，然后传输到显示器终端显示。这个过程如下图。</p><p><img src="http://images.cnitblog.com/blog/558323/201309/20180058-b0eedd2bd90c419099e026688e83598f.jpg" alt=""></p><p>总结 ：本章只是简单的介绍了一下hello程序的执行过程，我们可以简单的这么理解，hello程序的执行，其实就是将数据和代码加载到主存，并由CPU从主存获取指令从而执行的过程。</p><p>原文链接：<a href="http://www.cnblogs.com/zuoxiaolong/archive/2013/09/20/computer1.html" target="_blank" rel="noopener">http://www.cnblogs.com/zuoxiaolong/archive/2013/09/20/computer1.html</a></p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nachos操作系统：Pro1.1：完成KThread.join方法</title>
      <link href="/2016/11/09/Nachos%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%AE%8C%E6%88%90KThread_join%E6%96%B9%E6%B3%95/"/>
      <url>/2016/11/09/Nachos%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%AE%8C%E6%88%90KThread_join%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/53096124" target="_blank" rel="noopener">点这里</a></p><a id="more"></a><p>##问题描述</p><blockquote><ol><li>Note that another thread does not have to call join(), but if it is called, it must be called only once.</li><li>A thread must finish executing normally whether or not it is joined.</li></ol></blockquote><p>##问题思考</p><p>###</p><p>1.KThread.join函数如果被调用也只能被调用一次，第二次调用的结果是未知的。</p><p>2.每个线程都维护自己的资源，（在Linux和Windows操作系统中，线程维护的资源存在于TCB中）换言之，每个线程拥有自己的waitJoinQueue，里面存放了由于自己的join而被阻塞无法执行的线程。</p><p>3.由于我们对每个线程添加了waitJoinQueue切里面存有在等待的线程，故而我们需要修改finish函数，在线程完成运行即将终止时检查其waitJoinQueue，唤醒队列中在等待的线程。</p><p>##解决方案<br>(1)Kthread的join()中的Lib.assertTrue(this != currentThread)已经实现线程只能调用一次join()方法，根据要求，在调用join()方法时，让当前运行线程休眠，并将当前运行的线程加入到一个阻塞队列中。<br>(2)在线程结束时，finish()函数循环唤醒所有被阻塞的线程。Finish()函数在run()函数返回时自动调用，同样可以被直接调用。但当前唯一运行的线程不能被finish()函数立即结束，只有当其他线程运行时才可结束。</p><p>##线程状态转换图<br><img src="http://img.blog.csdn.net/20161109092451299" alt="Nachos操作系统--join函数线程转换"></p><p>##实现代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void join() &#123;</span><br><span class="line">Lib.debug(dbgThread, &quot;Joining to thread: &quot; + toString());</span><br><span class="line"></span><br><span class="line">Lib.assertTrue(this != currentThread);</span><br><span class="line">   //工作</span><br><span class="line">/*if(!this.IsAlive()) return;</span><br><span class="line">while(this.IsAlive())</span><br><span class="line">&#123;</span><br><span class="line">this.joinQueue.acquire(this);</span><br><span class="line">&#125;</span><br><span class="line">this.joinQueue.waitForAccess(KThread.currentThread());</span><br><span class="line">KThread.sleep();//当前进程等待被调用的进程结束。*/</span><br><span class="line"></span><br><span class="line">/**for join method**/</span><br><span class="line">boolean intStatus = Machine.interrupt().disable(); //系统关中断</span><br><span class="line">if (status != statusFinished)</span><br><span class="line">&#123;</span><br><span class="line">waitJoinQueue.waitForAccess(currentThread); //调用另一个要调用的进程</span><br><span class="line">KThread.sleep(); //当前进程睡眠等待被调用进程结束</span><br><span class="line">&#125;</span><br><span class="line"> Machine.interrupt().enable();</span><br><span class="line">/**for join method**/</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void finish() &#123;</span><br><span class="line">Lib.debug(dbgThread, &quot;Finishing thread: &quot; + currentThread.toString());</span><br><span class="line"></span><br><span class="line">Machine.interrupt().disable();//关中断</span><br><span class="line"></span><br><span class="line">Machine.autoGrader().finishingCurrentThread();</span><br><span class="line"></span><br><span class="line">Lib.assertTrue(toBeDestroyed == null);</span><br><span class="line">toBeDestroyed = currentThread;//表明进程要结束了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">currentThread.status = statusFinished;//当前进程状态修改为运行结束。</span><br><span class="line"></span><br><span class="line">//工作开始</span><br><span class="line">KThread waitThread= currentThread.waitJoinQueue.nextThread(); //调用等待队列上的第一个进程; //调用等待队列上的第一个进程</span><br><span class="line">while (waitThread != null) //while</span><br><span class="line">&#123;</span><br><span class="line">waitThread.ready(); //唤醒等待队列上所有被阻塞的进程</span><br><span class="line">waitThread= currentThread.waitJoinQueue.nextThread(); //调用等待队列上的第一个进程</span><br><span class="line">&#125;</span><br><span class="line">sleep();</span><br><span class="line">//工作结束：</span><br><span class="line"></span><br><span class="line">//sleep();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>##测试代码及结果<img src="http://img.blog.csdn.net/20161109093055401" alt="nachos测试内部类"><br><img src="http://img.blog.csdn.net/20161109093120292" alt="Join测试方法"></p><p>###结果<br><img src="http://img.blog.csdn.net/20161109093152246" alt="Test1"></p><p>这里只测试了Test1<br>方法，<br>可以看到，实现了join方法。至此，pro1.1<br>就<br>已经全部实现了。</p><p>##需要注意的几个地方</p><p>1.join：Kthread的join()中的Lib.assertTrue(this != currentThread)已经实现线程只能调用一次join()方法。还有finish函数的调用：Finish()函数在run()函数返回时自动调用，同样可以被直接调用。但当前唯一运行的线程不能被finish()函数立即结束，finish函数的测试也花费了一些时间。<br>waitJoinQueue的初始化要求在每个线程中都得到执行，不然会爆空指针异常，后来发现是finish的if 和while循环的差别。<br>2.Joincounter静态全局变量记录join方法被调用的次数以控制其满足题目要求<br>3.一定要记得修改finish方法唤醒waitJoinQueue中等待的线程</p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
            <tag> Nachos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nachos操作系统：Pro1.3：完成Alarm类</title>
      <link href="/2016/11/07/Nachos%E6%93%8D%E4%BD%9C%E7%B3%BB_%E5%AE%8C%E6%88%90Alarm%E7%B1%BB/"/>
      <url>/2016/11/07/Nachos%E6%93%8D%E4%BD%9C%E7%B3%BB_%E5%AE%8C%E6%88%90Alarm%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/53074410" target="_blank" rel="noopener">点这里</a></p><a id="more"></a><p>##题目要求<br>1)完成Alarm类，实现waitUntil(long x)方法。<br>2)一个线程通过调用waitUntil(long x)方法将自己挂起，一直到经过x时间再被唤醒。（例如：光标的闪烁）<br>3)线程经过x时间后唤醒，但不会立刻运行，而是加入readyqueue中。</p><p>##分析<br>Alarm类使用硬件定时器提供抢占，并允许线程挂起到某个时间。分配的新闹钟设置机器的定时器中断处理程序实现本闹钟的回调，同时Nachos只在有一个计时器的情况下正常行。<br>定时器中断处理程序被称为机器计时器定期（大约每500时钟周期）。当前线程产生后，如果有另一个必须运行的线程，则强制上下文切换。<br> 当前线程睡眠至少x时间周期，在定时器中断处理程序中将其唤醒。当现在时间(current time) &gt;= (WaitUntil called time)+(x)时，线程必须被唤醒（在调度准备集）在第一个定时器中断的产生时。</p><p>##设计思路</p><ol><li>新建一个TreeSet集合：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private TreeSet&lt;WaitingThread&gt; waiting;  // +dove+</span><br></pre></td></tr></table></figure><p>2.一个线程调用waitUntill()时，该线程设定唤醒时间并阻塞，放入队列中。</p><p>3.Timer每过500个clock ticks会产生一个timeInterrupt。</p><p>4.timeInterupt时，会运行handle()线程，将handler线程设置为 将队列中此时应当唤醒的进程加入就绪队列中 即可。</p><p>##难点<br>线程调用waitUntil方法之后会终止，该线程设定唤醒时间并阻塞，直到传入的时间之后才可以执行。线程只是放入就绪队列，等待分配。可以使用一个线程队列，但是不能产生额外的线程。 </p><p>##实现</p><p>###timerInterrupt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while (!waiting.isEmpty() &amp;&amp;</span><br><span class="line">       ((WaitingThread) waiting.first()).time &lt;= time) &#123;</span><br><span class="line">//当线程到了等待的时间就把线程从队列中取出放入就绪队列</span><br><span class="line">    WaitingThread next = (WaitingThread) waiting.first();</span><br><span class="line"></span><br><span class="line">        // Move due thread to waiting thread</span><br><span class="line">        next.thread.ready();</span><br><span class="line">    waiting.remove(next);</span><br><span class="line"></span><br><span class="line">    Lib.assertTrue(next.time &lt;= time);</span><br><span class="line">         </span><br><span class="line">    Lib.debug(dbgInt, &quot;  &quot; + next.thread.getName());</span><br></pre></td></tr></table></figure><p>###waitUtil.java<br>//改变中断方式<br>    boolean intStatus = Machine.interrupt().disable(); // +dove+</p><pre><code>// 该线程设定唤醒时间并阻塞，并调用sleep操作使当前线程挂起, 放入队列中。WaitingThread toAlarm = new WaitingThread(wakeTime, KThread.currentThread());Lib.debug(dbgInt,      &quot;Wait thread &quot; + KThread.currentThread().getName() +      &quot; until &quot; + wakeTime);waiting.add(toAlarm);//TreeSet</code></pre><p>##测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void selfTest() &#123;</span><br><span class="line"></span><br><span class="line">       System.out.print(&quot;Enter Alarm.selfTest\n&quot;);</span><br><span class="line"></span><br><span class="line">   Runnable r = new Runnable() &#123;</span><br><span class="line">       public void run() &#123;</span><br><span class="line">                   KThread t[] = new KThread[10];</span><br><span class="line"></span><br><span class="line">                   for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">                        t[i] = new KThread(new AlarmTest(160 + i*100));</span><br><span class="line">                        t[i].setName(&quot;Thread&quot; + i).fork();</span><br><span class="line">                   &#125;</span><br><span class="line">                   for (int i=0; i&lt;10000; i++) &#123;</span><br><span class="line">                       KThread.yield();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       KThread t = new KThread(r);</span><br><span class="line">       t.setName(&quot;Alarm SelfTest&quot;);</span><br><span class="line">       t.fork();</span><br><span class="line">       KThread.yield();</span><br><span class="line"></span><br><span class="line">       t.join();</span><br><span class="line"></span><br><span class="line">       System.out.print(&quot;Leave Alarm.selfTest\n&quot;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>注意，这段代码实现了多个线程公用一个Alarm类。</p><p>##测试结果<img src="http://img.blog.csdn.net/20161107232932318" alt="Nachos操作系统测试结果"></p><p>时间片调度的典型应用。</p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
            <tag> Nachos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nachos操作系统：Pro1_5:实现优先级调度</title>
      <link href="/2016/10/29/Nachos%E6%93%8D%E4%BD%9C%E7%B3%BBPro1_5_%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6/"/>
      <url>/2016/10/29/Nachos%E6%93%8D%E4%BD%9C%E7%B3%BBPro1_5_%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/52960647" target="_blank" rel="noopener">点这里</a></p><a id="more"></a><h1 id="Nachos操作系统：Pro1-5-实现优先级调度"><a href="#Nachos操作系统：Pro1-5-实现优先级调度" class="headerlink" title="Nachos操作系统：Pro1_5:实现优先级调度"></a>Nachos操作系统：Pro1_5:实现优先级调度</h1><hr><p>##问题描述</p><ol><li>Change a line in nachos.conf that specifies the scheduler class to use.</li><li>You must implement the methods getPriority(), getEffectivePriority(), and setPriority().</li><li>In choosing which thread to dequeue, the scheduler should always choose a thread of the highest effective priority. If multiple threads with the same highest priority are waiting, the scheduler should choose the one that has been waiting in the queue the longest.</li><li>A partial fix for this problem is to have the waiting thread donate its priority to the low priority thread while it is holding the lock.</li><li>Be sure to implement Scheduler.getEffectivePriority(), which returns the priority of a thread after taking into account all the donations it is receiving.</li><li>The Lock class does not need to be modified.</li></ol><h2 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h2><ul><li>通过完成实现 PriorityScheduler 优先级调度策略。所有的调度程序都是继承自 Scheduler 类，所以必须实getPriority(),getEffectivePriority()和setPriority()方法。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>Nachos 系统已经提供了一个简单的轮转调度器，采用简单的 FIFO 队列进行调度。优先级调度的传统算法如下: 每个线程拥有一个优先级(在 Nachos中, 优先级是一个 0 到 7 之间的整数, 默认为 1)。在线程调度时, 调度程序选择一个拥有最高优先级的处于就绪状态的线程运行。</p></blockquote><p>解决优先级问题的关键就是优先级反转，当一个高优先级的线程等待一个低优先级的线程时，高优先级的线程就必须把自己的有效优先级捐献给低优先级的线程，让低优先级的线程提高优先级可以尽快执行。解决这个问题的关键就是计算有效优先级，但是计算时间不能太长，所以在改变优先级的时候在计算比较合适。优先级在捐献之后不会丢失。优先级可以不断传递下去。</p><p>所以首先要在线程对象中完成对线程优先级修改的函数的实现，方便后面设置修改线程优先级完成试验的测试过程。</p><h3 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>getPriority</td><td>thread - the thread to get the priority of.</td></tr><tr><td>setPriority</td><td>thread - the thread to set the priority of.                    priority - the new priority.</td></tr><tr><td>getEffectivePriority</td><td>thread - the thread to get the effective priority of.</td></tr></tbody></table><p>getEffectivePriority:</p><p>计算有效优先级时，遍历等待队列中所用线程的有效优先级，找出最大的优先级。首先要在 PriorityQueue 类下创建个装有KThread 的LinkedList,即等待队列 waitQueue,声明一个 effectivePriority,遍历waitQueue,找出 priority 最大的那个 KThread,将它的 priority 赋给effectivePriority,然后返回即可。</p><p>##实现<br>在 PriorityScheduler 类的内部类ThreadState 类里有 priority 这属性，所以实现 getPriority(),setPriority(),increasePriority(),decreasePriority()时直接对 priority 进行返回，重新赋值，修改 priority 的值。（注意getPriority(), setPriority()函数内部是先调用内部类 ThreadState 类的同名函数，然后在这些同名函数里对 priority修改。</p><p>###getEffectivePriority（）<br>该方法是实现优先级继承功能的关键。先说这个方法的功能实现。我们通过该方法获取一个线程的有效优先级（即其所属的等待队列中所有线程中最高的一个优先级数值），这个优先级将用于赋给该线程，确保该线程的运行顺利进行以避免饥饿现象。在该方法的实现过程中，首先我们遍历waitQueue(其中保存了该线程的所属的所有PriorityQueue类型的等待队列)，在其中选取一个最大的优先级赋在一个局部变量中暂时保存下来。就像之前提到的，waitQueue是一个保存PriorityQueue对象的迭代器，这意味着在我的实现中有些不属于PriorityQueue对象的等待队列无法通过对waitQueue的便利得到。可以通过把这样的队列单拉出来进行遍历，选出其中最大的一个返回作为该线程的优先级即完成了该方法的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEffectivePriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implement  on 2016/10/29 by CAO dove</span></span><br><span class="line"><span class="keyword">int</span> maxEffective =<span class="keyword">this</span>.priority;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dirty)&#123;</span><br><span class="line"><span class="comment">//迭代器遍历，加快遍历速度</span></span><br><span class="line"><span class="keyword">for</span>(Iterator&lt;ThreadQueue&gt; it =myResource.iterator();it.hasNext();)&#123;</span><br><span class="line">PriorityQueue pg = (PriorityQueue)(it.next()); </span><br><span class="line"><span class="comment">//遍历myResource(其中保存了该线程的所属的所有PriorityQueue类型的等待队列)，在其中选取一个最大的优先级赋在一个局部变量中暂时保存下来。</span></span><br><span class="line">                <span class="keyword">int</span> effective = pg.getEffectivePriority();</span><br><span class="line">                <span class="keyword">if</span> (maxEffective &lt; effective) &#123;</span><br><span class="line">                    maxEffective=effective;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果如下：<br><img src="http://img.blog.csdn.net/20161029174409564" alt="这里写图片描述"></p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
            <tag> Nachos </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>等级分布图的边界元素的处理</title>
      <link href="/2016/09/17/%E7%AD%89%E7%BA%A7%E5%88%86%E5%B8%83%E5%9B%BE%E7%9A%84%E8%BE%B9%E7%95%8C%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2016/09/17/%E7%AD%89%E7%BA%A7%E5%88%86%E5%B8%83%E5%9B%BE%E7%9A%84%E8%BE%B9%E7%95%8C%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/52564890" target="_blank" rel="noopener">点这里</a><br>《Quantifying the Visual Impact of Classification Boundaries in Choropleth Maps 》 这篇论文提出了一种新型的判断边界元素的改变对整个地图的显示影响的算法，这个文章把他提到的几个基本点整理了一下。</p><a id="more"></a><h2 id="鉴定边界元素"><a href="#鉴定边界元素" class="headerlink" title="鉴定边界元素"></a>鉴定边界元素</h2><p>簇的凝聚度和分离度并不是独立的,两者之和为一个常数,等于总平方和, 即每个样本到总均值的距离的平方和,很明显,单纯地使用凝聚度或者分离度作为聚类的有效性分析是不严谨的 。</p><p>Kaufman等人提出的轮廓系数( SilhouetteCoefficient)，结合了凝聚度和分离度 。 </p><p>针对数据集里样本d_((i)), 假设样本d_((i)) 被聚类到簇A , 其轮廓系数S_((i))定义如下:<br>S_((i))=(b_((i) )-a_((i)))/(max{b_((i) ),a_((i))})</p><p>其中，a_((i))=样本d_((i))与其同簇其他样本的平均距离；对于其他非簇A</p><p>的簇C而言，令D_(（i,C）)= 样本d_((i))与簇C中所有样本的平均距离，则</p><p>b_((i))=min¦(C≠A) {D_(（i,C）) }，假设样本与簇B中所有样本的平均距离取得该最小值。</p><p>S_((i))取值介于-1和1之间，若S_((i))接近1，则表示簇内平均距离a_((i))远小于簇间平均距离b_((i))，表示该样本适合簇A，反之，若S_((i)) 接近-1，则表示该样本更适合簇B，若S_((i)) 接近0，则表示样本极有可能被重新分类</p><h2 id="空间关联指标"><a href="#空间关联指标" class="headerlink" title="空间关联指标"></a>空间关联指标</h2><p>轮廓系数并不能指出是否改变这些元素会影响视觉上的空间关联。</p><p>莫兰指数(Moran’s I)是用来度量空间相关性的一个重要指标。他是一个有理数，经过方差归一化之后，它的值会被归一化到-1.0–1.0之间。</p><p>一般说来，莫兰指数分为全局莫兰指数（GlobalMoran’sI）和安瑟伦局部莫兰指数（AnselinLocalMoran’sI）前者是是澳大利亚统计学家帕克·莫兰提出的，后者是美国亚利桑那州立大学地理与规划学院院长LucAnselin教授在1995年提出的。</p><p>Moran’s I &gt;0表示空间正相关性，其值越大，空间相关性越明显，Moran’s I\&lt;0表示空间负相关性，其值越小，空间差异越大，否则，Moran’s I = 0，空间呈随机性。</p><p><em>Clustered（集群）</em>：任何东西与别的东西之间都是相关的，但近处的东西比远处的东西相关性更强  Moran’sI&gt;0。</p><p><em>Dispersed（散布数据）</em>：不同类在空间上是连续的,Moran’s I\&lt;0。</p><p><em>Random</em>:随机的，Moran’sI接近0</p><p>空间自相关的Moran’sI统计可表示为：<br><img src="https://img-blog.csdn.net/20160917201717997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Moran’sI"><br>其中，N等于要素总数，W_(i,j)是要素i和j之间的空间权重，∑▒i∑▒〖jW_(i,j) 〗 是所有空间权重的聚合，x ̅是要素x的属性的平均值。</p><p>例子：<br><img src="https://img-blog.csdn.net/20160917201745116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Moran’sI"><br>Fig.1. An example of k-means clustering (k=5).Boundaryelementswith a silhouette coefficient from-:1≤t≤ 0arehighlighted. Weannotate one boundaryelementwith a red circle and show therelationship between the two views.</p>]]></content>
      
      <categories>
          
          <category> 学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化 </tag>
            
            <tag> 算法设计 </tag>
            
            <tag> 地图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图像处理之K-Means算法演示</title>
      <link href="/2016/08/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8BK-Means%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA/"/>
      <url>/2016/08/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8BK-Means%E7%AE%97%E6%B3%95%E6%BC%94%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/52386684" target="_blank" rel="noopener">点这里</a></p><p>原文地址：<a href="https://blog.csdn.net/jia20003/article/details/8828648#" target="_blank" rel="noopener">点这里</a></p><p>K-meanｓ算法的解读与实现<br><a id="more"></a></p><h2 id="一：数学原理"><a href="#一：数学原理" class="headerlink" title="一：数学原理"></a>一：数学原理</h2><p>K-Means算法的作者是MacQueen， 基本的数学原理很容易理解，假设有一个像素</p><p>数据集P。我们要根据值不同将它分为两个基本的数据集合Cluster1, Cluster2，使</p><p>用K-Means算法大致如下：</p><p>假设两个Cluster的RGB值分别为112,225,244和23,34,99则像素集合中的像素点</p><p>a(222,212,234), b(198,205,229), c(25,77,52),d(34,55,101)计算每个像素点与这</p><p>两个cluster中心点的欧几里德距离，则像素点a, b属于前面一个cluster， c,d属于</p><p>后面一个cluster。然后在根据(222+198)/2, (212+205)/2, (234+52)/2更新cluster</p><p>的RGB值，对后一个cluster做同样处理。然后再计算每个像素点到cluster中心点</p><p>的欧几里德距离。最终值没有变化则得到分类Cluster点集合。</p><h2 id="二：算法基本流程"><a href="#二：算法基本流程" class="headerlink" title="二：算法基本流程"></a>二：算法基本流程</h2><p><img src="http://img.my.csdn.net/uploads/201304/20/1366451358_1138.png" alt="K-means算法流程"></p><h3 id="三：算法关键代码解析"><a href="#三：算法关键代码解析" class="headerlink" title="三：算法关键代码解析"></a>三：算法关键代码解析</h3><p>初始化cluster中心点代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfCluster; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> randomNumber1 = random.nextInt(width);</span><br><span class="line">    <span class="keyword">int</span> randomNumber2 = random.nextInt(height);</span><br><span class="line">    index = randomNumber2 * width + randomNumber1;</span><br><span class="line">    ClusterCenter cc = <span class="keyword">new</span> ClusterCenter(randomNumber1, randomNumber2, inPixels[index]);</span><br><span class="line">    cc.setcIndex(i);</span><br><span class="line">    clusterCenterList.add(cc); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化所有像素点代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create all cluster point</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; ++row)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; ++col)</span><br><span class="line">    &#123;</span><br><span class="line">    index = row * width + col;</span><br><span class="line">    <span class="keyword">int</span> color = inPixels[index];</span><br><span class="line">    pointList.add(<span class="keyword">new</span> ClusterPoint(row, col, color));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>计算两个像素点之间欧几里德距离的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int pa = (p.getPixelColor() &gt;&gt; 24) &amp; 0xff;</span></span><br><span class="line"><span class="keyword">int</span> pr = (p.getPixelColor() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">int</span> pg = (p.getPixelColor() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">int</span> pb = p.getPixelColor() &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="comment">// int ca = (c.getPixelColor() &gt;&gt; 24) &amp; 0xff;</span></span><br><span class="line"><span class="keyword">int</span> cr = (c.getPixelColor() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">int</span> cg = (c.getPixelColor() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">int</span> cb = c.getPixelColor() &amp; <span class="number">0xff</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> Math.sqrt(Math.pow((pr - cr), <span class="number">2.0</span>) + Math.pow((pg - cg), <span class="number">2.0</span>) + Math.pow((pb - cb), <span class="number">2.0</span>));</span><br></pre></td></tr></table></figure></p><p>重新计算Cluster中心点RGB值的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span>[] reCalculateClusterCenters() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear the points now</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clusterCenterList.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"> clusterCenterList.get(i).setNumOfPoints(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recalculate the sum and total of points for each cluster</span></span><br><span class="line"><span class="keyword">double</span>[] redSums = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span>[] greenSum = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span>[] blueSum = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pointList.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cIndex = (<span class="keyword">int</span>)pointList.get(i).getClusterIndex();</span><br><span class="line">clusterCenterList.get(cIndex).addPoints();</span><br><span class="line"><span class="keyword">int</span> ta = (pointList.get(i).getPixelColor() &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> tr = (pointList.get(i).getPixelColor() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> tg = (pointList.get(i).getPixelColor() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> tb = pointList.get(i).getPixelColor() &amp; <span class="number">0xff</span>;</span><br><span class="line">        ta = <span class="number">255</span>;</span><br><span class="line">redSums[cIndex] += tr;</span><br><span class="line">greenSum[cIndex] += tg;</span><br><span class="line">blueSum[cIndex] += tb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>[] oldClusterCentersColors = <span class="keyword">new</span> <span class="keyword">double</span>[clusterCenterList.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clusterCenterList.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> sum  = clusterCenterList.get(i).getNumOfPoints();</span><br><span class="line"><span class="keyword">int</span> cIndex = clusterCenterList.get(i).getcIndex();</span><br><span class="line"><span class="keyword">int</span> red = (<span class="keyword">int</span>)(greenSum[cIndex]/sum);</span><br><span class="line"><span class="keyword">int</span> green = (<span class="keyword">int</span>)(greenSum[cIndex]/sum);</span><br><span class="line"><span class="keyword">int</span> blue = (<span class="keyword">int</span>)(blueSum[cIndex]/sum);</span><br><span class="line">System.out.println(<span class="string">"red = "</span> + red + <span class="string">" green = "</span> + green + <span class="string">" blue = "</span> + blue);</span><br><span class="line"><span class="keyword">int</span> clusterColor = (<span class="number">255</span> &lt;&lt; <span class="number">24</span>) | (red &lt;&lt; <span class="number">16</span>) | (green &lt;&lt; <span class="number">8</span>) | blue;</span><br><span class="line">clusterCenterList.get(i).setPixelColor(clusterColor);</span><br><span class="line">oldClusterCentersColors[i] = clusterColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oldClusterCentersColors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四：运行效果"><a href="#四：运行效果" class="headerlink" title="四：运行效果"></a>四：运行效果</h3><p><img src="http://img.my.csdn.net/uploads/201304/20/1366451587_7079.png" alt="K-means算法运行结果"></p><h3 id="五：源代码"><a href="#五：源代码" class="headerlink" title="五：源代码"></a>五：源代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gloomyfish.segmentation.kmeans;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> com.gloomyfish.filter.study.AbstractBufferedImageOp;</span><br><span class="line"><span class="keyword">import</span> com.gloomyfish.segmentation.fuzzycmeans.ClusterPoint;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMeansProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractBufferedImageOp</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> List&lt;ClusterCenter&gt; clusterCenterList;</span><br><span class="line"><span class="keyword">private</span> List&lt;ClusterPoint&gt; pointList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numOfCluster;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KMeansProcessor</span><span class="params">(<span class="keyword">int</span> clusters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.numOfCluster = clusters;</span><br><span class="line">pointList = <span class="keyword">new</span> ArrayList&lt;ClusterPoint&gt;();</span><br><span class="line"><span class="keyword">this</span>.clusterCenterList = <span class="keyword">new</span> ArrayList&lt;ClusterCenter&gt;();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BufferedImage <span class="title">filter</span><span class="params">(BufferedImage src, BufferedImage dest)</span> </span>&#123;</span><br><span class="line"><span class="comment">// initialization the pixel data</span></span><br><span class="line">        <span class="keyword">int</span> width = src.getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = src.getHeight();</span><br><span class="line">        <span class="keyword">int</span>[] inPixels = <span class="keyword">new</span> <span class="keyword">int</span>[width*height];</span><br><span class="line">        src.getRGB( <span class="number">0</span>, <span class="number">0</span>, width, height, inPixels, <span class="number">0</span>, width );</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Create random points to use a the cluster center</span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfCluster; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> randomNumber1 = random.nextInt(width);</span><br><span class="line">    <span class="keyword">int</span> randomNumber2 = random.nextInt(height);</span><br><span class="line">    index = randomNumber2 * width + randomNumber1;</span><br><span class="line">    ClusterCenter cc = <span class="keyword">new</span> ClusterCenter(randomNumber1, randomNumber2, inPixels[index]);</span><br><span class="line">    cc.setcIndex(i);</span><br><span class="line">    clusterCenterList.add(cc); </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create all cluster point</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; ++row)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; ++col)</span><br><span class="line">            &#123;</span><br><span class="line">            index = row * width + col;</span><br><span class="line">            <span class="keyword">int</span> color = inPixels[index];</span><br><span class="line">            pointList.add(<span class="keyword">new</span> ClusterPoint(row, col, color));</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// initialize the clusters for each point</span></span><br><span class="line">        <span class="keyword">double</span>[] clusterDisValues = <span class="keyword">new</span> <span class="keyword">double</span>[clusterCenterList.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pointList.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;clusterCenterList.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">        clusterDisValues[j] = calculateEuclideanDistance(pointList.get(i), clusterCenterList.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        pointList.get(i).setClusterIndex(getCloserCluster(clusterDisValues));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// calculate the old summary</span></span><br><span class="line">        <span class="comment">// assign the points to cluster center</span></span><br><span class="line">        <span class="comment">// calculate the new cluster center</span></span><br><span class="line">        <span class="comment">// computation the delta value</span></span><br><span class="line">        <span class="comment">// stop condition--</span></span><br><span class="line">        <span class="keyword">double</span>[] oldClusterCenterColors = reCalculateClusterCenters();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        stepClusters();</span><br><span class="line">        <span class="keyword">double</span>[] newClusterCenterColors = reCalculateClusterCenters();</span><br><span class="line">        <span class="keyword">if</span>(isStop(oldClusterCenterColors, newClusterCenterColors))</span><br><span class="line">        &#123;        </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        oldClusterCenterColors = newClusterCenterColors;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//update the result image</span></span><br><span class="line">        dest = createCompatibleDestImage(src, <span class="keyword">null</span> );</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] outPixels = <span class="keyword">new</span> <span class="keyword">int</span>[width*height];       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pointList.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clusterCenterList.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ClusterPoint p = <span class="keyword">this</span>.pointList.get(j);</span><br><span class="line">                <span class="keyword">if</span> (clusterCenterList.get(i).getcIndex() == p.getClusterIndex())</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">int</span> row = (<span class="keyword">int</span>)p.getX(); <span class="comment">// row</span></span><br><span class="line">                <span class="keyword">int</span> col = (<span class="keyword">int</span>)p.getY(); <span class="comment">// column</span></span><br><span class="line">                index = row * width + col;</span><br><span class="line">                outPixels[index] = clusterCenterList.get(i).getPixelColor();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fill the pixel data</span></span><br><span class="line">        setRGB( dest, <span class="number">0</span>, <span class="number">0</span>, width, height, outPixels );</span><br><span class="line"><span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isStop</span><span class="params">(<span class="keyword">double</span>[] oldClusterCenterColors, <span class="keyword">double</span>[] newClusterCenterColors)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;oldClusterCenterColors.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"cluster "</span> + i + <span class="string">" old : "</span> + oldClusterCenterColors[i] + <span class="string">", new : "</span> + newClusterCenterColors[i]);</span><br><span class="line"><span class="keyword">if</span>(oldClusterCenterColors[i]  != newClusterCenterColors[i]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * update the cluster index by distance value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stepClusters</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// initialize the clusters for each point</span></span><br><span class="line">        <span class="keyword">double</span>[] clusterDisValues = <span class="keyword">new</span> <span class="keyword">double</span>[clusterCenterList.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pointList.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;clusterCenterList.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">        clusterDisValues[j] = calculateEuclideanDistance(pointList.get(i), clusterCenterList.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        pointList.get(i).setClusterIndex(getCloserCluster(clusterDisValues));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * using cluster color of each point to update cluster center color</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span>[] reCalculateClusterCenters() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear the points now</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clusterCenterList.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"> clusterCenterList.get(i).setNumOfPoints(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recalculate the sum and total of points for each cluster</span></span><br><span class="line"><span class="keyword">double</span>[] redSums = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span>[] greenSum = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span>[] blueSum = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pointList.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cIndex = (<span class="keyword">int</span>)pointList.get(i).getClusterIndex();</span><br><span class="line">clusterCenterList.get(cIndex).addPoints();</span><br><span class="line">    <span class="keyword">int</span> ta = (pointList.get(i).getPixelColor() &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">int</span> tr = (pointList.get(i).getPixelColor() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">int</span> tg = (pointList.get(i).getPixelColor() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">int</span> tb = pointList.get(i).getPixelColor() &amp; <span class="number">0xff</span>;</span><br><span class="line">            ta = <span class="number">255</span>;</span><br><span class="line">redSums[cIndex] += tr;</span><br><span class="line">greenSum[cIndex] += tg;</span><br><span class="line">blueSum[cIndex] += tb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>[] oldClusterCentersColors = <span class="keyword">new</span> <span class="keyword">double</span>[clusterCenterList.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clusterCenterList.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> sum  = clusterCenterList.get(i).getNumOfPoints();</span><br><span class="line"><span class="keyword">int</span> cIndex = clusterCenterList.get(i).getcIndex();</span><br><span class="line"><span class="keyword">int</span> red = (<span class="keyword">int</span>)(greenSum[cIndex]/sum);</span><br><span class="line"><span class="keyword">int</span> green = (<span class="keyword">int</span>)(greenSum[cIndex]/sum);</span><br><span class="line"><span class="keyword">int</span> blue = (<span class="keyword">int</span>)(blueSum[cIndex]/sum);</span><br><span class="line">System.out.println(<span class="string">"red = "</span> + red + <span class="string">" green = "</span> + green + <span class="string">" blue = "</span> + blue);</span><br><span class="line"><span class="keyword">int</span> clusterColor = (<span class="number">255</span> &lt;&lt; <span class="number">24</span>) | (red &lt;&lt; <span class="number">16</span>) | (green &lt;&lt; <span class="number">8</span>) | blue;</span><br><span class="line">clusterCenterList.get(i).setPixelColor(clusterColor);</span><br><span class="line">oldClusterCentersColors[i] = clusterColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> oldClusterCentersColors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clusterDisValues</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getCloserCluster</span><span class="params">(<span class="keyword">double</span>[] clusterDisValues)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> min = clusterDisValues[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> clusterIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clusterDisValues.length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(min &gt; clusterDisValues[i])</span><br><span class="line">&#123;</span><br><span class="line">min = clusterDisValues[i];</span><br><span class="line">clusterIndex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> clusterIndex;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> point</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cluster</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> distance value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculateEuclideanDistance</span><span class="params">(ClusterPoint p, ClusterCenter c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// int pa = (p.getPixelColor() &gt;&gt; 24) &amp; 0xff;</span></span><br><span class="line">    <span class="keyword">int</span> pr = (p.getPixelColor() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> pg = (p.getPixelColor() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> pb = p.getPixelColor() &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// int ca = (c.getPixelColor() &gt;&gt; 24) &amp; 0xff;</span></span><br><span class="line">    <span class="keyword">int</span> cr = (c.getPixelColor() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> cg = (c.getPixelColor() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">int</span> cb = c.getPixelColor() &amp; <span class="number">0xff</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(Math.pow((pr - cr), <span class="number">2.0</span>) + Math.pow((pg - cg), <span class="number">2.0</span>) + Math.pow((pb - cb), <span class="number">2.0</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 可视化 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL 中文插入数据乱码(问号????)</title>
      <link href="/2016/05/12/MySQL%20%E4%B8%AD%E6%96%87%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E4%B9%B1%E7%A0%81/"/>
      <url>/2016/05/12/MySQL%20%E4%B8%AD%E6%96%87%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/51384233" target="_blank" rel="noopener">点这里</a></p><p>第一步其实没有什么必要，主要是把所有的设成一个编码格式，如果页面用的是utf8，那么把文章的所有gbk改成utf8<br><a id="more"></a></p><p>将带有中文的数据插入通过java程序插入到表中,中文出现了乱码. 一开始以为是客户端连接时的字符编码不对. </p><h3 id="1-便将hibernate的datasource的URL改为如下"><a href="#1-便将hibernate的datasource的URL改为如下" class="headerlink" title="1. 便将hibernate的datasource的URL改为如下:"></a>1. 便将hibernate的datasource的URL改为如下:</h3><p><property name="url" value="jdbc:mysql://localhost:3306/database?useUnicode=true&amp;characterEncoding=gbk">(红色部分为修改后代码.) . 修改后,执行添加操作, 中文还是变成了???. </property></p><h3 id="2-执行以上方之后发现报另一个错误-ERROR-1366-HY000-Incorrect-string-value-‘’-xE0-xFC-xB8-xS4-xG3-xDA’’-for-colum"><a href="#2-执行以上方之后发现报另一个错误-ERROR-1366-HY000-Incorrect-string-value-‘’-xE0-xFC-xB8-xS4-xG3-xDA’’-for-colum" class="headerlink" title="2. 执行以上方之后发现报另一个错误: ERROR 1366 (HY000): Incorrect string value: ‘’/xE0/xFC/xB8/xS4/xG3/xDA’’ for colum"></a>2. 执行以上方之后发现报另一个错误: ERROR 1366 (HY000): Incorrect string value: ‘’/xE0/xFC/xB8/xS4/xG3/xDA’’ for colum</h3><p>n ‘’province’’ at row 1<br>于是修改数据库的配置文件: </p><p>mysql安装目录下面的my.ini文件 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default-character-set=gbk </span><br><span class="line"></span><br><span class="line">   character-set-server=gbk</span><br></pre></td></tr></table></figure></p><p>data/performance_schema目录下的: db.opt文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default-character-set=gbk   </span><br><span class="line"></span><br><span class="line">                                                                              default-ollation=gbk_chinese_ci</span><br></pre></td></tr></table></figure></p><p>   修改完成之后重启MYSQL服务器. 但又出现了 ???? . </p><h3 id="3-方法二操作失败-便认为是数据库本身字符编码设置的问题"><a href="#3-方法二操作失败-便认为是数据库本身字符编码设置的问题" class="headerlink" title="3. 方法二操作失败, 便认为是数据库本身字符编码设置的问题:"></a>3. 方法二操作失败, 便认为是数据库本身字符编码设置的问题:</h3><p>使用命令查看数据库的字符编码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;&apos;char%&apos;&apos;; </span><br><span class="line"></span><br><span class="line">+--------------------------+---------------------------------------------------- </span><br><span class="line">-----+ </span><br><span class="line">| character_set_client     | latin1 </span><br><span class="line">     | </span><br><span class="line">| character_set_connection | latin1 </span><br><span class="line">     | </span><br><span class="line">| character_set_database   | latin1 </span><br><span class="line">     | </span><br><span class="line">| character_set_filesystem | binary </span><br><span class="line">     | </span><br><span class="line">| character_set_results    | latin1 </span><br><span class="line">     | </span><br><span class="line">| character_set_server     | latin1 </span><br><span class="line">     | </span><br><span class="line">| character_set_system     | utf8 </span><br><span class="line">     | </span><br><span class="line">| character_sets_dir       | D:/Program Files/MySQL/MySQL Server 5.5/share/chars </span><br><span class="line">ets/ | </span><br><span class="line">+--------------------------+---------------------------------------------------- </span><br><span class="line">-----+</span><br></pre></td></tr></table></figure></p><p>发现数据库的编码为: latin1(MYSQL默认字符编码); </p><p>将MYSQL数据库同一设置成: gbk格式, 命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MYSQL&gt;set character_set_client = &apos;&apos;gbk&apos;&apos; ; </span><br><span class="line"></span><br><span class="line">MYSQL&gt;set character_set_connection = &apos;&apos;gbk&apos;&apos; ; </span><br><span class="line"></span><br><span class="line">MYSQL&gt;set character_set_results= &apos;&apos;gbk&apos;&apos; ; </span><br><span class="line"></span><br><span class="line">MYSQL&gt;set character_set_server= &apos;&apos;gbk&apos;&apos; ;</span><br></pre></td></tr></table></figure></p><p>完成之后,执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;&apos;char%&apos;&apos;; </span><br><span class="line">+--------------------------+---------------------------------------------------- </span><br><span class="line">-----+ </span><br><span class="line">| Variable_name            | Value </span><br><span class="line">     | </span><br><span class="line">+--------------------------+---------------------------------------------------- </span><br><span class="line">-----+ </span><br><span class="line">| character_set_client     | gbk </span><br><span class="line">     | </span><br><span class="line">| character_set_connection | gbk </span><br><span class="line">     | </span><br><span class="line">| character_set_database   | gbk </span><br><span class="line">     | </span><br><span class="line">| character_set_filesystem | binary </span><br><span class="line">     | </span><br><span class="line">| character_set_results    | gbk </span><br><span class="line">     | </span><br><span class="line">| character_set_server     | gbk </span><br><span class="line">     | </span><br><span class="line">| character_set_system     | utf8 </span><br><span class="line">     | </span><br><span class="line">| character_sets_dir       | D:/Program Files/MySQL/MySQL Server 5.5/share/chars </span><br><span class="line">ets/ |</span><br></pre></td></tr></table></figure></p><p>然后修改对应的数据表的字符编码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table map_data modify province varchar(32) character set gbk;</span><br></pre></td></tr></table></figure></p><p>完成以上步骤之后.终于OK啦. </p><p>总结以上步骤: </p><p>1.设置客户端地连接编码格式. (命令: set names ‘’gbk’’) </p><ol start="2"><li>修改数据库的配置文件 </li><li>使用命令统一一下数据库的字符编码.</li></ol><p>我就是按照这篇文章改的。</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 软件安装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件操作--不断更新</title>
      <link href="/2016/05/04/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2016/05/04/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/51314590" target="_blank" rel="noopener">点这里</a></p><p>写给自己，文件操作方法太多，希望固定几种方法，以免每次要用都要谷歌。<br><a id="more"></a></p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>##打开文件，读取字符串：##</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt; </span><br><span class="line">#include &lt;string&gt; </span><br><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">ifstream ifs(&quot;test.txt&quot;); // 改成你要打开的文件 </span><br><span class="line">streambuf* old_buffer = cin.rdbuf(ifs.rdbuf()); </span><br><span class="line"></span><br><span class="line">string read; </span><br><span class="line">while(cin &gt;&gt; read) // 逐词读取方法</span><br><span class="line">cout &lt;&lt; read; </span><br><span class="line">cin.rdbuf(old_buffer); // 修复buffer</span><br></pre></td></tr></table></figure><h2 id="读取int类型"><a href="#读取int类型" class="headerlink" title="读取int类型"></a>读取int类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">freopen(&quot;in2.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">   for(i=0; i&lt;10000; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">       arr[i]=a;</span><br><span class="line">       Insert(a);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>##string转int##</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// int sprintf( char *buffer, const char *format, [ argument] … );</span><br><span class="line"> //参数列表</span><br><span class="line"> // buffer：char型指针，指向将要写入的字符串的缓冲区。</span><br><span class="line"> // format：格式化字符串。</span><br><span class="line"> // [argument]...：可选参数，可以是任何类型的数据。</span><br><span class="line"> // 返回值：字符串长度（strlen）</span><br><span class="line"></span><br><span class="line"> int aa = 30;</span><br><span class="line"> char c[8]; </span><br><span class="line"> int length = sprintf(c, &quot;%05X&quot;, aa); </span><br><span class="line"> cout&lt;&lt;c&lt;&lt;endl; // 0001E</span><br></pre></td></tr></table></figure><p>###方法2###</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int aa = 30;</span><br><span class="line"> stringstream ss;</span><br><span class="line"> ss&lt;&lt;aa; </span><br><span class="line"> string s1 = ss.str();</span><br><span class="line"> cout&lt;&lt;s1&lt;&lt;endl; // 30</span><br><span class="line"></span><br><span class="line"> string s2;</span><br><span class="line"> ss&gt;&gt;s2;</span><br><span class="line"> cout&lt;&lt;s2&lt;&lt;endl; // 30</span><br></pre></td></tr></table></figure><p>###string转int###</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;17&quot;;</span><br><span class="line"></span><br><span class="line"> stringstream ss;</span><br><span class="line"> ss&lt;&lt;s;</span><br><span class="line"></span><br><span class="line"> int i;</span><br><span class="line"> ss&gt;&gt;i;</span><br><span class="line"> cout&lt;&lt;i&lt;&lt;endl; // 17</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件操作 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>世界是自己的，与他人毫无关系--杨绛</title>
      <link href="/2016/05/01/%E6%9D%A8%E7%BB%9B/"/>
      <url>/2016/05/01/%E6%9D%A8%E7%BB%9B/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/51288753" target="_blank" rel="noopener">点这里</a></p><p>有说这篇文章不是杨绛先生的作品的，但是里面还是有内容的，我们常说过来人能让我们少走弯路，那么杨绛先生走过人生100年所发出的感悟，该会带给我们很多思考吧。当你因为外界而忘记了努力的方向的时候，我希望你回来看看这篇文章。靠谱也许不是所谓的大义凛然的去改变世界，而是不让世界的浑浊改变了自己，不让世界的喧嚣扰乱了自己的判断。</p><a id="more"></a><p>【世界是自己的，与他人毫无关系】</p><p>《一百岁感言》 杨绛</p><p>我今年一百岁，已经走到了人生的边缘，我无法确知自己还能走多远，寿命是不由自主的，但我很清楚我快“回家”了。</p><p>我得洗净这一百年沾染的污秽回家。 我没有“登泰山而小天下”之感，只在自己的小天地里过平静的生活。细想至此，我心静如水，我该平和地迎接每一天，准备回家。</p><p>在这物欲横流的人世间，人生一世实在是够苦。你存心做一个与世无争的老实人吧，人家就利用你欺侮你。你稍有才德品貌，人家就嫉妒你排挤你。 你大度退让，人家就侵犯你损害你。你要不与人争，就得与世无求，同时还要维持实力准备斗争。你要和别人和平共处，就先得和他们周旋，还得准备随时吃亏。</p><p>少年贪玩，青年迷恋爱情，壮年汲汲于成名成家，暮年自安于自欺欺人。</p><p>人寿几何，顽铁能炼成的精金，能有多少？但不同程度的锻炼，必有不同程度的成绩；不同程度的纵欲放肆，必积下不同程度的顽劣。</p><p>上苍不会让所有幸福集中到某个人身上，得到爱情未必拥有金钱；拥有金钱未必得到快乐；得到快乐未必拥有健康；拥有健康未必一切都会如愿以偿。</p><p>保持知足常乐的心态才是淬炼心智，净化心灵的最佳途径。一切快乐的享受都属于精神，这种快乐把忍受变为享受，是精神对于物质的胜利，这便是人生哲学。</p><p>一个人经过不同程度的锻炼，就获得不同程度的修养、不同程度的效益。好比香料，捣得愈碎，磨得愈细，香得愈浓烈。我们曾如此渴望命运的波澜，到最后才发现：人生最曼妙的风景，竟是内心的淡定与从容……我们曾如此期盼外界的认可，到最后才知道：世界是自己的，与他人毫无关系。</p>]]></content>
      
      <categories>
          
          <category> 我的心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图的强连通性：Korasaju算法实现</title>
      <link href="/2016/04/10/%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E6%80%A7_Korasaju%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2016/04/10/%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E6%80%A7_Korasaju%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/51112867" target="_blank" rel="noopener">点这里</a></p><p>有向图的强连通性算法是深度优先搜索的一个经典应用。许多针对有向图的算法都是由此种分解操作开始的。</p><a id="more"></a><p>#目录</p><p>[TOC]</p><h2 id="强连通性："><a href="#强连通性：" class="headerlink" title="强连通性："></a>强连通性：</h2><p>如果有向图中的任意两顶点互相可到达，则该图是强连通的。</p><p>有向图强连通性的概念和性质：</p><p>1.称有向图G =(V , E) 顶点v  ,w∈V是等价的， 要么v = w； 要么从 v 到 w 有一条有向路 ，并且从 w 到 v 也有一条有向路<br>2.设 Ei(1≤i≤r) 是头、 尾均在Vi 中的边集, 则Gi =(Vi, Ei ) 称为 G的一个强连通分量， 简称强分量、强支。<br>3.对于有向图， 在其每一个强连通分量中， 任何两个顶点都是可达的。 vG，与v可相互到达的所有顶点就是包含v的强连通分量的所有顶点<br>4.设从v可到达(以v为起点的所有有向路径的终点)的顶点集合为T1(G)，而到达v(以v为终点的所有有向路径的起点)的顶点集合为T2(G)，则包含v的强连通分量的顶点集合是：T1(G)∩T2(G)<br>5.性质定理：<br>一个有向图是强连通的。当且仅当G中有一个回路。他至少包含每个顶点各一次。</p><h2 id="求有向图强连通分支的算法—Korasaju算法"><a href="#求有向图强连通分支的算法—Korasaju算法" class="headerlink" title="求有向图强连通分支的算法—Korasaju算法"></a>求有向图强连通分支的算法—Korasaju算法</h2><p>输入：有向图G<br>输出：有向图的强连通分量（森林的孩子-兄弟表示）</p><p>算法步骤：<br>1.深度优先遍历G（起点如何选择无所谓），并计算出每个顶点U的结束时间dfn[u];<br>2.深度优先遍历G的转置（反向）图GT,选择遍历起点时，按照顶点结束时间从大到小进行。遍历过程中，一边遍历，一边给顶点做分类标记，每找到一个新的起点，分类标记就加1；<br>3.第二步中产生的标记值相同的顶点构成深度优先森林中的一棵树，也即一个强连通分量</p><p><img src="https://img-blog.csdn.net/20160410144611418?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="求有向图强连通分支的示例"><br>求有向图强连通分支的Korasaju算法实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 按弧的正向搜索， 起点如何选择无所谓 */</span></span><br><span class="line"><span class="keyword">int</span> in_order[MAX_VEX] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(OLGraph *G <span class="keyword">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123; ArcNode *p ;</span><br><span class="line">Count=<span class="number">0</span> ;</span><br><span class="line">visited[v]=TRUE ;</span><br><span class="line"><span class="keyword">for</span> (p=G-&gt;xlist[v] .firstout ; p!=<span class="literal">NULL</span> ; p=p .firstout ; p!=<span class="literal">NULL</span> ; p=p-&gt;tlink)</span><br><span class="line"><span class="keyword">if</span> (!visited[p-&gt;headvex])</span><br><span class="line">DFS(G p , p-&gt;headvex) ;</span><br><span class="line">in_order[count++]=v ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 对图G按弧的逆向进行搜索 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rev_DFS</span><span class="params">(OLGraph *G , <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123; ArcNode *p ;</span><br><span class="line">visited[v]=TRUE ;</span><br><span class="line"><span class="built_in">printf</span>(“%d” , v) ; <span class="comment">/* 输出顶点 */</span></span><br><span class="line"><span class="keyword">for</span> (p=G-&gt;xlist[v].firstin ; p!=<span class="literal">NULL</span> ; p=p-&gt;hlink)</span><br><span class="line"><span class="keyword">if</span> (!visited[p-&gt;tailvex])</span><br><span class="line">Rev_DFS(G , p-&gt;tailvex) ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> Strongly_Connected_ <span class="title">Component</span><span class="params">(OLGraph *G)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span> k=<span class="number">1</span>, v, j ;</span><br><span class="line"><span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;vexnum; v++) visited[v]=FALSE ;</span><br><span class="line"><span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;vexnum; v++) <span class="comment">/* 对图G正向遍历 */</span></span><br><span class="line"><span class="keyword">if</span> (!visited[v]) DFS(G, v) ;</span><br><span class="line"><span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;vexnum; v++)visited[v]=FALSE ;</span><br><span class="line"><span class="keyword">for</span> (j=G-&gt;vexnum<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123; <span class="comment">/* 对图G逆向遍历 */</span></span><br><span class="line">v=in_order[j] ;</span><br><span class="line"><span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(“\n第%d个连通分量顶点:”, k++) ;</span><br><span class="line">Rev_DFS(G, v) ；</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Korasaju算法复杂度分析："><a href="#Korasaju算法复杂度分析：" class="headerlink" title="Korasaju算法复杂度分析："></a>Korasaju算法复杂度分析：</h2><p>跟深度优先搜索的复杂度相同：O(|V|+|E|)。<br>其他求有向图强连通性的算法：<br>Tarjan算法（与关节点算法似）<br>Gabow算法。</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法设计 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>无向图的双连通性</title>
      <link href="/2016/04/08/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
      <url>/2016/04/08/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/51098128" target="_blank" rel="noopener">点这里</a></p><p>无向图的双连通性</p><a id="more"></a><p>#目录</p><p>[TOC]</p><h2 id="无向图的双连通性"><a href="#无向图的双连通性" class="headerlink" title="无向图的双连通性"></a>无向图的双连通性</h2><ul><li><strong>相关概念</strong></li><li>关节点：若在删去顶点a以及与之相邻的边之后，图G被分割成两个或<br>两个以上的连通分量，则顶点a为连通无向图的关节点<br><img src="http://img.blog.csdn.net/20160408161639206" alt="删除a或者c之后，a,c是关节点"></li><li>双连通图：没有关节点的连通图称为双连通图（ <em>Biconnected Graph</em>） 。</li><li>等价边集：称连通图G=(V, E)的边e1 和 e2 是等价的，若 e1=e2 或者有一条环路包含 e1又包含 e2 。</li><li>双连通分量：设 Vi是等价边集 Ei 中各边所连接的顶点集（ 1≤i≤k） , 每个图Gi = ( Vi, Ei ) 叫做 G 的一个双连通分量。</li><li>在双连通图上, 任何一对顶点之间至少存在有两条路径，在删<br>去某个顶点及与该顶点相关联的边时, 也不破坏图的连通性。</li><li>双连通的无向图是连通的，但连通的无向图未必双连通。<br>-如果连通图不是双连通图，则它可以包括几个双连通分量。</li><li><strong>关节点性质</strong></li><li>由关节点可以判断图是否双联通</li><li>由<strong>深度优先生成树</strong>可得出两类关节点的特性：</li><li>第一类关节点：若生成树的根有<em>两株或两株以上子树</em>， 则此根结点必为关节（ 第一类关节点） 。 因为图中不存在连接不同子树中顶点的边， 因此， 若删去根顶点， 生成树变成生成森林。</li><li>第二类关节点：若生成树中非叶顶点v，其某株子树的根和子树中的其它结点均没有指向v 的祖先的回退边，则v 是关节点（ 第二类关节点）。因为删去v，则其子树和图的其它部分被分割开来。</li><li><img src="http://img.blog.csdn.net/20160408162906449" alt="无回退边"></li></ul><hr><h2 id="R-Tarjan算法–求关节点的算法"><a href="#R-Tarjan算法–求关节点的算法" class="headerlink" title="R.Tarjan算法–求关节点的算法"></a>R.Tarjan算法–求关节点的算法</h2><ol><li>计算先深编号： 对图进行先深搜索， 计算每个结点v的先深编号dfn[v]，形成先深生成树S=(V,T)。</li><li>计算low[v]：在先深生成树上按后根遍历顺序进行计算每个顶点v的 low[v] ， low[v]取下述三个结点中的最小者：<br>  dfn[v]；<br>  dfn[w]， 凡是有回退边(v,w)的任何结点w；<br>  low[y]，对v的任何儿子y。<br>  <em>若某个顶点V，存在孩子结点y，且low[y]&gt;=dfn[v],则v必为关节点。因为此时表明，y及其子孙均无指向V的祖先的回退边</em><br>3.求关节点：<br>3.1 树根是关节点，当且仅当它有两个或两个以上的儿子(第一类关节点)；<br>3.2 非树根结点v是关节点当且仅当v有某个儿子y，使low[y]≥dfn[v] (第二类关节点)<br><strong>时间复杂度：O（n+e）</strong></li><li>示例：<br><em>注：连通图：G=(V,E)，先深生成树：S=(V,T),回退边之集：B</em><br>按后根遍历顺序计算low[v]编号和求关节点<br><img src="http://img.blog.csdn.net/20160408164453268" alt="一个示例"><br>结论：<br>1.根结点a有两个孩子，是关节点；<br>2.(c, f)是树边即f是c的孩子且low[f] ≥ dnf[c]，所以c是关节点。</li><li>求关节点的R.Tarjan算法实现—同先深搜索算法</li></ol><p>##代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void FindArticul(AdjGraph G)</span><br><span class="line">&#123; </span><br><span class="line">/*连通图G 以邻接表作存储结构，查找并输出G 上全部关节点*/</span><br><span class="line">count=1; /*全局变量count 用于对访问计数*/</span><br><span class="line">dfn[0] =1; /*设定邻接表上0 号顶点为生成树的根*/</span><br><span class="line">for(i=1;i&lt;G.n;++i) dfn[i]=0; /*其余顶点尚未访问， dfn[]兼职visited[]*/</span><br><span class="line">p=G.vexlist[0].firstedge; v=p-&gt;adjvex;</span><br><span class="line">DFSArticul(v); /*从顶点v 出发深度优先查找关节点**/</span><br><span class="line">if(count&lt;G.n) &#123; </span><br><span class="line">/*生成树的根至少有两棵子树*/</span><br><span class="line">cout&lt;&lt;G.vexlist[0].vertex); /*根是关节点，输出*/</span><br><span class="line">while(p-&gt;next) &#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">v p =p-&gt;adjve ; x;</span><br><span class="line">if(dfn[v]==0) DFSArticul(v);</span><br><span class="line">&#125;//while</span><br><span class="line">&#125;//if</span><br><span class="line">&#125; //FindArticul</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void DFSArticul(int v0)</span><br><span class="line">/*从顶点v0 出发深度优先遍历图G，计算low[]，查找并输出关节点 */</span><br><span class="line">&#123; dnf[v0]=min=count++; /*v0 是第count 个访问的顶点*/</span><br><span class="line">for(p=G.vexlist[v0].firstedge; p; p=p-&gt;next) /*对v0 的每个邻接点检查*/</span><br><span class="line">&#123; w=p-&gt;adjvex; /*w 为v0 的邻接点*/</span><br><span class="line">if(dnf[w]==0) /*若w 未曾访问，则w 为v0 的孩子*/</span><br><span class="line">&#123; DFSArticul(w); /*返回前求得low[w]*/</span><br><span class="line">if(low[w]&lt;min) min=low[w];</span><br><span class="line">if(low[w]&gt;=dfn[v0])</span><br><span class="line">cout&lt;&lt;G vexlist[v0] vertex); / .vexlist[v0].vertex); /*输出关节点*/</span><br><span class="line">&#125;</span><br><span class="line">else if(dfn[w]&lt;min) min=dfn[w];</span><br><span class="line">/*w 已访问， w 是v0 在生成树上的祖先*/</span><br><span class="line">&#125;//for</span><br><span class="line">low[v0]=min;</span><br><span class="line">&#125;//DFSArticul</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法设计 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小生成树——Kruskal算法</title>
      <link href="/2016/04/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Kruskal%E7%AE%97%E6%B3%95/"/>
      <url>/2016/04/06/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Kruskal%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/51074287" target="_blank" rel="noopener">点这里</a></p><p>最小生成树算法</p><a id="more"></a><p>1，<strong>问题描述</strong></p><p><em>设G=(V,E)是无向连通带权图，如果G的一个子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树的各边权的总和称为该生成树的耗费,求在G的所有生成树中耗费最小的最小生成树。</em><br>2，<strong>算法思想</strong><br>（1）将代价树中权值非0的所有的边进行小顶堆排序，依次存入到road[]数组中，然后将road[]进行倒置，注意在进行排序时，按照road[i]的权值进行排序，然后记录这条边的起始顶点也要相对应。<br>（2）从最小边开始扫描各边，并检测当前所选边的加入是否会构成回路，如果不会构成回路，则将该边并入到最小生成树中。<br>（3）不断重复步骤2，直到所有的边都检测完为止。<br>其中判断当前检测边的加入是否会使原来生成树构成回路的算法思想是：<br>  （1）采用树的双亲存储结构，即数组v[i]的值表示编号为i的顶点的父结点编号。并将数组v[]初始化为v[i]=i；<br>  （2）若当前要并入的边起点为a，终点为b，需要判断起点a是否被修改过，即a!=v[a]，若已被修改过，就要修改终点v[b]的值,使v[b]=a，即结点b的父结点为a。<br>  （3）若当前检测的边结点起点为a，终点为b，则判断该边是否能被加入的方法是：分别访问a，b的根结点（a，b的父结点有可能还有父结点），若a，b的根结点相同，则不可以并入，否则可以将该边并入。</p><p>  3.<strong>实现代码</strong></p><p><em>注：部分代码来自图书《大话数据结构》</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;    </span><br><span class="line">#include &quot;stdlib.h&quot;   </span><br><span class="line">#include &quot;io.h&quot;  </span><br><span class="line">#include &quot;math.h&quot;  </span><br><span class="line">#include &quot;time.h&quot;</span><br><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="line"></span><br><span class="line">#define MAXEDGE 20</span><br><span class="line">#define MAXVEX 20</span><br><span class="line">#define INFINITY 65535</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int arc[MAXVEX][MAXVEX];</span><br><span class="line">int numVertexes, numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int begin;</span><br><span class="line">int end;</span><br><span class="line">int weight;</span><br><span class="line">&#125;Edge;   /* 对边集数组Edge结构的定义 */</span><br><span class="line"></span><br><span class="line">/* 构件图 */</span><br><span class="line">void CreateMGraph(MGraph *G)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">/* printf(&quot;请输入边数和顶点数:&quot;); */</span><br><span class="line">G-&gt;numEdges=15;</span><br><span class="line">G-&gt;numVertexes=9;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</span><br><span class="line">&#123;</span><br><span class="line">for ( j = 0; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (i==j)</span><br><span class="line">G-&gt;arc[i][j]=0;</span><br><span class="line">else</span><br><span class="line">G-&gt;arc[i][j] = G-&gt;arc[j][i] = INFINITY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G-&gt;arc[0][1]=10;</span><br><span class="line">G-&gt;arc[0][5]=11; </span><br><span class="line">G-&gt;arc[1][2]=18; </span><br><span class="line">G-&gt;arc[1][8]=12; </span><br><span class="line">G-&gt;arc[1][6]=16; </span><br><span class="line">G-&gt;arc[2][8]=8; </span><br><span class="line">G-&gt;arc[2][3]=22; </span><br><span class="line">G-&gt;arc[3][8]=21; </span><br><span class="line">G-&gt;arc[3][6]=24; </span><br><span class="line">G-&gt;arc[3][7]=16;</span><br><span class="line">G-&gt;arc[3][4]=20;</span><br><span class="line">G-&gt;arc[4][7]=7; </span><br><span class="line">G-&gt;arc[4][5]=26; </span><br><span class="line">G-&gt;arc[5][6]=17; </span><br><span class="line">G-&gt;arc[6][7]=19; </span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; G-&gt;numVertexes; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(j = i; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;arc[j][i] =G-&gt;arc[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 交换权值 以及头和尾 */</span><br><span class="line">void Swapn(Edge *edges,int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">int temp;</span><br><span class="line">temp = edges[i].begin;</span><br><span class="line">edges[i].begin = edges[j].begin;</span><br><span class="line">edges[j].begin = temp;</span><br><span class="line">temp = edges[i].end;</span><br><span class="line">edges[i].end = edges[j].end;</span><br><span class="line">edges[j].end = temp;</span><br><span class="line">temp = edges[i].weight;</span><br><span class="line">edges[i].weight = edges[j].weight;</span><br><span class="line">edges[j].weight = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 对权值进行排序 */</span><br><span class="line">void sort(Edge edges[],MGraph *G)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">for ( i = 0; i &lt; G-&gt;numEdges; i++)</span><br><span class="line">&#123;</span><br><span class="line">for ( j = i + 1; j &lt; G-&gt;numEdges; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (edges[i].weight &gt; edges[j].weight)</span><br><span class="line">&#123;</span><br><span class="line">Swapn(edges, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;权排序之后的为:\n&quot;);</span><br><span class="line">for (i = 0; i &lt; G-&gt;numEdges; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;(%d, %d) %d\n&quot;, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 查找连线顶点的尾部下标 */</span><br><span class="line">int Find(int *parent, int f)</span><br><span class="line">&#123;</span><br><span class="line">while ( parent[f] &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">f = parent[f];</span><br><span class="line">&#125;</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 生成最小生成树 */</span><br><span class="line">void MiniSpanTree_Kruskal(MGraph G)</span><br><span class="line">&#123;</span><br><span class="line">int i, j, n, m;</span><br><span class="line">int k = 0;</span><br><span class="line">int parent[MAXVEX];/* 定义一数组用来判断边与边是否形成环路 */</span><br><span class="line"></span><br><span class="line">Edge edges[MAXEDGE];/* 定义边集数组,edge的结构为begin,end,weight,均为整型 */</span><br><span class="line"></span><br><span class="line">/* 用来构建边集数组并排序********************* */</span><br><span class="line">for ( i = 0; i &lt; G.numVertexes-1; i++)</span><br><span class="line">&#123;</span><br><span class="line">for (j = i + 1; j &lt; G.numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (G.arc[i][j]&lt;INFINITY)</span><br><span class="line">&#123;</span><br><span class="line">edges[k].begin = i;</span><br><span class="line">edges[k].end = j;</span><br><span class="line">edges[k].weight = G.arc[i][j];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(edges, &amp;G);</span><br><span class="line">/* ******************************************* */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; G.numVertexes; i++)</span><br><span class="line">parent[i] = 0;/* 初始化数组值为0 */</span><br><span class="line"></span><br><span class="line">printf(&quot;打印最小生成树：\n&quot;);</span><br><span class="line">for (i = 0; i &lt; G.numEdges; i++)/* 循环每一条边 */</span><br><span class="line">&#123;</span><br><span class="line">n = Find(parent,edges[i].begin);</span><br><span class="line">m = Find(parent,edges[i].end);</span><br><span class="line">if (n != m) /* 假如n与m不等，说明此边没有与现有的生成树形成环路 */</span><br><span class="line">&#123;</span><br><span class="line">parent[n] = m;/* 将此边的结尾顶点放入下标为起点的parent中。 */</span><br><span class="line">/* 表示此顶点已经在生成树集合中 */</span><br><span class="line">printf(&quot;(%d, %d) %d\n&quot;, edges[i].begin, edges[i].end, edges[i].weight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">MGraph G;</span><br><span class="line">CreateMGraph(&amp;G);</span><br><span class="line">MiniSpanTree_Kruskal(G);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法设计 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小生成树Prim算法理解</title>
      <link href="/2016/04/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prim%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
      <url>/2016/04/05/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91Prim%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/51069178" target="_blank" rel="noopener">点这里</a><br>MST（Minimum Spanning Tree，最小生成树）问题有两种通用的解法，Prim算法就是其中之一，它是从点的方面考虑构建一颗MST，大致思想是：设图G顶点集合为U，首先任意选择图G中的一点作为起始点a，将该点加入集合V，再从集合U-V中找到另一点b使得点b到V中任意一点的权值最小，此时将b点也加入集合V；以此类推，现在的集合V={a，b}，再从集合U-V中找到另一点c使得点c到V中任意一点的权值最小，此时将c点加入集合V，直至所有顶点全部被加入V，此时就构建出了一颗MST。因为有N个顶点，所以该MST就有N-1条边，每一次向集合V中加入一个点，就意味着找到一条MST的边。<br><a id="more"></a></p><p>用图示和代码说明：</p><p>初始状态：<br><img src="https://img-blog.csdn.net/20140816180420993" alt="Prim算法初始状态"></p><p>设置2个数据结构：</p><p>lowcost[i]:表示以i为终点的边的最小权值,当lowcost[i]=0说明以i为终点的边的最小权值=0,也就是表示i点加入了MST</p><p>mst[i]:表示对应lowcost[i]的起点，即说明边&lt;mst[i],i&gt;是MST的一条边，当mst[i]=0表示起点i加入MST</p><p>我们假设V1是起始点，进行初始化（*代表无限大，即无通路）：</p><p>lowcost[2]=6，lowcost[3]=1，lowcost[4]=5，lowcost[5]=<em>，lowcost[6]=</em></p><p>mst[2]=1，mst[3]=1，mst[4]=1，mst[5]=1，mst[6]=1，（所有点默认起点是V1）</p><p>明显看出，以V3为终点的边的权值最小=1，所以边&lt;mst[3],3&gt;=1加入MST</p><p><img src="https://img-blog.csdn.net/20140816181809296" alt="Prim算法第一步状态"></p><p>此时，因为点V3的加入，需要更新lowcost数组和mst数组：</p><p>lowcost[2]=5，lowcost[3]=0，lowcost[4]=5，lowcost[5]=6，lowcost[6]=4</p><p>mst[2]=3，mst[3]=0，mst[4]=1，mst[5]=3，mst[6]=3</p><p>明显看出，以V6为终点的边的权值最小=4，所以边&lt;mst[6],6&gt;=4加入MST<br><img src="https://img-blog.csdn.net/20140816182214390" alt="Prim算法第二步状态"></p><p>此时，因为点V6的加入，需要更新lowcost数组和mst数组：</p><p>lowcost[2]=5，lowcost[3]=0，lowcost[4]=2，lowcost[5]=6，lowcost[6]=0</p><p>mst[2]=3，mst[3]=0，mst[4]=6，mst[5]=3，mst[6]=0</p><p>明显看出，以V4为终点的边的权值最小=2，所以边&lt;mst[4],4&gt;=4加入MST</p><p><img src="https://img-blog.csdn.net/20140816182451906" alt="Prim算法第三步状态"></p><p>此时，因为点V4的加入，需要更新lowcost数组和mst数组：</p><p>lowcost[2]=5，lowcost[3]=0，lowcost[4]=0，lowcost[5]=6，lowcost[6]=0</p><p>mst[2]=3，mst[3]=0，mst[4]=0，mst[5]=3，mst[6]=0</p><p>明显看出，以V2为终点的边的权值最小=5，所以边&lt;mst[2],2&gt;=5加入MST</p><p><img src="https://img-blog.csdn.net/20140816182846179" alt="Prim算法第四步状态"></p><p>此时，因为点V2的加入，需要更新lowcost数组和mst数组：</p><p>lowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=3，lowcost[6]=0</p><p>mst[2]=0，mst[3]=0，mst[4]=0，mst[5]=2，mst[6]=0</p><p>很明显，以V5为终点的边的权值最小=3，所以边&lt;mst[5],5&gt;=3加入MST</p><p>lowcost[2]=0，lowcost[3]=0，lowcost[4]=0，lowcost[5]=0，lowcost[6]=0</p><p>mst[2]=0，mst[3]=0，mst[4]=0，mst[5]=0，mst[6]=0</p><p>至此，MST构建成功，如图所示：<br><img src="https://img-blog.csdn.net/20140816183241396" alt="Prim算法最后状态"></p><p>根据上面的过程，可以容易的写出具体实现代码如下（cpp）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXCOST 0x7fffffff  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> graph[MAX][MAX];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> graph[][MAX], <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> lowcost[MAX];  </span><br><span class="line">    <span class="keyword">int</span> mst[MAX];  </span><br><span class="line">    <span class="keyword">int</span> i, j, min, minid, sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        lowcost[i] = graph[<span class="number">1</span>][i];  </span><br><span class="line">        mst[i] = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mst[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        min = MAXCOST;  </span><br><span class="line">        minid = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= n; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] &lt; min &amp;&amp; lowcost[j] != <span class="number">0</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                min = lowcost[j];  </span><br><span class="line">                minid = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"V"</span> &lt;&lt; mst[minid] &lt;&lt; <span class="string">"-V"</span> &lt;&lt; minid &lt;&lt; <span class="string">"="</span> &lt;&lt; min &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        sum += min;  </span><br><span class="line">        lowcost[minid] = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= n; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (graph[minid][j] &lt; lowcost[j])  </span><br><span class="line">            &#123;  </span><br><span class="line">                lowcost[j] = graph[minid][j];  </span><br><span class="line">                mst[j] = minid;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> sum;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, k, m, n;  </span><br><span class="line">    <span class="keyword">int</span> x, y, cost;  </span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"input.txt"</span>)</span></span>;  </span><br><span class="line">    in &gt;&gt; m &gt;&gt; n;<span class="comment">//m=顶点的个数，n=边的个数  </span></span><br><span class="line">    <span class="comment">//初始化图G  </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            graph[i][j] = MAXCOST;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//构建图G  </span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        in &gt;&gt; i &gt;&gt; j &gt;&gt; cost;  </span><br><span class="line">        graph[i][j] = cost;  </span><br><span class="line">        graph[j][i] = cost;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//求解最小生成树  </span></span><br><span class="line">    cost = prim(graph, m);  </span><br><span class="line">    <span class="comment">//输出最小权值和  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最小权值和="</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    system(<span class="string">"pause"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Input：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">10</span>  </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span>  </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span>  </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span>  </span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">3</span>  </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span>  </span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">6</span>  </span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">4</span>  </span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">2</span>  </span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>Output</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V1-V3=<span class="number">1</span>  </span><br><span class="line">V3-V6=<span class="number">4</span>  </span><br><span class="line">V6-V4=<span class="number">2</span>  </span><br><span class="line">V3-V2=<span class="number">5</span>  </span><br><span class="line">V2-V5=<span class="number">3</span>  </span><br><span class="line">最小权值和=<span class="number">15</span>  </span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络:各种时延的计算</title>
      <link href="/2016/03/14/%E5%90%84%E7%A7%8D%E6%97%B6%E5%BB%B6%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2016/03/14/%E5%90%84%E7%A7%8D%E6%97%B6%E5%BB%B6%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/50994907" target="_blank" rel="noopener">点这里</a><br>_时延_：是数据（一个报文或分组，甚至比特）从网络或链路的一段传送到另一端所需要的时间。</p><a id="more"></a><p><em>发送时延</em>：是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><p>发送时延=数据帧长度(b) /信道带宽(b/s)      [信道带宽就是数据率]</p><p><em>传播时延</em>：电磁波在信道中需要传播一定的距离而花费的时间。</p><p><em>传播时延</em>=信道长度(m)/电磁波在信道上的传播速率(m/s)</p><p><em>处理时延</em>：主机或路由器处理所收到的分组的时间。</p><p><em>排队时延</em>：分组在输入队列中排队等待处理，在输出队列中等待转发，就形成了排队时延。</p><p><em>总时延</em>=发送时延+传播时延+处理时延+排队时延</p><p>例题1：</p><p>试在下列条件下比较电路交换和分组交换。要传送的报文共x（bit）。从源点到终点共经过k段链路，每段链路的传播时延为d（s），数据率为b(b/s)。在电路交换时电路的建立时间为s(s)。在分组交换时分组长度为p(bit)，且各结点的排队等待时间可忽略不计。问在怎样的条件下，分组交换的时延比电路交换的要小？（提示：画一下草图观察k段链路共有几个结点。）</p><p>答：在电路交换中，电路的建立时延是s,报文的发送时延是x/b,报文的传播时延是：kd,故总时延为：x/b+kd+s;</p><p>在分组交换中,报文的发送时延是(x/p)<em>(p/b); K段传输中，有(k-1)次的储存转发延迟,(p/b)</em>(k-1);传播时延是kd;故总时延是：（x/p）<em>(p/b)+ (p/b)</em>(k-1)+kd=x/b+kd+(p/b)*(k-1);</p><p>当s&gt;(k-1)*(p/b)时，电路交换的时延比分组交换的时延大，当x&gt;&gt;p,相反。</p><p>例题2：</p><p>在上题的分组交换网中，设报文长度和分组长度分别为x和(p+h)(bit),其中p为分组的数据部分的长度，而h为每个分组所带的控制信息固定长度，与p的大小无关。通信的两端共经过k段链路。链路的数据率为b(b/s)，但传播时延和结点的排队时间均可忽略不计。若打算使总的时延为最小，问分组的数据部分长度p应取为多大？（提示：参考图1-12的分组交换部分，观察总的时延是由哪几部分组成。）</p><p>答：总时延：y=(x/p)<em>((p+h)/b)+(k-1)</em> ((p+h)/b)+kd</p><p>两边求导，并令其值为0得p=[(xh)/(k-1)]^0.5</p>]]></content>
      
      <categories>
          
          <category> 学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 时延 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我写数据结构排序部分的部分心得</title>
      <link href="/2016/02/14/%E6%88%91%E5%86%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%92%E5%BA%8F%E9%83%A8%E5%88%86%E7%9A%84%E9%83%A8%E5%88%86%E5%BF%83%E5%BE%97/"/>
      <url>/2016/02/14/%E6%88%91%E5%86%99%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%92%E5%BA%8F%E9%83%A8%E5%88%86%E7%9A%84%E9%83%A8%E5%88%86%E5%BF%83%E5%BE%97/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/50659816" target="_blank" rel="noopener">点这里</a><br>详细代码请参考我的上一篇博客<br><a id="more"></a><br>（一）各部分的关系图<br><img src="https://img-blog.csdn.net/20160213210735147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="BST算法流程"><br>（二）心得</p><p>这是最后一次实验,感觉难度其实并不大，学习树的时候已经自己整理过建立树与遍历的算法，而且这次实验用递归建树，代码并不难写。我觉得更考验人的是BST树递归建立的思路和删除操作对继承结点的选择，我选择用两个方法组合来实现删除，并用前序遍历和中序遍历来检验自己删除算法的正确性。</p><p>这次实验中遇到的难点是对信息的处理，包括选择学生的哪门课进行排序，排完序后如何显示学生的全部信息，最后选择了用结构体的方法来实现，也算巩固了自己对C语言的掌握。还包括对从文件中读取到的信息的分割，类似的算法在哈夫曼树中用到过，可是这次仍感觉有点棘手，因为要存储的东西太多，不像哈夫曼树，直接就把数据处理了，这次实验是要先存储后处理，然后我就尝试了很多种方法，结果都不尽如人意，每次调试结果都很令人失望。最后选择了全局变量的方法才把问题解决。</p><p>通过这四次实验，觉得自己需要努力的地方还很多，需要学习的东西更多。这几次实验告诉我不要害怕有问题 ，真正值得自己恐惧的是自己竟然想试图逃避问题而不是解决问题。有时候一个小小的问题可能需要你调试多次还需要你查各种资料，但这些都不应成为我们解决问题的阻碍，我把时间花在了这些问题上，以后再遇到就会更得心应手，就能顺利解决，所以我这四次实验逼自己面对问题，解决问题，收获真的挺多的。</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 编码 </tag>
            
            <tag> 哈弗曼树 </tag>
            
            <tag> 译码 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SOM自组织特征映射神经网络-MATLAB</title>
      <link href="/2016/02/14/%20SOM%E8%87%AA%E7%BB%84%E7%BB%87%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CMATLAB/"/>
      <url>/2016/02/14/%20SOM%E8%87%AA%E7%BB%84%E7%BB%87%E7%89%B9%E5%BE%81%E6%98%A0%E5%B0%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CMATLAB/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/52396823" target="_blank" rel="noopener">点这里</a><br>一篇转载的不错的介绍ＳＯＭ的文章</p><a id="more"></a><p>n clustering problems, you want a neural network to group data by similarity.</p><p>A self-organizing map (newsom) consists of a competitive layer which can classify a dataset of vectors with any number of dimensions into as many classes as the layer has neurons. The neurons are arranged in a 2D topology, which allows the layer to form a representation of the distribution and a two-dimensional approximation of the topology of the dataset.</p><p>The network is trained with the SOM batch algorithm (trainubwb, learnsomb).</p><p><img src="http://s9.sinaimg.cn/orignal/7671b3eb4af4c74430f38&amp;690" alt="SOM batch algorithm"></p><h2 id="神经网络创建函数"><a href="#神经网络创建函数" class="headerlink" title="神经网络创建函数"></a>神经网络创建函数</h2><p>（一）newsom函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">net=newsom(PR,[D1,D2,^],TFCN,DFCN,OLR,OSTEPS,TLR,TND)</span><br><span class="line"></span><br><span class="line">PR:R个输入元素的最大值和最小值的设定值，R*2维矩阵</span><br><span class="line"></span><br><span class="line">Di：第I层的维数，默认为[5 8]</span><br><span class="line"></span><br><span class="line">TFCN：拓扑函数，默认为hextop</span><br><span class="line"></span><br><span class="line">DFCN:距离函数，默认为linkdist</span><br><span class="line"></span><br><span class="line">OLR：分类阶段学习速率，默认为0.9</span><br><span class="line"></span><br><span class="line">OSTEPS：分类阶段的步长，默认为1000</span><br><span class="line"></span><br><span class="line">TLR：调谐阶段的学习速率，默认为0.02</span><br><span class="line"></span><br><span class="line">TNS:调谐阶段的领域距离，默认为1.</span><br></pre></td></tr></table></figure></p><p>输入net=newsom([0 1;0 1],[3 5])时的拓扑结构<br><img src="http://s7.sinaimg.cn/orignal/7671b3eb4af4d986c8f96&amp;690" alt="BST算法流程"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eg.</span><br><span class="line">&gt;&gt; P=[rand(1,400)*2;rand(1,400)];</span><br><span class="line"></span><br><span class="line">&gt;&gt; plot(P(1,:),P(2,:),&apos;.&apos;,&apos;markersize&apos;,20)</span><br><span class="line">&gt;&gt; net=newsom([0 1;0 1],[3 5]);</span><br><span class="line">&gt;&gt; net=train(net,P);</span><br><span class="line">&gt;&gt; hold on</span><br><span class="line">&gt;&gt; plotsom(net.iw&#123;1,1&#125;,net.layers&#123;1&#125;.distances)</span><br><span class="line">&gt;&gt; hold off</span><br></pre></td></tr></table></figure></p><p><img src="http://s14.sinaimg.cn/orignal/7671b3eb4af4dce12150d&amp;690" alt="BST算法流程"></p><p>（二）newc函数</p><p>功能：该函数用于创建一个竞争层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net=newc</span><br><span class="line"></span><br><span class="line">net=newc(PR,S,KLR,CLR)</span><br><span class="line"></span><br><span class="line">S:神经元的数目</span><br><span class="line"></span><br><span class="line">KLR：Kohonen学习速度，默认为0.01</span><br><span class="line"></span><br><span class="line">CLR：Conscience学习速度，默认为0.001</span><br><span class="line"></span><br><span class="line">net:函数返回值，一个新的竞争层。</span><br></pre></td></tr></table></figure></p><p>（三）newlvq函数</p><p>功能：该函数用于创建一个学习向量量化的LVQ网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net=newlvp</span><br><span class="line"></span><br><span class="line">net=newlvp(PR,S1,PC,LR,LF)</span><br><span class="line"></span><br><span class="line">S1:竞争层神经元的数目</span><br><span class="line"></span><br><span class="line">PC：分类的百分比</span><br><span class="line"></span><br><span class="line">LR：学习速率，默认为0.01</span><br><span class="line"></span><br><span class="line">LF:学习函数，默认为learnlvl</span><br></pre></td></tr></table></figure><p>例子看<a href="http://blog.sina.com.cn/s/blog_7671b3eb0100y4t3.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7671b3eb0100y4t3.html</a></p><h2 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h2><p>（一）compet函数</p><p>功能：该函数为传递函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A=compet(N)</span><br><span class="line"></span><br><span class="line">info=compet(code)</span><br><span class="line"></span><br><span class="line">N：输入（列）向量的S*Q维矩阵</span><br><span class="line"></span><br><span class="line">A：函数返回值，输出向量矩阵，每一列向量只有一个1，位于输入向量最大的位置</span><br></pre></td></tr></table></figure></p><p>info=compet(code)：根据code值的不同返回有关函数的不同信息，包括derice-导数名称；name-函数名称；output-输出范围；active-动态输入范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; n1=[5;3;6;8];</span><br><span class="line">&gt;&gt; a1=compet(n1)</span><br><span class="line"></span><br><span class="line">a1 =</span><br><span class="line"></span><br><span class="line">   (4,1)        1</span><br></pre></td></tr></table></figure></p><p>（二）softmax函数</p><p>功能：该函数为软最大传递函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=softmax(N)</span><br><span class="line"></span><br><span class="line">info=softmax(code)</span><br></pre></td></tr></table></figure></p><p>与compet不同的是，参数A为函数返回向量，个元素在区间[0，1]，且向量结构与N一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; n1=[5;3;6;8];</span><br><span class="line">&gt;&gt; a2=softmax(n1)</span><br><span class="line"></span><br><span class="line">a2 =</span><br><span class="line"></span><br><span class="line">    0.0418</span><br><span class="line">    0.0057</span><br><span class="line">    0.1135</span><br><span class="line">    0.8390</span><br></pre></td></tr></table></figure></p><h2 id="距离函数"><a href="#距离函数" class="headerlink" title="距离函数"></a>距离函数</h2><p>（一）boxdist函数</p><p>功能：该函数为Box距离函数，在给定神经网络某层的神经元的位置后，可利用该函数计算神经元之间的位置，该函数通常用于结构函数的gridtop的神经网络层。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d=boxdist(pos)</span><br><span class="line"></span><br><span class="line">ps:神经元位置的N*S维矩阵</span><br><span class="line"></span><br><span class="line">d：函数返回值，神经元距离的S*S维矩阵。</span><br></pre></td></tr></table></figure></p><p>函数的运算原理为d(i,j)=max||pi-pj||。其中，d(i,j)表示距离矩阵中的元素，pi表示位置矩阵的第i列向量。</p><p>（二）dist函数</p><p>功能：该函数的欧式距离权函数，通过对输入进行加权得到加权后的输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Z=dist(W,P);</span><br><span class="line"></span><br><span class="line">df=dist(&apos;deriv&apos;)</span><br><span class="line"></span><br><span class="line">D=dist(pos)</span><br><span class="line"></span><br><span class="line">W:S*R维的权值矩阵</span><br><span class="line"></span><br><span class="line">P:Q组输入（列）向量的R*Q维矩阵</span><br><span class="line"></span><br><span class="line">Z:S*Q维的距离矩阵</span><br><span class="line"></span><br><span class="line">pos:神经元位置的N*S维矩阵</span><br><span class="line"></span><br><span class="line">D:S*S维的距离矩阵</span><br><span class="line"></span><br><span class="line">df=dist(&apos;deriv&apos;)：返回值为空，因为该函数不存在导函数。</span><br></pre></td></tr></table></figure></p><p>函数运算规则为D=sqrt(sum((x-y)2))，其中x和y分别为列向量。</p><p>（三）linkdist函数</p><p>功能：该函数为连接距离函数，在给定神经元的位置后，该函数可用于计算神经元之间的距离<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d=linkdist(pos)</span><br></pre></td></tr></table></figure></p><p>（四）mandist函数</p><p>功能：该函数为Manhattan距离权函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Z=mandist(W,P)</span><br><span class="line"></span><br><span class="line">df=mandist(&apos;deriv&apos;)</span><br><span class="line"></span><br><span class="line">D=mandist(pos)</span><br></pre></td></tr></table></figure></p><h2 id="学习函数"><a href="#学习函数" class="headerlink" title="学习函数"></a>学习函数</h2><p>（一）learnk函数</p><p>功能：该函数为kohonen权值学习函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[dw,LS]=learnk(W,P,Z,N,A,T,E,gW,gA,D,LP,LS)</span><br><span class="line"></span><br><span class="line">info=learnk(code)</span><br><span class="line"></span><br><span class="line">W:权值矩阵</span><br><span class="line"></span><br><span class="line">P:输入向量矩阵</span><br><span class="line"></span><br><span class="line">Z:权值输入向量矩阵</span><br><span class="line"></span><br><span class="line">N:网格输入向量矩阵</span><br><span class="line"></span><br><span class="line">A:输出向量矩阵</span><br><span class="line"></span><br><span class="line">T:目标向量矩阵</span><br><span class="line"></span><br><span class="line">E:误差向量矩阵</span><br><span class="line"></span><br><span class="line">gW:性能梯度矩阵</span><br><span class="line"></span><br><span class="line">D:神经元距离矩阵</span><br><span class="line"></span><br><span class="line">LP:学习参数，若无则为空</span><br><span class="line"></span><br><span class="line">LS:学习状态，初始化为空</span><br><span class="line"></span><br><span class="line">dW：权值（阈值）变化矩阵</span><br><span class="line"></span><br><span class="line">LS:新的学习状态</span><br><span class="line"></span><br><span class="line">info=learnk(code)……</span><br></pre></td></tr></table></figure></p><p>(二)learnsom函数</p><p>功能：该函数为自组织映射权值学习函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[dW,LS]=learnsom(W,P,Z,N,A,T,E,gW,gA,D,LP,LS)</span><br><span class="line"></span><br><span class="line">info=learnsom(code)</span><br><span class="line"></span><br><span class="line">几个需要设置的学习参数</span><br><span class="line"></span><br><span class="line">LP.order_lr分类阶段学习速率，默认0.9</span><br><span class="line"></span><br><span class="line">LP.order_steps学习阶段补偿，默认1000</span><br><span class="line"></span><br><span class="line">LP.tune_lr调谐阶段领域距离，默认0.02</span><br><span class="line"></span><br><span class="line">LP.tune_nd调谐阶段学习速率，默认1</span><br></pre></td></tr></table></figure></p><p>（三）learnis函数</p><p>功能：该函数为instar权值学习函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dW,LS]=learnis(W,P,Z,N,A,T,E,gW,gA,D,LP,LS)</span><br><span class="line"></span><br><span class="line">info=learnis(code)</span><br></pre></td></tr></table></figure></p><p>（四）learnos函数</p><h2 id="初始化函数（midpoint）"><a href="#初始化函数（midpoint）" class="headerlink" title="初始化函数（midpoint）"></a>初始化函数（midpoint）</h2><p>功能：该函数为i中心点权值初始化函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">W=midpoint(S,PR)</span><br><span class="line"></span><br><span class="line">S:神经元的数目；</span><br><span class="line"></span><br><span class="line">PR:每组输入向量的最大值和最小值组成的R*2维矩阵，规定了输入区间为[Pmin，Pmax]</span><br><span class="line"></span><br><span class="line">W:函数返回值，S*R维的矩阵，每个元素对应设定为（Pmin+Pmax）/2</span><br></pre></td></tr></table></figure></p><h2 id="权值函数（negdist）"><a href="#权值函数（negdist）" class="headerlink" title="权值函数（negdist）"></a>权值函数（negdist）</h2><p>功能：该函数为负距离权值函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z=negdist(W,P)</span><br></pre></td></tr></table></figure></p><h2 id="显示函数（plotsom）"><a href="#显示函数（plotsom）" class="headerlink" title="显示函数（plotsom）"></a>显示函数（plotsom）</h2><p>功能：该函数用于绘制自组织特征映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plotsom(pos)</span><br><span class="line"></span><br><span class="line">plotsom(W,D,ND)</span><br><span class="line"></span><br><span class="line">pos:神经元位置向量</span><br><span class="line"></span><br><span class="line">W:权值矩阵</span><br><span class="line"></span><br><span class="line">D:距离矩阵</span><br><span class="line"></span><br><span class="line">ND：领域矩阵，默认为1</span><br><span class="line"></span><br><span class="line">plotsom（pos）：利用红点绘制神经元的位置，将欧氏距离小于等于1的神经元连接起来</span><br><span class="line"></span><br><span class="line">plotsom(W,D,ND)：将欧氏距离小于等于1的神经元的权值向量连接起来</span><br></pre></td></tr></table></figure></p><h2 id="结构函数（hextop）"><a href="#结构函数（hextop）" class="headerlink" title="结构函数（hextop）"></a>结构函数（hextop）</h2><p>六角层结构函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pos=hextop(dim1,dim2,^dimN)</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"></span><br><span class="line">pos=hextop(8,5);</span><br><span class="line">plotsom(pos)</span><br><span class="line"></span><br><span class="line">W=rands(40,2);plotsom(W,dist(pos))</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 可视化 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BST 存储结构建立（插入）、删除、 查找算法的实现及应用</title>
      <link href="/2016/02/14/BST%E5%AD%98%E5%82%A8%E7%BB%93%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2016/02/14/BST%E5%AD%98%E5%82%A8%E7%BB%93%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/50659727" target="_blank" rel="noopener">点这里</a><br>（一）下面的代码要实现的任务：<br>1.设计 BST 的左右链存储结构；<br>2.实现 BST 左右链存储结构上的插入（建立）、删除、查找和排序算法。<br>3.利用 BST 结构和相应的操作算法，实现班级学习成绩管理（单科成绩管理， 排名；加权绩点管理与排名等）。<br><a id="more"></a><br>4.学生的基础成绩信息以文件形式保存；学生基础成绩信息和排名信息以文件形式存储；并能显示到屏幕。</p><p>（二）话不多说上代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StuInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">   <span class="comment">//char obj1[100][100];</span></span><br><span class="line">   <span class="keyword">int</span> sco1[<span class="number">100</span>];</span><br><span class="line">   <span class="comment">//char obj2[100][100];</span></span><br><span class="line">   <span class="keyword">int</span> sco2[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span> avi[<span class="number">100</span>];</span><br><span class="line">  <span class="comment">// char scoAve[100][100];</span></span><br><span class="line">&#125;StuInfo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTN</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">   <span class="comment">// struct StuInfo stu;</span></span><br><span class="line">     <span class="keyword">char</span> name1[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">// int sco1[100];</span></span><br><span class="line">     <span class="keyword">int</span> sco21;</span><br><span class="line">     <span class="keyword">int</span> sco11;</span><br><span class="line">     <span class="keyword">int</span> scoAv1;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTN</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTN,*BstTree;</span><br><span class="line"><span class="comment">//全局变量写文件</span></span><br><span class="line"><span class="keyword">char</span> keep[<span class="number">100</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> cou=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> sa[<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> *zhengti;</span><br><span class="line"><span class="comment">//查找，放在建立前面</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(BstTree T,BstTree f,BstTree *p,<span class="keyword">int</span> key)</span><span class="comment">/* 指针f指向T的双亲，其初始调用值为NULL */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        *p=f;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        *p=T;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> search(T-&gt;lchild,T,p,key);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> search(T-&gt;rchild,T,p,key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(BstTree *T,<span class="keyword">int</span> score1,<span class="keyword">char</span> ss[],<span class="keyword">int</span> score2,<span class="keyword">int</span> aveScore,<span class="keyword">int</span> cho)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    BstTree p,s;</span><br><span class="line">    <span class="keyword">if</span> (cho==<span class="number">1</span>)</span><br><span class="line">        key=score1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            key=aveScore;</span><br><span class="line">    <span class="keyword">if</span>(search(*T,<span class="literal">NULL</span>,&amp;p,key)==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s=(BstTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTN));</span><br><span class="line">        s-&gt;data=key;</span><br><span class="line">        <span class="comment">//s-&gt;name1=s[];</span></span><br><span class="line">        <span class="built_in">strcpy</span>(s-&gt;name1,ss);</span><br><span class="line">        s-&gt;sco11=score1;</span><br><span class="line">        s-&gt;sco21=score2;</span><br><span class="line">        s-&gt;scoAv1=aveScore;</span><br><span class="line">        s-&gt;lchild=s-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//printf("aa");</span></span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">            *T=s;<span class="comment">//插入S为新的根结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;p-&gt;data)</span><br><span class="line">            p-&gt;lchild=s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;rchild=s;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delete</span><span class="params">(BstTree *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BstTree q,s;</span><br><span class="line"><span class="keyword">if</span>((*p)-&gt;rchild==<span class="literal">NULL</span>) <span class="comment">/* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; *p=(*p)-&gt;lchild; <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild==<span class="literal">NULL</span>) <span class="comment">/* 只需重接它的右子树 */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; *p=(*p)-&gt;rchild; <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 左右子树均不空 */</span></span><br><span class="line">&#123;</span><br><span class="line">q=*p; s=(*p)-&gt;lchild;</span><br><span class="line"><span class="keyword">while</span>(s-&gt;rchild) <span class="comment">/* 转左，然后向右到尽头（找待删结点的前驱） */</span></span><br><span class="line">&#123;</span><br><span class="line">q=s;</span><br><span class="line">s=s-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">(*p)-&gt;data=s-&gt;data; <span class="comment">/*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */</span></span><br><span class="line"><span class="keyword">if</span>(q!=*p)</span><br><span class="line">q-&gt;rchild=s-&gt;lchild; <span class="comment">/*  重接q的右子树 */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">q-&gt;lchild=s-&gt;lchild; <span class="comment">/*  重接q的左子树 */</span></span><br><span class="line"><span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */</span></span><br><span class="line"><span class="comment">/* 并返回TRUE；否则返回FALSE。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteBST</span><span class="params">(BstTree *T,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!*T) <span class="comment">/* 不存在关键字等于key的数据元素 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key==(*T)-&gt;data) <span class="comment">/* 找到关键字等于key的数据元素 */</span></span><br><span class="line"><span class="keyword">return</span> Delete(T);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key&lt;(*T)-&gt;data)</span><br><span class="line"><span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BstTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;data);<span class="comment">/* 显示结点数据，可以更改为其它对结点操作 */</span></span><br><span class="line">PreOrderTraverse(T-&gt;lchild); <span class="comment">/* 再先序遍历左子树 */</span></span><br><span class="line">PreOrderTraverse(T-&gt;rchild); <span class="comment">/* 最后先序遍历右子树 */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 初始条件: 二叉树T存在 */</span></span><br><span class="line"><span class="comment">/* 操作结果: 中序递归遍历T */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BstTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>  ;</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">InOrderTraverse(T-&gt;lchild); <span class="comment">/* 中序遍历左子树 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\t"</span>,T-&gt;name1);</span><br><span class="line">    store(T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;sco11);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\t"</span>,T-&gt;sco21);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,T-&gt;scoAv1);</span><br><span class="line"><span class="comment">/* 显示结点数据，可以更改为其它对结点操作 */</span></span><br><span class="line">InOrderTraverse(T-&gt;rchild); <span class="comment">/* 最后中序遍历右子树 */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(BstTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(T-&gt;name1);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        keep[cou][i]=T-&gt;name1[i];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//keep[cou][i]=T-&gt;sco11;</span></span><br><span class="line">        <span class="comment">//itoa(T-&gt;sco11,keep[cou][i],10);</span></span><br><span class="line">    <span class="comment">//keep[cou]=T-&gt;name1;</span></span><br><span class="line">    itoa(T-&gt;sco11,s1[cou],<span class="number">10</span>);</span><br><span class="line">itoa(T-&gt;sco21,s2[cou],<span class="number">10</span>);</span><br><span class="line">itoa(T-&gt;scoAv1,sa[cou],<span class="number">10</span>);</span><br><span class="line">   <span class="comment">// printf("%s",keep[cou]);</span></span><br><span class="line"><span class="comment">//sa[cou]=T-&gt;scoAv1;</span></span><br><span class="line"><span class="comment">//wriIn(s1);</span></span><br><span class="line">cou++;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//printf("%d",cou);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">andstr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//strcat(zhengti,keep[i]);</span></span><br><span class="line">        zhengti=keep[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wriIn</span><span class="params">(<span class="keyword">int</span> whi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//if(whi==1)</span></span><br><span class="line">    FILE *pFile = fopen(<span class="string">"F:\\untitled\\DataStructure\\实验\\实验二\\aac.txt"</span>, <span class="string">"w"</span>); <span class="comment">// 文件打开方式 如果原来有内容也会销毁</span></span><br><span class="line">   <span class="comment">/* else</span></span><br><span class="line"><span class="comment">        FILE *pFile = fopen("F:\\untitled\\DataStructure\\实验\\实验二\\aac.txt", //打开文件的名称</span></span><br><span class="line"><span class="comment">    "w");*/</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,<span class="string">"按工数排序\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,<span class="string">"姓名\t工数\t概率论\t绩点\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,keep[i]);</span><br><span class="line">         <span class="built_in">fprintf</span>(pFile,<span class="string">"\t"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,s1[i]);</span><br><span class="line">         <span class="built_in">fprintf</span>(pFile,<span class="string">"\t"</span>);</span><br><span class="line">         <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,s2[i]);</span><br><span class="line">        <span class="built_in">fprintf</span>(pFile,<span class="string">"\t"</span>);</span><br><span class="line">         <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,sa[i]);</span><br><span class="line">       <span class="built_in">fprintf</span>(pFile,<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pFile);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wriIn2</span><span class="params">(<span class="keyword">int</span> whi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//if(whi==1)</span></span><br><span class="line">    FILE *pFile = fopen(<span class="string">"F:\\untitled\\DataStructure\\实验\\实验二\\aab.txt"</span>, <span class="string">"w"</span>); <span class="comment">// 文件打开方式 如果原来有内容也会销毁</span></span><br><span class="line">   <span class="comment">/* else</span></span><br><span class="line"><span class="comment">        FILE *pFile = fopen("F:\\untitled\\DataStructure\\实验\\实验二\\aac.txt", //打开文件的名称</span></span><br><span class="line"><span class="comment">    "w");*/</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">     <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,<span class="string">"按绩点排序\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,<span class="string">"姓名\t工数\t概率论\t绩点\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,keep[i]);</span><br><span class="line">         <span class="built_in">fprintf</span>(pFile,<span class="string">"\t"</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,s1[i]);</span><br><span class="line">         <span class="built_in">fprintf</span>(pFile,<span class="string">"\t"</span>);</span><br><span class="line">         <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,s2[i]);</span><br><span class="line">        <span class="built_in">fprintf</span>(pFile,<span class="string">"\t"</span>);</span><br><span class="line">         <span class="built_in">fprintf</span>(pFile,<span class="string">"%s"</span>,sa[i]);</span><br><span class="line">       <span class="built_in">fprintf</span>(pFile,<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pFile);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,hahahaha;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">62</span>,<span class="number">88</span>,<span class="number">58</span>,<span class="number">47</span>,<span class="number">35</span>,<span class="number">73</span>,<span class="number">51</span>,<span class="number">99</span>,<span class="number">94</span>,<span class="number">37</span>&#125;;</span><br><span class="line">BstTree T=<span class="literal">NULL</span>;</span><br><span class="line">BstTree T1=<span class="literal">NULL</span>;</span><br><span class="line">StuInfo stu;</span><br><span class="line">   <span class="comment">// read(stu);</span></span><br><span class="line">    FILE *in;</span><br><span class="line"><span class="keyword">int</span> LINE = <span class="number">128</span>,len,j=<span class="number">50</span>,k=<span class="number">0</span>,m;</span><br><span class="line"><span class="keyword">char</span> buf[LINE],ss[<span class="number">50</span>][j];</span><br><span class="line">in = fopen(<span class="string">"F:\\untitled\\DataStructure\\实验\\实验二\\aaa.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span> (in == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"找不到该文件"</span>);</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        fgets(buf, LINE, in);</span><br><span class="line"><span class="keyword">while</span>(fgets(buf, LINE, in) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">len = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;len;m++)&#123;</span><br><span class="line"> </span><br><span class="line">ss[k][m]=buf[m];</span><br><span class="line">ss[k][m+<span class="number">1</span>]=<span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">//printf("%c",ss[k][m]);</span></span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line"><span class="comment">//printf("\n");</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">char</span> delims[] = <span class="string">" "</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> count,a2;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line"><span class="comment">//a1=0;</span></span><br><span class="line">    <span class="keyword">for</span>(a2=<span class="number">0</span>;a2&lt;k;a2++)&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">t= strtok(ss[a2], delims);</span><br><span class="line"><span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;<span class="built_in">strlen</span>(t);count++)</span><br><span class="line">    &#123;</span><br><span class="line">       stu.name[a2][count]=t[count];</span><br><span class="line">       <span class="comment">// printf("%c", stu.name[a1][count]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a1++;</span></span><br><span class="line"> </span><br><span class="line">    t = strtok(<span class="literal">NULL</span>, delims);</span><br><span class="line">    stu.sco1[a2]=atoi(t);</span><br><span class="line"><span class="comment">//printf("%d", stu.sco1[a1]+1);</span></span><br><span class="line">   <span class="comment">// a1++;</span></span><br><span class="line"> </span><br><span class="line">    t = strtok(<span class="literal">NULL</span>, delims);</span><br><span class="line">    stu.sco2[a2]=atoi(t);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">double</span> ave[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">        ave[i]=(((<span class="keyword">int</span>)(stu.sco1[i]*<span class="number">5</span>+stu.sco2[i]*<span class="number">4</span>)/<span class="number">9</span>)*<span class="number">100.00</span>)/<span class="number">100.00</span>;</span><br><span class="line">        stu.avi[i]=ave[i];</span><br><span class="line">insert(&amp;T, stu.sco1[i],stu.name[i],stu.sco2[i],stu.avi[i],<span class="number">1</span>);</span><br><span class="line">insert(&amp;T1, stu.sco1[i],stu.name[i],stu.sco2[i],stu.avi[i],<span class="number">2</span>);</span><br><span class="line"><span class="comment">//printf("%lf",ave[i]);</span></span><br><span class="line"><span class="comment">//printf("%d??\n",stu.sco1[i]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for(i=0;i&lt;10;)</span></span><br><span class="line"><span class="comment">/*printf("\n前序遍历二叉树:");</span></span><br><span class="line"><span class="comment">PreOrderTraverse(T);*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请选择相关操作：1.按工数排序；2：按绩点排序;3:结束\n"</span>);</span><br><span class="line"><span class="comment">//do&#123;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;hahahaha);</span><br><span class="line"><span class="keyword">if</span>(hahahaha==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n按工数排序:\n"</span>);</span><br><span class="line">InOrderTraverse(T);</span><br><span class="line">wriIn(hahahaha);</span><br><span class="line"><span class="comment">//hahahaha=2;</span></span><br><span class="line">&#125;</span><br><span class="line">cou=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(hahahaha==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n按绩点排序:\n"</span>);</span><br><span class="line">InOrderTraverse(T1);</span><br><span class="line">wriIn2(hahahaha);&#125;<span class="comment">//&#125;while(hahahaha==3);</span></span><br><span class="line"><span class="comment">//if(hahahaha==3)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 编码 </tag>
            
            <tag> 哈弗曼树 </tag>
            
            <tag> 译码 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构：我写哈夫曼树的一点心得及改进</title>
      <link href="/2016/02/13/%E6%88%91%E5%86%99%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97%E5%8F%8A%E6%94%B9%E8%BF%9B/"/>
      <url>/2016/02/13/%E6%88%91%E5%86%99%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97%E5%8F%8A%E6%94%B9%E8%BF%9B/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/50659705" target="_blank" rel="noopener">点这里</a><br>一：首先，讨论并比较基于字符的压缩与基于单词的压缩<br><a id="more"></a></p><p>1.基于字符的压缩所用的存储空间固定，但由于每个字符都要编码，相比基于单词的压缩在文章字数较少时更加适用；</p><p>2.基于单词的压缩适用于专业类文章或者其他相关术语等有单词出现频率高的文章的压缩，这样编码的长度会减少很多</p><p>3.对于不同的文章，应综合考虑，或者在大量统计的基础上得出普适规律</p><p>4.无论是基于字符的压缩还是基于单词的压缩如果应用K叉树，则空间利用率都会提高，而应用最优堆则会使时间复杂度降低</p><p>二：系统不足</p><p>不足：</p><p>1.没有考虑优化问题，如果应用K叉树，平均编码长度就会减少很多，整体的哈夫曼编码会变得简短；</p><p>2.在建立哈夫曼树的过程中，无论是插入结点还是寻找最小结点，他们整体的时间复杂度都是O（n2）。如果考虑用最小堆问题，寻找最小结点的时间复杂度变为O(logn),整体的复杂度就减少为O（n·logn）。</p><p>三：实验心得</p><p>这次最突出的问题是：代码的复用问题，因为之前建立结构体数组用的是全局变量，本以为在函数操作中会简单，到后来在建立基于单词压缩方法时就出现了复用问题，后来是自己动手改了每个函数参数之间的传递。我觉得这对我是一次警告，警告我以后编程序时要充分考虑代码复用性及函数的封装性。</p><p>还有一个地方，是方法的选择问题，在寻找权值最小的两个结点时，我面临很多方法，可以用实验一用过的插入排序把数组按权值排序后直接取前两个，也可以直接遍历两次寻找到最小的，然而这两种方法的时间复杂度都是O（n）,如果再进一步考虑，思考老师给的后面的加分题，完全可以想到用最小堆来优化使时间复杂度降为O（logn），这也是刚学过的知识。</p><p>上面的两个问题让我意识到对知识的应用和对程序优化的重要性，对已经实现出来的功能从时间复杂度和空间复杂度两个方面优化，并加强他的复用性，使方法可以再更多情况下使用而不是仅仅局限于当前命题，是我要学习的方向之一。</p><p>实验是基础的哈夫曼树，在寻找资料的过程中无意接触到了计算机学科对自然语言的处理这一领域，做为兴趣决定会去多多接触一下，就拿哈夫曼树当入门了。</p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 编码 </tag>
            
            <tag> 哈弗曼树 </tag>
            
            <tag> 译码 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构：哈夫曼树，哈夫曼编码与译码系统</title>
      <link href="/2016/02/13/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91_%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E4%B8%8E%E8%AF%91%E7%A0%81%E7%B3%BB%E7%BB%9F/"/>
      <url>/2016/02/13/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91_%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E4%B8%8E%E8%AF%91%E7%A0%81%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/50659685" target="_blank" rel="noopener">点这里</a><br>将文本文件利用哈夫曼树进行编码，存储成压缩文件<br><a id="more"></a></p><p>定义结构体类型：</p><p>1）.结构体类型 HaffmanfT：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> chh[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> lchild;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> rchild;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> parent;</span><br><span class="line"></span><br><span class="line"> &#125;HaffmanT;<span class="comment">/*结点结构体*/</span></span><br></pre></td></tr></table></figure></p><p>2）. （字母部分用的结构体）结构体类型 HaffmanfN<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedefstruct</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> bits[MB + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> start;<span class="comment">//标志编码起始位</span></span><br><span class="line"></span><br><span class="line">&#125;HaffmanN;<span class="comment">/*保存编码*/</span></span><br></pre></td></tr></table></figure></p><p>3 ）.单词部分的储存编码和权值用了三个数组（全局变量）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">charstr2[MB][<span class="number">20</span>];<span class="comment">//单词字串</span></span><br><span class="line"></span><br><span class="line">charstr3[MB][<span class="number">20</span>];<span class="comment">//输入串</span></span><br><span class="line"></span><br><span class="line">intstrC[MB];<span class="comment">//单词字串计数数组.对应每个单词串,拥有一个计算器</span></span><br></pre></td></tr></table></figure></p><p>4）.   （全局变量）charmi[MAXPLUS];//存放的是字符串编码</p><p>charcha[MAXPLUS];//存放的是句子</p><p>2．</p><p>实验所用到的全部函数有：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>）.voidstrCount();<span class="comment">//统计字母并计算每个字母出现的次数即权值</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）.intwordCount();<span class="comment">//统计单词并计算每个单词出现的次数即权值，返回出现的不同单词个数</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）.<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(intn)</span></span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）.voidgetHaff(<span class="keyword">int</span> n,<span class="keyword">int</span> p);<span class="comment">//把字母（单词）及权值保存到结构体中，n决定单词还是字母，p决定了结构体数组的大小</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）.<span class="function"><span class="keyword">int</span> <span class="title">creat2</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//创建哈夫曼树</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）.voidCharSetHuffmanEncoding(<span class="keyword">int</span> n,<span class="keyword">int</span> wh);<span class="comment">//给每一个结点编码，n代表结点个数</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>）.<span class="function"><span class="keyword">void</span> <span class="title">bianma</span><span class="params">(intwh,<span class="keyword">int</span> p)</span></span>;<span class="comment">//给从文件中读到的文章整体编码，即压缩</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>）.<span class="function"><span class="keyword">void</span> <span class="title">wriIn</span><span class="params">()</span></span>;<span class="comment">//将对文件的编码写入新的TXT文档</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span>）.<span class="function"><span class="keyword">void</span> <span class="title">yima</span><span class="params">(intn,<span class="keyword">int</span> wh)</span></span>;  <span class="comment">//将哈夫曼编码解码为原文档        </span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>）.<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>;<span class="comment">//综合调用并计算压缩率</span></span><br></pre></td></tr></table></figure></p><p>详细代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include "stdafx.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"io.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB 300<span class="comment">//最大编码的值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXPLUS 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">char</span> chh[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> lchild;</span><br><span class="line"><span class="keyword">int</span> rchild;</span><br><span class="line"><span class="keyword">int</span> parent;</span><br><span class="line"></span><br><span class="line">&#125;HaffmanT;<span class="comment">/*结点结构体*/</span></span><br><span class="line">HaffmanT T[MB];</span><br><span class="line">HaffmanT TW[MB];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">char</span> bits[MB + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> start;<span class="comment">//标志编码起始位</span></span><br><span class="line">&#125;HaffmanN;</span><br><span class="line">HaffmanN N[MB];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str2[MB][<span class="number">20</span>];<span class="comment">//单词字串结果存放数组</span></span><br><span class="line"><span class="keyword">char</span> str3[MB][<span class="number">20</span>];<span class="comment">//输入串或者用char *str2也可,这样可以</span></span><br><span class="line"><span class="keyword">int</span> strC[MB];<span class="comment">//单词字串计数数组.对应每个单词串,拥有一个计算器</span></span><br><span class="line"><span class="keyword">char</span> mi[MAXPLUS];<span class="comment">//存放的是字符串编码</span></span><br><span class="line"><span class="keyword">char</span> cha[MAXPLUS];<span class="comment">//存放的是句子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strCount</span><span class="params">()</span></span>;<span class="comment">//统计字母并计算每个字母出现的次数即权值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordCount</span><span class="params">()</span></span>;<span class="comment">//统计单词并计算每个单词出现的次数即权值，返回出现的不同单词个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHaff</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>;<span class="comment">//把字母（单词）及权值保存到结构体中，n决定单词还是字母，p决定了结构体数组的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat2</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//创建哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CharSetHuffmanEncoding</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> wh)</span></span>;<span class="comment">//给每一个结点编码，n代表结点个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bianma</span><span class="params">(<span class="keyword">int</span> wh,<span class="keyword">int</span> p)</span></span>;<span class="comment">//给从文件中读到的文章整体编码，即压缩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wriIn</span><span class="params">()</span></span>;<span class="comment">//将对文件的编码写入新的TXT文档</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yima</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> wh)</span></span>;  <span class="comment">//将哈夫曼编码解码为原文档   </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,k,cho;</span><br><span class="line">    strCount();</span><br><span class="line">k=wordCount();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">29</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请选择编码：0,单词，1字母\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cho);</span><br><span class="line"><span class="keyword">if</span>(cho==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"你输入了”0“，将给出单词的频率及相应的哈夫曼编码\n"</span>);</span><br><span class="line">        getHaff(cho,k);</span><br><span class="line">        creat2(k);</span><br><span class="line">        CharSetHuffmanEncoding(k<span class="number">-1</span>,cho);<span class="comment">//k-1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"是否压缩：1：是，0：否：\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cho);</span><br><span class="line">        <span class="keyword">if</span>(cho==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cho==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"接下来是压缩环节\n"</span>);</span><br><span class="line">            bianma(cho,k);</span><br><span class="line">            wriIn();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"是否解压缩：1：是，0：否：\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cho);</span><br><span class="line">        <span class="keyword">if</span>(cho==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cho==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        yima(k,cho);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"计算压缩率：\n"</span>);</span><br><span class="line">        <span class="keyword">double</span> ee=(<span class="keyword">double</span>)<span class="built_in">strlen</span>(mi)/(<span class="built_in">strlen</span>(cha)*<span class="number">8</span>);</span><br><span class="line">        ee=<span class="number">1</span>-ee;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"压缩率为%.2f"</span>,ee*<span class="number">100</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%%"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cho==<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"你输入了”1“，将给出字符的频率及相应的哈夫曼编码\n"</span>);</span><br><span class="line">        getHaff(cho,n);</span><br><span class="line">        creat2(n);</span><br><span class="line">        CharSetHuffmanEncoding(n,cho);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"是否压缩：1：是，0：否：\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cho);</span><br><span class="line">        <span class="keyword">if</span>(cho==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cho==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"接下来是压缩环节\n"</span>);</span><br><span class="line">            bianma(cho,n);</span><br><span class="line">            wriIn();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"是否解压缩：1：是，0：否：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cho);</span><br><span class="line">    <span class="keyword">if</span>(cho==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cho==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        yima(n,cho);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"计算压缩率：\n"</span>);</span><br><span class="line">        <span class="keyword">double</span> ee=(<span class="keyword">double</span>)<span class="built_in">strlen</span>(mi)/(<span class="built_in">strlen</span>(cha)*<span class="number">8</span>);</span><br><span class="line">        ee=<span class="number">1</span>-ee;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"压缩率为%.2f"</span>,ee*<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%%"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//先是统计字符的功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strCount</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">char</span> str1;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">"F:\\untitled\\DataStructure\\实验\\实验二\\aaa.txt"</span>,<span class="string">"r"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"file cannot be opened\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;<span class="comment">//数组下标</span></span><br><span class="line">    <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;<span class="number">29</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        TW[x].ch=<span class="string">'a'</span>+x;</span><br><span class="line">        TW[x].weight=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">// printf("%c",N[x].ch);</span></span><br><span class="line">    &#125;</span><br><span class="line">    TW[<span class="number">26</span>].ch=<span class="string">' '</span>;</span><br><span class="line">    TW[<span class="number">27</span>].ch=<span class="string">','</span>;</span><br><span class="line">    TW[<span class="number">28</span>].ch=<span class="string">'.'</span>;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((str1=fgetc(fp))!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//cha[x]+=str1;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(str1))</span><br><span class="line">        &#123;</span><br><span class="line">            str1=<span class="built_in">tolower</span>(str1);</span><br><span class="line">            ++TW[str1-<span class="string">'a'</span>].weight;<span class="comment">//直接用数组的ascii做下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="keyword">int</span>)str1==<span class="number">32</span>)</span><br><span class="line">            ++TW[<span class="number">26</span>].weight;<span class="comment">//这个是空格</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">int</span>)str1==<span class="number">44</span>)</span><br><span class="line">            ++TW[<span class="number">27</span>].weight;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">int</span>)str1==<span class="number">46</span>)</span><br><span class="line">            ++TW[<span class="number">28</span>].weight;</span><br><span class="line"></span><br><span class="line">            cha[x]=str1;</span><br><span class="line">            x++;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//fgets(cha,10000,fp);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"我的句子是:%s\n"</span>,&amp;cha);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计单词</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>,x,y=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(j&lt;<span class="built_in">strlen</span>(cha)+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(;cha[j]==<span class="number">32</span>||cha[j]==<span class="number">44</span>||cha[j]==<span class="number">46</span>;j++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k&lt;<span class="number">20</span>&amp;&amp;cha[j]!=<span class="number">32</span>&amp;&amp;cha[j]!=<span class="number">44</span>&amp;cha[j]!=<span class="number">46</span>)</span><br><span class="line">        str2[i][k++]=cha[j++];</span><br><span class="line">        str3[y][k++]=cha[j++];</span><br><span class="line">        str2[i][k]=<span class="string">'\0'</span>;</span><br><span class="line">        strC[i]=<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// strcpy(str3[j],str2[j]);</span></span><br><span class="line">        y++;</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;i;x++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(str2[i],str2[x],<span class="number">20</span>)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                strC[x]++;</span><br><span class="line"></span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            k=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//printf("i是%d,值是%s\n",i,str2[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    str2[i+<span class="number">1</span>][<span class="number">0</span>]=<span class="string">' '</span>;</span><br><span class="line">    str2[i+<span class="number">2</span>][<span class="number">0</span>]=<span class="string">','</span>;</span><br><span class="line">    str2[i+<span class="number">3</span>][<span class="number">0</span>]=<span class="string">'.'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建树之前赶紧把权值给搞好</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHaff</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span><span class="comment">//n是操作符，p是数组大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=n;</span><br><span class="line">    <span class="keyword">int</span> k=p;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;c&lt;p;c++)&#123;</span><br><span class="line">                T[c].weight=TW[c].weight;</span><br><span class="line">                T[c].ch=TW[c].ch;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(c=<span class="number">0</span>;c&lt;p<span class="number">-1</span>;c++)</span><br><span class="line">            T[c].weight=strC[c];</span><br><span class="line">          <span class="comment">//  strcpy(T[c].chh,str2[c]);</span></span><br><span class="line">           <span class="comment">// printf("%s,不输出啊吗",T[c].chh);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来构造一棵哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">2</span> * n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//T[i].weight = 0;//权值</span></span><br><span class="line">T[i].parent = <span class="number">-1</span>;</span><br><span class="line">T[i].lchild = <span class="number">-1</span>;</span><br><span class="line">T[i].rchild = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, p1, p2, w1, w2;<span class="comment">//p1,p2分别是最小权值的位置,w1,w2代表最小权值</span></span><br><span class="line"><span class="comment">//初始化结点</span></span><br><span class="line"><span class="keyword">int</span> num = n;</span><br><span class="line">init(n);</span><br><span class="line"><span class="comment">//循环构造哈夫曼树</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;num - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">w1 = w2 = <span class="number">10000</span>;</span><br><span class="line">p1 = p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j&lt;num + i; j++)<span class="comment">//循环条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T[j].weight&lt;w1&amp;&amp;T[j].parent == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">w2 = w1;</span><br><span class="line">p2 = p1;</span><br><span class="line">w1 = T[j].weight;</span><br><span class="line">p1 = j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (T[j].weight&lt;w2&amp;&amp;T[j].parent == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">w2 = T[j].weight;</span><br><span class="line">p2 = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//找到了p1，p2两个最小的位置</span></span><br><span class="line"><span class="comment">//printf("%d %d我要看看p的值！\n",p1,p2);</span></span><br><span class="line">T[p1].parent = T[p2].parent = num + i;    <span class="comment">//找到当前最小的两个节点 确定父节点</span></span><br><span class="line">T[num + i].lchild = p1;                   <span class="comment">//设置父节点的左右子树和权值</span></span><br><span class="line">T[num + i].rchild = p2;</span><br><span class="line">T[num + i].weight = T[p1].weight + T[p2].weight;<span class="comment">//特别注意一下是num+i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CharSetHuffmanEncoding</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> wh)</span><span class="comment">//n表示多少个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//根据树求编码表</span></span><br><span class="line"><span class="comment">//int n=init();</span></span><br><span class="line"><span class="keyword">int</span> c, p, i, j;</span><br><span class="line">HaffmanN cd;<span class="comment">//临时变量来存放求解编码时的信息</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cd.start = n - <span class="number">1</span>;</span><br><span class="line">c = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((p = T[c].parent) != <span class="number">-1</span>)   <span class="comment">/* 父结点存在 */</span></span><br><span class="line">&#123;</span><br><span class="line">cd.bits[cd.start] = (T[p].lchild == c) ? <span class="string">'0'</span> : <span class="string">'1'</span>;</span><br><span class="line">cd.start--;        <span class="comment">/* 求编码的低一位 */</span></span><br><span class="line">c = p;</span><br><span class="line">&#125; <span class="comment">/* end while */</span></span><br><span class="line"><span class="comment">/* 保存求出的每个叶结点的哈夫曼编码和编码的起始位 */</span></span><br><span class="line"><span class="keyword">for</span> (j = cd.start + <span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">N[i].bits[j] = cd.bits[j];</span><br><span class="line">N[i].start = cd.start;</span><br><span class="line">&#125; <span class="comment">/* end for */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出已保存好的所有存在编码的哈夫曼编码 */</span></span><br><span class="line"><span class="keyword">int</span> n1; <span class="keyword">char</span> temp;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(wh==<span class="number">1</span>)&#123;</span><br><span class="line">N[i].ch = T[i].ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c 出现的次数是%d，它的编码是: "</span>, T[i].ch,T[i].weight);&#125;</span><br><span class="line"><span class="comment">//for (n=0)</span></span><br><span class="line"><span class="keyword">if</span>(wh==<span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"第%d项,%s 出现的次数是%d，它的编码是: "</span>, i,str2[i],T[i].weight);</span><br><span class="line"><span class="keyword">for</span> (j = N[i].start + <span class="number">1</span>,n1=<span class="number">0</span>; j &lt; n; j++,n1++)</span><br><span class="line">&#123;</span><br><span class="line">temp = N[i].bits[j];</span><br><span class="line">N[i].bits[n1] = temp;</span><br><span class="line"><span class="comment">//printf("%c对比", N[i].bits[j]);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, N[i].bits[n1]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(" start:%d", N[i].start);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接下来是给字符串编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bianma</span><span class="params">(<span class="keyword">int</span> wh,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="built_in">strlen</span>(cha);</span><br><span class="line">    <span class="keyword">int</span> n2=<span class="built_in">strlen</span>(str3);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">if</span>(wh==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">29</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cha[i]==N[j].ch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//mi[i].bits=gets(N[j].bits);</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>,N[j].bits);</span><br><span class="line">                <span class="built_in">strcat</span> (mi,N[j].bits);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(wh==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n2;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;p;j++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(str3[i],T[j].chh,<span class="number">20</span>)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//mi[i].bits=gets(N[j].bits);</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>,N[j].bits);</span><br><span class="line">                <span class="built_in">strcat</span> (mi,N[j].bits);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后把字符串的码写到文件中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wriIn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *pFile = fopen(<span class="string">"F:\\untitled\\DataStructure\\实验\\实验二\\aab.txt"</span>, <span class="comment">//打开文件的名称</span></span><br><span class="line">                    <span class="string">"w"</span>); <span class="comment">// 文件打开方式 如果原来有内容也会销毁</span></span><br><span class="line"><span class="comment">//向文件写数据</span></span><br><span class="line">    fwrite (mi, <span class="comment">//要输入的文字</span></span><br><span class="line">         <span class="number">1</span>,<span class="comment">//文字每一项的大小</span></span><br><span class="line">       <span class="built_in">strlen</span>(mi),<span class="comment">//单元个数 </span></span><br><span class="line">         pFile <span class="comment">//我们刚刚获得到的地址</span></span><br><span class="line">         );</span><br><span class="line">        <span class="comment">// printf("测试下mi的值%c:\n",mi[0]);</span></span><br><span class="line"></span><br><span class="line">fflush(pFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//译码的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yima</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> wh)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">2</span>*n - <span class="number">2</span>;<span class="comment">//原来是这里！！！！！！！！！！</span></span><br><span class="line"><span class="keyword">int</span> temp = m;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"译码：\n"</span>);</span><br><span class="line"><span class="comment">/*char str[MAXPLUS];</span></span><br><span class="line"><span class="comment">gets(str);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//printf("weisheme ");</span></span><br><span class="line"><span class="comment">//char str[3]=&#123;'0','1'&#125;;</span></span><br><span class="line"><span class="comment">//for ()</span></span><br><span class="line"><span class="keyword">while</span> (mi[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="comment">//挨个读入电文</span></span><br><span class="line"><span class="comment">//printf("看一下有没有出粗哦%c第几位%d\n", str[i], i);</span></span><br><span class="line"><span class="keyword">if</span> (mi[i] == <span class="string">'0'</span>)</span><br><span class="line"><span class="comment">//如果是0进入左子树   如果是1进入右子树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf("is0do");</span></span><br><span class="line">temp = T[temp].lchild;</span><br><span class="line"><span class="comment">//printf("现在我的值是：%c\n", T[temp].ch);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mi[i] == <span class="string">'1'</span>)</span><br><span class="line">temp = T[temp].rchild;</span><br><span class="line"><span class="keyword">if</span> (T[temp].lchild == <span class="number">-1</span> &amp;&amp; T[temp].rchild == <span class="number">-1</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(wh==<span class="number">1</span>)<span class="comment">//如果该节点左右均为空 即到达字母结点 输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, T[temp].ch);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(wh==<span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s"</span>, T[temp].chh);</span><br><span class="line">temp = m;                                               <span class="comment">//重新回到根节点 进行下一字符的译码</span></span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 编码 </tag>
            
            <tag> 哈弗曼树 </tag>
            
            <tag> 译码 </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我眼中的操作系统中断</title>
      <link href="/2015/12/08/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%AD/"/>
      <url>/2015/12/08/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%AD/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/50224305" target="_blank" rel="noopener">点这里</a><br>没学过汇编和计算机组成原理就直接接触了操作系统，这是我根据个人理解目前用到的中断知识，以后应该会不断添加<br><a id="more"></a><br>1.中断是什么？<br>可以认为他是一种信号，它告诉处理器当下发生了一种需要特别注意的事情。<br>2.他存在的意义？<br>开中断和关中断是为了保证某段程序执行的原子性<br>3.他的最基本原理？<br>CPU接到中断请求信号，开始响应中断请求，外设在数据线上发射中断类型码，CPU接收到以后，将执行如下操作<br>1.将中断类型码放入暂存器保存，<br>2.将标志寄存器内容压入堆栈，以保护中断时的状态，<br>3.保护断点，<br>4.根据中断类型码，在中断向量表中找到对应的中断向量，将其装入IP,CS，即自动转向中断服务子程序<br>4.中断的分类<br>1）强迫性中断，自愿性中断<br>2）按中断源的性质和中断作用，中断可分为3种类型：<br>        一、硬中断<br>        硬中断就是由硬件引起的中断。有优先级别，这广泛用于I/O外设（操作系统I/O管理部分用到的中断），处理器可向外设发送一个命令并继续执行，外设执行指定命令并在需要与处理器通讯时开启一个中断，这种方式节约了大量CPU时间。<br>        二、软中断<br>        软中断是由中断指令(INT)引起的中断。软中断无优先级别，它是程序中执行一条INT指令产生的。在Linux0.11的bootset和setup中普遍应用的中断。<br>        三、表中断<br>        表中断永远不会被软件或硬件调用，只用于指明重要的信息表。（笔者才疏学浅，暂时未见应用）</p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 中断 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>蚁群算法</title>
      <link href="/2015/11/20/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
      <url>/2015/11/20/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/49952133" target="_blank" rel="noopener">点这里</a></p><p>自1991年由意大利学者 M. Dorigo，V. Maniezzo 和 A. Colorni 通过模拟蚁群觅食行为提出了一种基于种群的模拟进化算法——蚁群优化。<br><a id="more"></a></p><h2 id="蚁群算法简介"><a href="#蚁群算法简介" class="headerlink" title="蚁群算法简介"></a>蚁群算法简介</h2><p>自1991年由意大利学者 M. Dorigo，V. Maniezzo 和 A. Colorni 通过模拟蚁群觅食行为提出了一种基于种群的模拟进化算法——蚁群优化。该算法的出现引起了学者们的极大关注，蚁群算法的特点：</p><p> ① 其原理是一种正反馈机制或称增强型学习系统; 它通过【最优路径上蚂蚁数量的增加→信息素强度增加→后来蚂蚁选择概率增大→最优路径上蚂蚁数量更大增加】达到最终收敛于最优路径上L</p><p>② 它是一种通用型随机优化方法, 它吸收了蚂蚁的行为特(内在搜索机制) , 它是使用人工蚂蚁仿真(也称蚂蚁系统) 来求解问题L但人工蚂蚁决不是对实际蚂蚁的一种简单模拟, 它融进了人类的智能L人工蚂蚁有一定的记忆; 人工蚂蚁不完全是瞎的; 人工蚂蚁生活的时空是离散的L</p><p>③ 它是一种分布式的优化方法, 不仅适合目前的串行计算机, 而且适合未来的并行计算机L</p><p>④ 它是一种全局优化的方法, 不仅可用于求解单目标优化问题, 而且可用于求解多目标优化问题L</p><p>⑤ 它是一种启发式算法, 计算复杂性为o (Nc<em>n2</em>m) , 其中Nc 是迭代次数, m 是蚂蚁数目, n 是目的节点数目L</p><p>蚁群发现最短路径的原理和机制[1]</p><p>下面用图 1解释蚁群发现最短路径的原理和机制。</p><p>如图 1(a)所示，在蚁巢和食物源之间有两条道路 Nest-A-B-D-Food 和Nest-A-C-D-Food，其长度分别为 4 和 6。单位时间内蚂蚁可移动一个单位长度的距离。开始时所有路径上都没有外激素。</p><p>如图 1(b)，在 t=0 时刻，20 只蚂蚁从蚁巢出发移动到 A。由于路径上没有外激素，它们以相同概率选择左侧或右侧道路，因此平均有 10 只蚂蚁走左侧，另外 10 只走右侧。</p><p>如图 1(c)，在 t=4 时刻，第一组先到达食物源的蚂蚁将折回。</p><p>如图 1(d)，在 t=5 时刻，两组蚂蚁将在 D 点相遇。此时 BD 上的外激素数量与 CD 上的相同，因此返回的 10 只蚂蚁中有 5 只选择 BD 而另 5 只选择 CD。</p><p>如图 1(e)，在 t=8 时刻，前 5 个蚂蚁将返回巢穴，而在 AC、CD 和 AB 上各有 5 个蚂蚁。</p><p>如图 1(f)，在 t=9 时刻，前 5 个蚂蚁又回到 A 并且再次面对往左还是往右的选择。这时，AB 上的轨迹数是 20 而 AC 上是 15，因此将有较为多数的蚂蚁选择往右，从而增强了 AB 上外激素的量。随着该过程的继续，两条道路上外激素数量的差距将越来越大，直至绝大多数蚂蚁都选择了最短的路径。正是由于一条道路要比另一条道路短，因此，在相同的时间间隔内，短的路线会有更多的机会被选择。</p><p>根据仿生学家的研究结果,蚂蚁凭借路径寻优的能力能够找到蚁巢与食物之间的最短路径,其原理在于:蚂蚁在所经过的路径上留下一种挥发性分泌物(pheromone,以下称为信息素),信息素随着时间的推移会逐渐挥发消失.蚂蚁在觅食过程中能够感知这种物质的存在及其强度,并以此来指导自己的运动方向,倾向于朝着这种物质强度高的方向移动,即选择该路径的概率与当时这条路径上该物质的强度成正比.信息素强度越高的路径,选择它的蚂蚁就越多,则在该路径上留下的信息素的强度就更大,而强度大的信息素又吸引更多的蚂蚁,从而形成一种正反馈.通过这种正反馈,蚂蚁最终可以发现最佳路径,导致大部分的蚂蚁都会走此路径.</p><p>以求解ｎ个城市的ＴＳＰ旅行商问题为例说明ＡＣＡ模型.</p><p>设蚁群中蚂蚁的数量为ｍ,ｄij (ｉ,ｊ=1,2,…,ｎ)表示城市ｉ和城市ｊ之间的距离,ｂi(ｔ)表示ｔ时刻位于城市ｉ的蚂蚁的个数,则有 表示ｔ时刻在城市ｉ,ｊ连线上残留的信息量.初始时刻,各条路径上信息量相等,设τｉｊ(0)=Ｃ(Ｃ为常数).蚂蚁ｋ(ｋ=1,2,…,ｍ)在运动过程中,根据各条路径上的信息量决定转移方向. 表示在ｔ时刻蚂蚁ｋ由城市ｉ转移到城市ｊ的概率.</p><p>   （1）</p><p>残留信息的重要程度;β——启发信息的重要程度;tabuk——记录蚂蚁ｋ当前所走过的城市,称为记忆列表,ｋ=1,2,…,ｍ,集合tabuk随着进化过程作动态调整.经过ｎ个时刻,所有蚂蚁都完成了一次遍历.此时,计算每一只蚂蚁所走过的路径Ｌｋ,并保存最短路径Ｌｍｉｎ=ｍｉｎ{Ｌｋ︱ｋ=1,2,…,ｍ}.在蚂蚁完成一次循环以后,各路径上的信息量进行如下调整</p><p>τｉｊ(ｔ+1)=(1-ρ)τｉｊ(ｔ)+Δτｉｊ    (2)</p><p>式中ρ∈(0,1),表示信息素τｉｊ(ｔ)随时间的推移而衰减的程度.所以1-ρ为信息素残留因子，开始时Δτｉｊ（0）=0，</p><p>信息素增量Δτｉｊ可表示             (3)</p><p>式中Δτｋｉｊ为蚂蚁ｋ在本次循环中在城市ｉ和ｊ之间留下的信息量,它的计算公式根据具体问题而定.Dorigo曾给出Δτｋｉｊ3种不同的模型,分别称为Ant-Cycle模型、Ant-Quantity模型、Ant-Density模型，它们的区别就在于信息素的更新机制,即其差别在于Δτｋｉｊ</p><p>在Ant-Cycle模型中：</p><p>（4） 式中，Q表示信息素强度，它在一定程度上影响算法的收敛速度；Lk表示第K只蚂蚁在本次循环中所奏路径的总长度。</p><p>在Ant-Quantity模型中：</p><p>（5） 式中，Q表示信息素强度，它在一定程度上影响算法的收敛速度；dij表示第K只蚂蚁在t和t+1之间经过的（ i, j ）</p><p>在Ant-Density模型中：</p><p>（6） 区别:式(5)式(6)中利用的是局部信息，即蚂蚁完成一步后更新路径上的信息素；而式(4)中利用的是整体信息，即蚂蚁完成一个循环后所有路径上的信息素。经过大量试验总结研究，采用式(4)性能较好，所以 Ant-Cycle模型是最优的。</p><p>以上说明了信息素残留因子1-ρ、信息启发式因子α、期望启发式因子β、信息素强度Q、蚂蚁数目M等都是非常重要的参数，其选区方式和选区原则直接影响到蚁群算法的全局收敛性和求解效率。我们学习到这种“三步走”[2]选择蚁群算法最优组合参数的有效方法：</p><p>（1） 确定蚂蚁数目M，根据 城市规模 / 蚂蚁数目 ≈1.5的选择策略来确定蚂蚁的总数目。</p><p>（2） 参数粗调，即调整数值范围较大的信息启发式因子α、期望启发式因子β、信息素强度Q等参数，已得到较理想的解。</p><p>（3） 参数微调，即调整数值范围较小的信息素残留因子1-ρ。</p><h2 id="目前蚁群算法的应用"><a href="#目前蚁群算法的应用" class="headerlink" title="目前蚁群算法的应用"></a>目前蚁群算法的应用</h2><p>虽然对蚁群算法的研究时间不长, 但是初步研究已显示出它在求解复杂优化问题方面具有很大的优势, 特别是1998 年在比利时布鲁塞尔专门召开了第一届蚂蚁优化国际研讨会后, 现在每两年召开一次这样的蚂蚁优化国际研讨会。这标志着蚁群算法的研究已经得到了国际上的广泛支持，使得这种新兴的智能进化仿生算法展现出了勃勃生机[3]。</p><p>以蚁群算法为代表的群体智能已成为当今分布式人工智能研究的一个热点,许多源于蜂群和蚁群模型设计的算法已越来越多地被用于企业的运转模式的研究。美国五角大楼正在资助关于群体智能系统的研究工作–群体战略(SWARM STRATEGY),它的一个实战用途是通过运用成群的空中无人驾驶飞行器和地面车辆来转移敌人的注意力,让自己的军队在敌人后方不被察觉地安全行进。英国电信公司和美国世界通信公司以电子蚂蚁为基础,对新的电信网络管理方法进行了试验。群体智能还被应用于工厂生产计划的制定和运输部门的后勤管理。美国太平洋西南航空公司采用了一种直接源于蚂蚁行为研究成果的运输管理软件,结果每年至少节约了1000万美元费用开支。英国联合利华公司已率先利用群体智能技术改善其一家牙膏厂的运转状况。美国通用汽车公司,法国液气公司,荷兰公路交通部和美国一些移民事务机构也都采用这种技术来改善其运转的机能。又如美国MCIWorld.com公司一直研究人工蚂蚁，并用于管理公司的电话网，对用户记账收费等工作。另外，还设计“人工蚂蚁”打算用于因特网的路由管理。鉴于群体智能广阔的应用前景,美国和欧洲联盟均于近几年开始出资资助基于群体智能模拟的相关研究项目, 关在一些院校开设群体智能的相关课程.牛津大学出版社1999年版的E.Bonabeau和M.Dorigo等人编写的专著《群体智能:从自然到人工系统》(Swarm Intelligence:From Natural to Artificial System),以及2001年出版的J.Kennedy和R.Eberhart编著的《群体智能》(Swarm Intelligence)进一步扩大了群体智能的影响.IEEE进化计算会刊也于2002年8月出版了蚁群优化算特刊。国内也有研究者用蚂蚁算法求解全国144个城市的最短回路问题，求得的解同其它方法求到得解一样精确，这说明蚂蚁算法不但是求解组合优化问题的可行方法，而且是一种很有竞争力的算法。国家自然科学基金”十五”期间学科交叉类优先资助领域中的认知科学及其信息处理的研究内容中也明确列出了群体智能领域的进化,自适应与现场认知主题[4]。而且从1999年开始，几乎每年都会有几项相关项目获得资助。蚁群算法是一种新型的模拟进化算法，其在数据挖掘中的应用正逐步引起人们的关注。目前，人工蚁群在知识发现的过程中主要用于发掘聚类模型和分类模型。</p><h3 id="蚁群算法在数据挖掘中的应用"><a href="#蚁群算法在数据挖掘中的应用" class="headerlink" title="蚁群算法在数据挖掘中的应用"></a>蚁群算法在数据挖掘中的应用</h3><p>聚类是将一组对象分成若干个群体，每个群体构成一个簇，使得簇内的对象尽可能具有最大的相似性，不同簇之间的对象尽可能有最大的相异性。目前，聚类方法主要有K均值法，模糊聚类、神经网络聚类、基于遗传算法的聚类、小波变换聚类以及将这些算法有效结合而形成的改进方法。随着蚁群算法研究的兴起，人们发现在某些方面采用蚁群模型进行聚类更加接近实际的聚类问题。将蚁群算法用于聚类分析,灵感源于蚂蚁堆积他们的尸体和分类他们的幼体。基于蚁群算法的聚类方法从原理上可分为两种：一种是基于蚁堆形成原理来实现数据聚类，另一种是运用蚂蚁觅食的原理，利用信息来实现聚类分析。</p><p>而数据是数据挖掘的另一个重要主题，它是在数据库对象集合中寻找属性，并根据分类模式将其划分为不同类别的过程。分类过程利用历史数据记录自动推导出对给定数据的分类树。分类器构造方法有统计学方法、机器学习法、神经网络、决策树等。从知识发现的观点来看，分类规则的表达方式形如if&lt;条件&gt;then&lt;类&gt;规则前件（if 部分）包含一组条件集合，一般由逻辑连接符连接；规则结论（then部分）定义了样本的预测类，这些样本的预测属性满足规则前件所定义的所有条件[5]。将蚁群算法引入分类规则的发现，是利用蚁群觅食原理在数据库中进行搜索，对随机产生的一组规则进行选择优化，直到数据库能被该组规则覆盖，从而挖掘出隐含在数据库中的规则，建立最优的分类模型。蚁群算法搜索的初始条件为发现规则的集合为空，且训练集包含所有的训练样本。蚂蚁搜索一次要完成规则生成、规则剪枝、信息素更新三个任务。一次搜索生成一条规则，并且将这条规则加入发现规则集合，同时将该条规则所覆盖的训练样本从训练集中删除。如果未覆盖训练样本的数目大于用户定义的阈值，即最大未覆盖样本数，就反复执行上述过程，最终算法将得到一组最优分类规则集合[5]。 </p><p>最早在这一领域开展工作的是Deneubourg 等[6],他们根据数据对象与其周围对象的相似性,让蚂蚁随机地移动、拾起或放下数据对象,以达到聚类数据的目的,这个基本模型已成功地应用于机器人领域。Lumer 等首先改进此算法,提出了LF算法。Wu 等、Ramos等、Yang等[7]从不同角度对LF算法进行了改进,在用蚁群算法进行聚类分析方面取得了一定成效。近几年，学者在这方面的研究从来没有间断过，也取得了一定的研究成果。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>不过，将蚁群算法运用于数据发掘还存在一些问题，需要进一步研究：</p><p>（1）如何将现实的挖掘任务转换成蚁群求解的问题空间，并用适当的方式表达。如何定义“人工蚂蚁”以及蚂蚁间的非直接通信方式（如路径上的信息素、对象的分布状态等）的选择。</p><p>（2）如何建立正反馈机制，定义启发函数，递增地进行问题求解，并且使得到的解与问题定义中现实世界的情况相对应。</p><p>（3）基于蚁群的算法要初始化大量的参数，这些参数的选择会对算法的性能产生较大的影响，但其选取的方法和原则目前尚无理论上的依据，只能通过多次实验调优，因此参数的最佳设置原则还有待进一步研究。</p><p>（4）蚁群算法的搜索时间较长，如何将蚁群算法与遗传算法、免疫算法等优化算法相结合，改善和提高算法性能，以适应海量数据库的知识发现。</p><p>所以如何在数据挖掘中运用蚁群算法快速、高效地获得高质量的知识越来越受到人们的关注，逐渐成为近期的研究热点[5]。</p><h2 id="Matlab实现蚁群算法"><a href="#Matlab实现蚁群算法" class="headerlink" title="Matlab实现蚁群算法"></a>Matlab实现蚁群算法</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[R_best,L_best,L_ave,Shortest_Route,Shortest_Length]</span>=<span class="title">ACATSP</span><span class="params">(C,NC_max,m,Alpha,Beta,Rho,Q)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%-------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 主要符号说明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% C n个城市的坐标，n×2的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% NC_max 最大迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% m 蚂蚁个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Alpha 表征信息素重要程度的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Beta 表征启发式因子重要程度的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Rho 信息素蒸发系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Q 信息素增加强度系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% R_best 各代最佳路线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% L_best 各代最佳路线的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%=========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第一步：变量初始化</span></span><br><span class="line"></span><br><span class="line">n=<span class="built_in">size</span>(C,<span class="number">1</span>);<span class="comment">%n表示问题的规模（城市个数）</span></span><br><span class="line"></span><br><span class="line">D=<span class="built_in">zeros</span>(n,n);<span class="comment">%D表示完全图的赋权邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">i</span>~=<span class="built_in">j</span></span><br><span class="line"></span><br><span class="line">D(<span class="built_in">i</span>,<span class="built_in">j</span>)=((C(<span class="built_in">i</span>,<span class="number">1</span>)-C(<span class="built_in">j</span>,<span class="number">1</span>))^<span class="number">2</span>+(C(<span class="built_in">i</span>,<span class="number">2</span>)-C(<span class="built_in">j</span>,<span class="number">2</span>))^<span class="number">2</span>)^<span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">D(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="built_in">eps</span>;      <span class="comment">%i=j时不计算，应该为0，但后面的启发因子要取倒数，用eps（浮点相对精度）表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">D(<span class="built_in">j</span>,<span class="built_in">i</span>)=D(<span class="built_in">i</span>,<span class="built_in">j</span>);   <span class="comment">%对称矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Eta=<span class="number">1.</span>/D;          <span class="comment">%Eta为启发因子，这里设为距离的倒数</span></span><br><span class="line"></span><br><span class="line">Tau=<span class="built_in">ones</span>(n,n);     <span class="comment">%Tau为信息素矩阵</span></span><br><span class="line"></span><br><span class="line">Tabu=<span class="built_in">zeros</span>(m,n);   <span class="comment">%存储并记录路径的生成</span></span><br><span class="line"></span><br><span class="line">NC=<span class="number">1</span>;               <span class="comment">%迭代计数器，记录迭代次数</span></span><br><span class="line"></span><br><span class="line">R_best=<span class="built_in">zeros</span>(NC_max,n);       <span class="comment">%各代最佳路线</span></span><br><span class="line"></span><br><span class="line">L_best=<span class="built_in">inf</span>.*<span class="built_in">ones</span>(NC_max,<span class="number">1</span>);   <span class="comment">%各代最佳路线的长度</span></span><br><span class="line"></span><br><span class="line">L_ave=<span class="built_in">zeros</span>(NC_max,<span class="number">1</span>);        <span class="comment">%各代路线的平均长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> NC&lt;=NC_max        <span class="comment">%停止条件之一：达到最大迭代次数，停止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第二步：将m只蚂蚁放到n个城市上</span></span><br><span class="line"></span><br><span class="line">Randpos=[];   <span class="comment">%随即存取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:(<span class="built_in">ceil</span>(m/n))</span><br><span class="line"></span><br><span class="line">Randpos=[Randpos,randperm(n)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Tabu(:,<span class="number">1</span>)=(Randpos(<span class="number">1</span>,<span class="number">1</span>:m))';    <span class="comment">%此句不太理解？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第三步：m只蚂蚁按概率函数选择下一座城市，完成各自的周游</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">2</span>:n     <span class="comment">%所在城市不计算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m    </span><br><span class="line"></span><br><span class="line">visited=Tabu(<span class="built_in">i</span>,<span class="number">1</span>:(<span class="built_in">j</span><span class="number">-1</span>)); <span class="comment">%记录已访问的城市，避免重复访问</span></span><br><span class="line"></span><br><span class="line">J=<span class="built_in">zeros</span>(<span class="number">1</span>,(n-<span class="built_in">j</span>+<span class="number">1</span>));       <span class="comment">%待访问的城市</span></span><br><span class="line"></span><br><span class="line">P=J;                      <span class="comment">%待访问城市的选择概率分布</span></span><br><span class="line"></span><br><span class="line">Jc=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:n</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(<span class="built_in">find</span>(visited==k))==<span class="number">0</span>   <span class="comment">%开始时置0</span></span><br><span class="line"></span><br><span class="line">J(Jc)=k;</span><br><span class="line"></span><br><span class="line">Jc=Jc+<span class="number">1</span>;                         <span class="comment">%访问的城市个数自加1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%下面计算待选城市的概率分布</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">length</span>(J)</span><br><span class="line"></span><br><span class="line">P(k)=(Tau(visited(<span class="keyword">end</span>),J(k))^Alpha)*(Eta(visited(<span class="keyword">end</span>),J(k))^Beta);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">P=P/(sum(P));</span><br><span class="line"></span><br><span class="line"><span class="comment">%按概率原则选取下一个城市</span></span><br><span class="line"></span><br><span class="line">Pcum=cumsum(P);     <span class="comment">%cumsum，元素累加即求和</span></span><br><span class="line"></span><br><span class="line">Select=<span class="built_in">find</span>(Pcum&gt;=<span class="built_in">rand</span>); <span class="comment">%若计算的概率大于原来的就选择这条路线</span></span><br><span class="line"></span><br><span class="line">to_visit=J(Select(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>)=to_visit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> NC&gt;=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Tabu(<span class="number">1</span>,:)=R_best(NC<span class="number">-1</span>,:);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第四步：记录本次迭代最佳路线</span></span><br><span class="line"></span><br><span class="line">L=<span class="built_in">zeros</span>(m,<span class="number">1</span>);     <span class="comment">%开始距离为0，m*1的列向量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</span><br><span class="line"></span><br><span class="line">R=Tabu(<span class="built_in">i</span>,:);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">L(<span class="built_in">i</span>)=L(<span class="built_in">i</span>)+D(R(<span class="built_in">j</span>),R(<span class="built_in">j</span>+<span class="number">1</span>));    <span class="comment">%原距离加上第j个城市到第j+1个城市的距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">L(<span class="built_in">i</span>)=L(<span class="built_in">i</span>)+D(R(<span class="number">1</span>),R(n));      <span class="comment">%一轮下来后走过的距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">L_best(NC)=min(L);           <span class="comment">%最佳距离取最小</span></span><br><span class="line"></span><br><span class="line">pos=<span class="built_in">find</span>(L==L_best(NC));</span><br><span class="line"></span><br><span class="line">R_best(NC,:)=Tabu(pos(<span class="number">1</span>),:); <span class="comment">%此轮迭代后的最佳路线</span></span><br><span class="line"></span><br><span class="line">L_ave(NC)=mean(L);           <span class="comment">%此轮迭代后的平均距离</span></span><br><span class="line"></span><br><span class="line">NC=NC+<span class="number">1</span>                      <span class="comment">%迭代继续</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第五步：更新信息素</span></span><br><span class="line"></span><br><span class="line">Delta_Tau=<span class="built_in">zeros</span>(n,n);        <span class="comment">%开始时信息素为n*n的0矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">Delta_Tau(Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>),Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>+<span class="number">1</span>))=Delta_Tau(Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>),Tabu(<span class="built_in">i</span>,<span class="built_in">j</span>+<span class="number">1</span>))+Q/L(<span class="built_in">i</span>);          </span><br><span class="line"></span><br><span class="line"><span class="comment">%此次循环在路径（i，j）上的信息素增量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Delta_Tau(Tabu(<span class="built_in">i</span>,n),Tabu(<span class="built_in">i</span>,<span class="number">1</span>))=Delta_Tau(Tabu(<span class="built_in">i</span>,n),Tabu(<span class="built_in">i</span>,<span class="number">1</span>))+Q/L(<span class="built_in">i</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%此次循环在整个路径上的信息素增量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Tau=(<span class="number">1</span>-Rho).*Tau+Delta_Tau; <span class="comment">%考虑信息素挥发，更新后的信息素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第六步：禁忌表清零</span></span><br><span class="line"></span><br><span class="line">Tabu=<span class="built_in">zeros</span>(m,n);             <span class="comment">%%直到最大迭代次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%第七步：输出结果</span></span><br><span class="line"></span><br><span class="line">Pos=<span class="built_in">find</span>(L_best==min(L_best)); <span class="comment">%找到最佳路径（非0为真）</span></span><br><span class="line"></span><br><span class="line">Shortest_Route=R_best(Pos(<span class="number">1</span>),:) <span class="comment">%最大迭代次数后最佳路径</span></span><br><span class="line"></span><br><span class="line">Shortest_Length=L_best(Pos(<span class="number">1</span>)) <span class="comment">%最大迭代次数后最短距离</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)                  <span class="comment">%绘制第一个子图形</span></span><br><span class="line"></span><br><span class="line">DrawRoute(C,Shortest_Route)     <span class="comment">%画路线图的子函数</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)                  <span class="comment">%绘制第二个子图形</span></span><br><span class="line"></span><br><span class="line">plot(L_best)</span><br><span class="line"></span><br><span class="line">hold on                         <span class="comment">%保持图形</span></span><br><span class="line"></span><br><span class="line">plot(L_ave,<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line">title(<span class="string">'平均距离和最短距离'</span>)     <span class="comment">%标题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DrawRoute</span><span class="params">(C,R)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%=========================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% DrawRoute.m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画路线图的子函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%-------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% C Coordinate 节点坐标，由一个N×2的矩阵存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% R Route 路线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%=========================================================================</span></span><br><span class="line"></span><br><span class="line">N=<span class="built_in">length</span>(R);</span><br><span class="line"></span><br><span class="line">scatter(C(:,<span class="number">1</span>),C(:,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line">plot([C(R(<span class="number">1</span>),<span class="number">1</span>),C(R(N),<span class="number">1</span>)],[C(R(<span class="number">1</span>),<span class="number">2</span>),C(R(N),<span class="number">2</span>)],<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ii=<span class="number">2</span>:N</span><br><span class="line"></span><br><span class="line">plot([C(R(ii<span class="number">-1</span>),<span class="number">1</span>),C(R(ii),<span class="number">1</span>)],[C(R(ii<span class="number">-1</span>),<span class="number">2</span>),C(R(ii),<span class="number">2</span>)],<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">hold on</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title(<span class="string">'旅行商问题优化结果 '</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蚁群算法，算法设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>01-复杂度1 最大子列和问题   (20分)</title>
      <link href="/2015/10/12/%E5%A4%8D%E6%9D%82%E5%BA%A61%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2015/10/12/%E5%A4%8D%E6%9D%82%E5%BA%A61%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/49075887" target="_blank" rel="noopener">点这里</a><br>给定K个整数组成的序列{ N<sub>1</sub>, N<sub>2</sub>, …, N<sub>K</sub>}，“连续子列”被定义为{ N<sub>i</sub>, N<sub>i+1</sub>, …, N<sub>j</sub>}，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。<br><a id="more"></a></p><p>输入格式:<br>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。</p><p>输出格式:<br>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p><p>输入样例:<br>6<br>-2 11 -4 13 -5 -2<br>输出样例:<br>20</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> rs;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">   <span class="keyword">for</span>(i;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">  rs=MaxSum(a,n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,rs);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> thisSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j;j&lt;n;j++)&#123;</span><br><span class="line">            thisSum+=a[j];</span><br><span class="line">         <span class="comment">//   printf("%d",thisSum);</span></span><br><span class="line">            <span class="keyword">if</span>(thisSum&gt;maxSum)&#123;</span><br><span class="line">                maxSum=thisSum;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(thisSum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            thisSum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1.读取数组问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(i;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时a就是数组名，a+i就是平时所说的a[i]；</p><p>待解决问题：当数组长度未知时的解决</p><p>2.函数调用过程中数组的传递</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSum</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>这是函数声明顺序</p><p>MaxSum(a,n)这是在函数main方法中调用函数，其中a就是数组名</p><p>这两点是与java不同的</p><p>3.另外，这种算法的复杂度为n</p><p>待解决问题：当数组长度未知时的解决</p>]]></content>
      
      <categories>
          
          <category> 算法设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构，算法设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git学习笔记</title>
      <link href="/2015/10/12/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2015/10/12/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/49233969" target="_blank" rel="noopener">点这里</a></p><p>吐血推荐一个学习git的网站：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰教程</a></p><a id="more"></a><p>1.公共秘钥问题</p><p>导致无法连接远程git仓库</p><p>提醒为fatal：could not read from remote repository.</p><p>2.github图形化界面怎么用</p><p>这个有廖老师教程</p><p>3.github图形化直接点击发布可以同步到网络，本地如何实现？</p><p> –已解决</p><p>4分支的使用：</p><p>查看分支：git branch</p><p>创建分支：git branch <name></name></p><p>切换分支：git checkout <name></name></p><p>创建+切换分支：git checkout -b<name></name></p><p>合并某分支到当前分支：git merge <name></name></p><p>删除分支：git branch -d <name></name></p><p>5多人协作的工作模式通常是这样：</p><p>首先，可以试图用git push origin branch-name推送自己的修改；<br>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>如果合并有冲突，则解决冲突，并在本地提交；<br>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！<br>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p>远程问题如果不可以，可以先试试克隆远程仓库</p><p>取消别名 git config –global –unset alias.st</p><p>学到的知识：</p><p>1下载使用gitbash，通过命令行创建一个仓库，写文件传文件，分支，修改文件，回退，与github建立关系，通过图形界面push ，clone，与他人一起协作。</p><p>待巩固：github网站的熟悉使用，还有request等注意编码格式。</p>]]></content>
      
      <categories>
          
          <category> 学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql的安装及完全卸载</title>
      <link href="/2015/10/07/Mysql%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD/"/>
      <url>/2015/10/07/Mysql%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%9A%84%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/48947193" target="_blank" rel="noopener">点这里</a><br>不完全卸载的话安装后也会有各种问题~</p><a id="more"></a><ul><li><p><strong>5.0的安装</strong></p><ul><li>众所周知，mysql5.0是提供图形界面安装程序的，首先下载mysql-essential-5.0.22-win32.msi文件，MSI格式直接双击选择合适安装路径安装/*不建议安装在c盘</li><li>安装完成后，去mysql目录下的bin文件夹中选择有图标的.exe格式（我把5.0卸了忘记文件名叫什么了）双击打开</li><li>一般直接点next就可安装完成</li></ul></li><li><p><strong>mysql的卸载</strong></p><ul><li>第一步，在运行工具中输入regedit，将注册表中关于mysql的注册表全部删除（Ctrl+f直接查找mysql）</li><li>第二步，以管理员身份打开命令行，直接输cs mysql delete, 将mysql服务从电脑中彻底删除（要先在电脑服务项中找到mysql并关闭服务），</li><li>第三步，在控制面板中的卸载程序中删除mysql</li><li>第四步，去相应文件夹下删除mysql文件夹，并在c盘 program data（默认隐藏）文件夹中删除mysql文件夹</li><li>最后就可以重启电脑</li></ul></li><li><p><strong>5.6的安装</strong></p><ul><li>以管理员身份运行命令行，</li><li><img src="http://img.blog.csdn.net/20151007102020960" alt="一直输入到这里"></li><li>然后输入：mysqld -install</li><li>如果提示“success”之类的，恭喜安装成功</li><li>成功后，输入mysql直接回车，如果出现这个<img src="http://img.blog.csdn.net/20151007102309528" alt="恭喜成功"></li><li>最后推荐一款图形界面管理工具<img src="http://img.blog.csdn.net/20151007102431390" alt="可以开始使用了"></li></ul></li></ul><ul><li><strong>写在最后</strong><br>-笔者水平有限，安装过程各种错误层出不穷，不过只要按照上面正确的步骤，便可避免很多错误，还有问题直接在留言板问即可。不足或者不对之处，欢迎指正，在此谢过！  </li></ul>]]></content>
      
      <categories>
          
          <category> 学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安装 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓--活动（Activity）--个人总结</title>
      <link href="/2015/05/14/%E5%AE%89%E5%8D%93--%E6%B4%BB%E5%8A%A8--%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2015/05/14/%E5%AE%89%E5%8D%93--%E6%B4%BB%E5%8A%A8--%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/45704485" target="_blank" rel="noopener">点这里</a><br>纲要：这篇文章总结了活动的基本用法，手动创建活动，创建响应并认识了活动的生命周期</p><a id="more"></a><p>1.在活动中使用toast(一种比较合适的提醒方式)，首先要注册一个活动     &lt;activity…../activity&gt;<br>2.学会了在活动中使用menu：onCreatOptionsMenu()方法&lt;menu…&gt;&lt;item…/&gt;&lt;item…/&gt;<br>   还要定义菜单响应事件，重写onOptionItemSelected（）方法<br>3.如果想通过代码销毁活动，要用finish（）方法；<br>4.在活动之间使用Intent(显式，隐式)显式，新建Intent类，并把构建好的Intent传入startActivity（）；<br>隐式，每个Intent只能指定一个action但却可指定多个category。<br>5.关于活动的生命周期<br>1）有一个生命周期示意图<br>Activity类里的7个回调方法1.onCreate()2.onStart()3.onReaume()4.onPause()5.onStop()6.onDestory()7.onRestart()<br>2）活动生存期：1.完整生存期，2可见生存期3.前台生存期<br>3）关于活动被回收的问题：如果活动在回收之前有通过onSaveInstanceState（）方法来保存数据的话，这个参数将带有之前保存的全部数据<br>4）关于活动的启动模式1.standard:Log.d(“FirstActivity”，this.toString())2.singleTop:&lt;activity  andorid:launchMode=”singleTop”…./activity&gt;3.singleTask&lt;activity  andorid:launchMode=”singleTask”…./activity&gt;<br>4.singleInatance&lt;activity  andorid:launchMode=”singleInatance”…./activity&gt;<br>5）（总结）关于启动活动的最佳写法：<br>在SecondActivity中添加一个actionStart（）方法，在这个方法中完成了Intent的构建，另外所有SecondActivity中需要的数据都是通过actionStart（）方法的参数传递过来的，然后把它们储存在Intent中，最后再调用startActivity（）方法启动SecondActivity。</p>]]></content>
      
      <categories>
          
          <category> 学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
            <tag> 移动开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>课设有感--第一份博客给已经逝去的Java课堂</title>
      <link href="/2015/05/13/%E8%AF%BE%E8%AE%BE%E6%9C%89%E6%84%9F--%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%8D%9A%E5%AE%A2%E7%BB%99%E5%B7%B2%E7%BB%8F%E9%80%9D%E5%8E%BB%E7%9A%84Java%E8%AF%BE%E5%A0%82/"/>
      <url>/2015/05/13/%E8%AF%BE%E8%AE%BE%E6%9C%89%E6%84%9F--%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%8D%9A%E5%AE%A2%E7%BB%99%E5%B7%B2%E7%BB%8F%E9%80%9D%E5%8E%BB%E7%9A%84Java%E8%AF%BE%E5%A0%82/</url>
      <content type="html"><![CDATA[<p>本文在CSDN的地址：<a href="https://blog.csdn.net/idevede/article/details/45679619" target="_blank" rel="noopener">点这里</a><br>经过短暂的八周的Java程序设计，终于把你画我猜的基本功能实现，看着自己用代码砌成的程序可以运行的接近自己的想法，使我不仅技术进步，能用代码去解决实际的问题了，更重要的，提高了我的编程兴趣，使我下意识留出时间每天编程。</p><a id="more"></a><h2 id="项目开发中遇到的困难及解决"><a href="#项目开发中遇到的困难及解决" class="headerlink" title="项目开发中遇到的困难及解决"></a>项目开发中遇到的困难及解决</h2><p>课程设计过程中，错误和困难可谓常客，遇到的状况大大小小多多少少，到交结果之前，总算被我们解决了。</p><p>谈到遇到的困难，在图形界面部分，主要的有两点，一是界面布局问题，如何在有限的空间实现最多的功能，让界面友好，交互流畅困扰了我很久，从开始写界面到现在，我组前前后后换了三次界面，试过最复杂的网格布局管理器，最终还是一个像素一个像素的规定了每个组件的位置，第二就是画图时鼠标移动过快就连不成线的问题，为此我逛过不少论坛，查了好多字资料，最终也把它给解决了；至于网络编程，与其说是方法问题到不如说是理解问题，从来没有接触过网络和多线程原理的我和组员在编写网络时用了过半数的时间来理解他们如何运行；谈到数据库，就不得不说在已经搞明白数据库如何使用，这次课程设计要用到哪些sql语句之后还没有安上数据库的苦痛，在mysql5.6上，删除了引导配置文件，网上的配置教程又众说纷纭，试过近百种方法的我最终还是安装上了数据库，这个问题花掉了好多不该花的时间，不过错误给成长铺路，最后我也能帮别人按数据库了。</p><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><p>短短8周，刚开始接触画图方法的有点无知的我还历历在目，因为装个数据库而忙忙碌碌近一周的我仿  若昨日，如今的我，也能帮助同学配置数据库了，不自觉会有一点小小的成就感。写到如今，再回首自己这八周来时的路，每一个凌晨1:00过后面对看似一点都没有进步的程序也没少崩溃，但在程序每一个小功能的实现的乐趣的吸引和队友不时的鼓励下，最终还是完成了任务。这让我明白了那句话：“每一个努力过后没有进步的背后，不是没有成长，而是在扎根”。</p><p>这次课程设计，不仅让我掌握了老师课堂上讲的知识，更重要的，让我提高了自己的自学能力，好多之前没有见过的类都通过API，逛论坛搞明白了他的方法，看着自己编写的程序一步步完善，我开始更加喜欢编程，开始努力写出完美的代码。除此之外，我还得到了一些有用的教训：写程序时必须要细心，不能输错一个字符标点，就连全角半角也得注意。在修改时要有耐心，编译出错后必须逐个错误去改正，绝不能心急浮躁，否则修改之后还会有新的错误。错误要从头开始看，要直面错误。</p><p>课设结束，Java结课，以后就没有专门的Java课程了，可是这次课设带给我的对Java魅力的领悟和对自我成长的欣慰，会这样陪着我编程道路上一步一个脚印的走下去。</p>]]></content>
      
      <categories>
          
          <category> 学习心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
            <tag> Java </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
